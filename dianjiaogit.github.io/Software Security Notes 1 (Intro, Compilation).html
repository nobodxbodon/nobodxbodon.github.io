<h2><a href="https://github.com/dianjiaogit/dianjiaogit.github.io/blob/master/_posts/2021-02-23-SS notes.md">仓库源文</a>，<a href="https://dianjiaogit.github.io/notes/software%20security/2021/02/23/SS-notes">站点原文</a></h2>
<hr/>
<p>layout: post
title:  "Software Security Notes 1 (Intro, Compilation)"
date:   2021-2-23 07:00:00 +0800</p>
<h2>categories: [Notes, Software Security]</h2>
<h3>Fundamentals of binary analysis:</h3>
<ul>
<li>binary format  </li>
<li>disassembly  </li>
<li>code injection  </li>
</ul>
<h3>Exploitations techniques:</h3>
<ul>
<li>stack-based exploitation  </li>
<li>heap exploitation  </li>
</ul>
<h3>Vulnerability discovery:</h3>
<ul>
<li>binary instrumentaion  </li>
<li>fuzzing  </li>
<li>symbolic execution  </li>
</ul>
<p>&lt;br /&gt;</p>
<hr/>
<p>&lt;br /&gt;</p>
<h2>Binary analysis:</h2>
<p>program -&gt; machine code<br/>
security gap<br/>
what high level program does VS what it really does</p>
<p>Focus on Linux binary (ELF) and x86 assembly.</p>
<h3>Static analysis:</h3>
<p>Analysing without running it.<br/>
platform independent<br/>
Less precise. Generally udecidable.</p>
<h3>Dynamic analysis:</h3>
<p>Runs the binary as it executes<br/>
More precise. Access to entire system states<br/>
May miss some code. See particular runs. Not all possible.</p>
<h2>Challenges in binary analysis:</h2>
<p>No symbolic information<br/>
No type information<br/>
No high-level abstraction<br/>
Mixed code and data<br/>
Location dependent data and code</p>
<h2>Loading and Executing:</h2>
<p>Representation in-memory may differ from on-disk representation<br/>
Setting up a new process, virtual address space.<br/>
Maps an interpreter into virtual memory<br/>
Transfer control to interpreter<br/>
In Linux, interpreter is a shared library called <em>Id-linux</em>.so</p>
<h3>Interpretere:</h3>
<p>Loads binary into virtual address space.<br/>
Maps required dynamic libraried into virtual address space<br/>
Relocation if required</p>
<ul>
<li>usually lazy-binding<br/>
Transfer control to the entry point  </li>
</ul>
<p>&lt;br /&gt;</p>
<hr/>
<p>&lt;br /&gt;</p>
<h2>Compilation:</h2>
<p>normal code -&gt; machine code</p>
<ul>
<li>preprocessing  </li>
<li>compilation  </li>
<li>assembly  </li>
<li>linking  </li>
</ul>
<p>GCC does all by default, but any of the steps can be stopped.</p>
<h3>Compiler:</h3>
<p>Input preprocessed source files<br/>
Output Assembly files<br/>
normal code -&gt; assembly<br/>
Optimization<br/>
-S flag to stop after compiler<br/>
Default is AT&amp;T syntax, use -masm=intel to change to Intel syntax</p>
<p>e.g. gcc -S -masm=Intel example.c</p>
