<h2><a href="https://github.com/dianjiaogit/dianjiaogit.github.io/blob/master/_posts/2021-03-09-SS notes.md">仓库源文</a>，<a href="https://dianjiaogit.github.io/notes/software%20security/2021/03/09/SS-notes">站点原文</a></h2>
<h2>Function Dectection</h2>
<p>Called directly by the $call$ instruction.<br/>
Indirect all is hard to dectect.</p>
<h2>Object-Oriented Code</h2>
<p>We only discuss about C code in this course</p>
<h2>Structuring Data</h2>
<p>Automatic data struction detection in stripped binaries is a notoriouly difficult problem<br/>
Some codes can be compiled into similar instructions</p>
<h2>Decompilation</h2>
<p>Guessing function signatures and local variables<br/>
Recovering control flows and function calls</p>
<p>Intermediate Representation</p>
<ul>
<li>Abstration  </li>
<li>Goal: translate Machine code to IR code   </li>
</ul>
<h1>Binary Analysis Properties</h1>
<p>Interprocedural and intraprocedural<br/>
Flow sensitivity<br/>
Context sensitivity</p>
<h2>Intraprocedural</h2>
<p>Code within a single function at a time</p>
<ul>
<li>Maybe incomplete</li>
</ul>
<h2>Interprocedural</h2>
<p>Consider entire program as a whole</p>
<ul>
<li>Might take long so results no longer matter.  </li>
</ul>
<h2>Flow Sensitivity</h2>
<p>Take the order of the instructions into account.<br/>
Either flow-sensitive or flow-insensitive.</p>
<ul>
<li>flow-sensitive more conplex.  </li>
</ul>
<h2>Context Sensitivity</h2>
<p>Take the order of the function invocation into account.</p>
<h2>Loop Detection</h2>
<p>Implemented using $jump$ instructions.<br/>
Most execution time is spent in loops.<br/>
Buffer overflow tends in occur in loops.</p>
<p>Compilers use dominance trees to determine natural loops.</p>
<h2>Reaching Definition Analysis</h2>
<p>Reachable data definitions from this point.<br/>
CFG level.<br/>
Which can reach at the start.  Which can still be alive after.</p>
<h2>Program Slicing</h2>
<p>Find irrelevant slices and remove them.</p>
