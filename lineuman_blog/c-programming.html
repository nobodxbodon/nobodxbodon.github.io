<h2><a href="https://github.com/lineuman/blog/blob/master/_posts/2017-06-23-c-programming.md">仓库源文</a>，<a href="https://lineuman_blog/2017/06/23/c-programming">站点原文</a></h2>
<hr/>
<h2>layout: post
tags: [c]</h2>
<p>真的是太欣赏c的速度了，但如果你连c的指针计算都搞不定，那就好比你活生生的错过了绝世美女,如果真的是那样，人生就太遗憾了。</p>
<h2>c常见问题</h2>
<ol>
<li><p>double free:free已经free的内存。</p>
</li>
<li><p>访问已经释放的内存</p>
</li>
</ol>
<h2>gcc</h2>
<h2>gdb</h2>
<h2>glibc</h2>
<h2>/usr/include</h2>
<p><a href="https://en.wikibooks.org/wiki/C_Programming/Simple_input_and_output">https://en.wikibooks.org/wiki/C_Programming/Simple_input_and_output</a></p>
<h3>data types</h3>
<p>In Standard C there are four basic data types. They are int, char, float, and double.</p>
<h3>output and input</h3>
<p>printf</p>
<pre><code>%d  int
%f  float
%c  char
%s   string
%p pointer
</code></pre>
<p>scanf</p>
<p>it might read as: "Read in an integer from the user and store it at the address of variable a ".</p>
<pre><code>scanf("%d", &amp;a);

</code></pre>
<pre><code>scanf("%s", a);
</code></pre>
<p><strong>This is because, whenever you use a format specifier for a string (%s), the variable that you use to store the value will be an array and, the array names (in this case - a) themselves point out to their base address and hence, the address of operator is not required.</strong></p>
<h3>oprator</h3>
<pre><code>   &amp;         Address-of; value is the location of the operand(取地址)
   
   *         Contents-of; value is what is stored at the location（取内容）
</code></pre>
<p>或与非</p>
<pre><code>||
&amp;&amp;
!
</code></pre>
<h2>Control flow</h2>
<h3>if</h3>
<pre><code>if (conditions)
{
// do something
}
else if (conditions)
{
// do otherthing
}
else
{
// do something
}
</code></pre>
<h3>for</h3>
<pre><code>int i = 0;
for(i=0;i&lt;100;i++)
{
  printf("%d", i);
}
</code></pre>
<h3>while</h3>
<pre><code>int i = 0;
while (i &lt; 100)
{
 //do something
 i++;
}
</code></pre>
<h3>do...while</h3>
<pre><code>do{
}while(condition)
</code></pre>
<h3>break continue</h3>
<p>break 跳出循环</p>
<p>continue 跳出本次循环</p>
<h3>goto</h3>
<pre><code>Start:
   if (!''cond1'') goto End;
   S;
   if (''cond2'') goto End;
   T;
   goto Start;
 End:
   /* ... */
</code></pre>
<h3>switch case</h3>
<pre><code> switch (something) {
 case 2:
 case 3:
 case 4:
   /* some statements to execute for 2, 3 or 4 */
   break;
 case 1:
 default:
   /* some statements to execute for 1 or other than 2,3,and 4 */
   break;
 }
</code></pre>
<h2>Pointers and arrays</h2>
<p>指针是地址</p>
<p>指针变量是用来存放指针的变量</p>
<p>空指针的存放的值为0</p>
<pre><code>#include &lt;stdio.h&gt;

int main () {

   int  *ptr = NULL;

   printf("The value of ptr is : %x\n", ptr  );
 
   return 0;
}
When the above code is compiled and executed, it produces the following result −

The value of ptr is 0
</code></pre>
<p>指针算数
<a href="https://www.tutorialspoint.com/cprogramming/c_pointer_arithmetic.htm">https://www.tutorialspoint.com/cprogramming/c_pointer_arithmetic.htm</a>
有四种算数操作符可以应用到指针变量上面，<code>++</code>, <code>--</code>, <code>+</code>, <code>-</code></p>
<h3>Incrementing a Pointer</h3>
<h3>Decrementing a Pointer</h3>
<h3>Pointer Comparisons</h3>
<p>sizeof</p>
<h2>glibc一些函数</h2>
<p><a href="https://www.tutorialspoint.com/c_standard_library/stdio_h.htm">https://www.tutorialspoint.com/c_standard_library/stdio_h.htm</a></p>
<h3>stdlib.h</h3>
<pre><code>void *malloc(size_t size); //使用malloc分配的内存是没有初始化的
void *calloc(size_t nitems, size_t size)
 
</code></pre>
<h3>stdio.h</h3>
<pre><code>int puts(const char *str)
printf()
scanf()
sprintf()
sprintf_s()
snprintf()
snprintf_s()
</code></pre>
<h3>string.h</h3>
<pre><code>strcpy()
strlen()

strncpy()
strncpy_s()
memset()
</code></pre>
