<h2>原文：<a href="https://www.barretlee.com/2016/09/28/ieee754-operation-in-js">揭秘 0.1 + 0.2 != 0.3</a></h2>
<hr/>
<p>title: '揭秘 0.1 + 0.2 != 0.3'
description: 在采用 IEEE754 浮点数标准的语言中，0.1 + 0.2 都不会等于 0.3，但是 0.2 + 0.3 却等于 0.5，这是为何？想必这类问题也困扰着不少程序员。
warning: true
date: 2016-09-28 23:05:23
categories:</p>
<ul>
<li>前端杂烩</li>
<li>JavaScript
tags:</li>
<li>IEEE754</li>
</ul>
<hr/>
<p>"0.1 + 0.2 = ?"，这道题如果给小学生，他会立马告诉你答案是 0.3，但是交给一些程序去计算，结果就不是那么简单了。</p>
<p><img alt="math" src="/media/wwww/share/study/聚聚/源数据/博客聚合/www.barretlee.com../blogimgs/2016/09/28/6c0378f8gw1f89pd8hm96j20p00dwacm.jpg"/>&lt;!--&lt;source src="http://ww4.sinaimg.cn/large/6c0378f8gw1f89pd8hm96j20p00dwacm.jpg"&gt;--&gt;</p>
<p>&lt;!-- more --&gt;</p>
<p>事实上，不仅仅是 JS，在其他采用 IEEE754 浮点数标准的语言中，0.1 + 0.2 都不会等于 0.3，但是 0.2 + 0.3 却等于 0.5，这是为何？想必这类问题也困扰着不少程序员。</p>
<h3>IEEE754 浮点数的演算</h3>
<p>我们知道，科学计数法中 30000 可以写成 3x10&lt;sup&gt;4&lt;/sup&gt;，以 10 为底数 4 为指数的科学计数法。在 IEEE754 标准中是比较类似的，只不过它是二进制数，底数也为 2。</p>
<p>IEEE 754 中最常用的浮点数值表示法是：单精确度（32位）和双精确度（64位），JavaScript 采用的是后者。举个例子，十进制数 150，使用双精度浮点数表示法，表示如下：</p>
<pre><code class="language-javascript">// D 表示十进制，B 表示二进制
150D = 2^8 * 0.1001011B // 后面省略了 46 个 0
</code></pre>
<p>可以通过短除法计算：</p>
<pre><code>   150   余数位
÷    2
---------------
    75     0   
÷    2
---------------
    37     1
÷    2
---------------
    18     1
÷    2
---------------
     9     0
÷    2
---------------
     4     1
÷    2
---------------
     2     0
÷    2
---------------
     1     0
÷    2
---------------
     0     1
</code></pre>
<p>最后一个余数为高位值，于是拿到 150 对应的二进制数位 <code>1001011</code>，也就等于 <code>2^8 * 0.1001011</code>。</p>
<p>上面是整数的表示法，而小数的表示法采用的是乘二取整，如 0.1，它的二进制表示为：</p>
<pre><code class="language-javascript">// (0011) 表示循环
0.1D = 2^-3 * 0.110011(0011)
</code></pre>
<p>其演算方法如下：</p>
<pre><code>    0.1   整数位
×     2
---------------
    0.2     0 
×     2
---------------
    0.4     0   * ↓
×     2
---------------
    0.8     0 
×     2
---------------
    1.6     1 
×     2
---------------
    1.2     1
×     2
---------------
    0.4     0   * ↑
             (0011循环)
</code></pre>
<p>与整数不同的是，第一个计算得到的整数位为最高位，故 0.1 对应的二进制数为 <code>0.000110011(0011)</code>，也就等于 <code>2^-3 0.1100110011(0011)</code>。</p>
<p>如果一个数既包含整数部分，又包含小数部分，其表示法的计算，需要分拆为整数和小数两部分，然后相加得到结果。</p>
<h3>IEEE754 浮点数精度丢失</h3>
<p>IEEE754 浮点数表示法的数据格式如下图：</p>
<pre><code class="language-javascript">// 下图采用大端表示，高位在左，低位在右。

sign  exponent         fraction
+---+----------+---------------------+
| 1 |   2~12   |         13~64       |
+---+----------+---------------------+
</code></pre>
<ul>
<li>符号位：高位第 1 位，如图 sign 部分</li>
<li>指数位：高位第 2~12 位，如图 exponent 部分</li>
<li>尾数位：剩下的 fraction 部分</li>
</ul>
<p>从上面小数的乘二取整演算中可以看到，有些小数对应的二进制数是无法写全的，比如 0.1，而 fraction 尾数部分有要求，只允许 52 位，超过部分进一舍零。</p>
<p>那么，我们就可以得到：</p>
<pre><code>0.1D 
= 2^-4 * 1.10011(0011)B
= 2^-4 * 1.10011(0011 repeat 12 times)0011B // ← 最后一位为 1，进 1
= 2^-4 * 1.10011(0011 repeat 12 times)010B
</code></pre>
<h3>揭秘 0.1 + 0.2</h3>
<p>根据上面我们了解到的知识，我们可以很容易算出这些值：</p>
<pre><code class="language-javascript">0.1D = 2^-4 * 1.1001100110011001100110011001100110011001100110011010B
0.2D = 2^-3 * 1.1001100110011001100110011001100110011001100110011010B
0.3D = 2^-2 * 1.0011001100110011001100110011001100110011001100110011B
</code></pre>
<p><code>0.1 + 0.2</code> 时，先将两者指数统一为 -3，故 0.1 小数点向左移一位，于是：</p>
<pre><code>   0.1100110011001100110011001100110011001100110011001101B
+  1.1001100110011001100110011001100110011001100110011010B
------------------------------------------------------------
= 10.0110011001100110011001100110011001100110011001100111B
</code></pre>
<p>得到的二进制数为：</p>
<pre><code>10.0110011001100110011001100110011001100110011001100111B
</code></pre>
<p>小数点往左移一位使得整数部分为 1，此时尾数部分为 53 位，进一舍零，于是得到最后的值是：</p>
<pre><code>2^-2 * 1.0011001100110011001100110011001100110011001100110100
</code></pre>
<p>这个值转化成真值，结果为：<code>0.30000000000000004</code>。那么 <code>0.1 + 0.2 = 0.30000000000000004</code> 的推演到这里就结束了。</p>
<h3>相关验证</h3>
<p>毕竟咱们手动计算可能存在笔误，可以通过一个叫做 <code>double-bits</code> 的 npm 进行推演，我写了一个小 demo，感兴趣的可以玩耍下：</p>
<pre><code class="language-javascript">const db = require('double-bits');
const pad = require('pad');

// [lo, hi] where lo is a 32 bit integer and hi is a 20 bit integer.
const base2Str = (n) =&gt; {
  const f = db.fraction(n);
  const s = db.sign(n) ? '-' : '';
  const e = `2^${db.exponent(n) + 1}`;
  const t = `0.${pad(f[1].toString(2), 20, '0')}${pad(f[0].toString(2), 32, '0')}`;
  return `${s}${e} * ${t}`;
};

console.log(base2Str(0.1).toString(2));
console.log(base2Str(0.2).toString(2));
console.log(base2Str(0.3).toString(2));
console.log(base2Str(1.2).toString(2));
</code></pre>
<p>上面输出结果为：</p>
<pre><code class="language-javascript">2^-3 * 0.11001100110011001100110011001100110011001100110011010
2^-2 * 0.11001100110011001100110011001100110011001100110011010
2^-1 * 0.10011001100110011001111001100110011001100110011001100
2^1 * 0.10011001100110011001111001100110011001100110011001100
</code></pre>
<h3>最后</h3>
<p>为了按照计算机的思维，IEEE754 的标准来计算 <code>0.1 + 0.2</code>，又重新复习了一遍大学计算机基础的知识，原码、反码、补码，以及除二取余、乘二取整计算法，最后能够推演出来，也算是一个胜利吧~</p>
<h3>更多阅读</h3>
<ul>
<li><a href="http://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE 754 Converter</a></li>
<li><a href="https://zh.wikipedia.org/wiki/IEEE_754">维基百科 IEEE 754</a></li>
</ul>
<hr/>
<p>题图：<a href="https://unsplash.com/search/math?photo=5mZ_M06Fc9g">math</a> by Roman Mager</p>
<p><em><strong>笔耕不辍，欢迎关注微信公众号小胡子哥（barretlee_com），分享生活，分享技术，我在那里等你。</strong></em></p>
