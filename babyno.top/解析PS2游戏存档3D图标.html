<h2><a href="https://github.com/caol64/caol64.github.io/blob/master/content/posts/2023/2023-10-04-parsing-ps2-3d-icon.md">仓库源文</a>，<a href="https://babyno.top/posts/2023/10/04/parsing-ps2-3d-icon">站点原文</a></h2>
<p><img alt="" src="/Users/xuanwu/work/聚聚/中文博客集锦/源数据/博客聚合/babyno.top/content/imgs/posts/2023-10-04-parsing-ps2-3d-icon/1.gif"/></p>
<p>看到这个图片，对于熟悉PS2的老玩家来说应该不会陌生。它是PS2记忆卡管理界面中的游戏存档3D图标。本篇文章我们将介绍如何从存档文件里解析出这个活动的小人。</p>
<h2>01 解析目标</h2>
<p>A：我们能从存档文件中解析到什么？</p>
<ul>
<li>图标模型的所有顶点、法线</li>
<li>图标模型的动作帧</li>
<li>光照</li>
<li>纹理及纹理坐标</li>
<li>背景颜色及透明度</li>
</ul>
<p>B：我们需要做什么？</p>
<ul>
<li>编写着色器渲染背景和图标</li>
<li>将图标模型的动作帧组成动画</li>
<li>构建模型矩阵、视图矩阵、透视矩阵，使显示接近PS2原生效果</li>
</ul>
<p>完成整个功能估计需要两篇文章，本篇主要介绍A。</p>
<h2>02 解析<code>icon.sys</code></h2>
<p>上一篇我们介绍了如何导出游戏的存档文件，事实上每个存档里都会有一个<code>icon.sys</code>的文件，这个可以看作图标的配置文件。<code>icon.sys</code>是一个固定大小（964字节）的文件，其结构如下：</p>
<table>
<thead><tr>
<th>offset</th>
<th>length</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>byte[4]</td>
<td><code>magic</code>：PS2D</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>uint16</td>
<td>0</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>uint16</td>
<td>游戏标题换行符所在位置，注1</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>uint32</td>
<td>0</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>uint32</td>
<td><code>bg_transparency</code>，背景透明度，0-255</td>
</tr>
<tr>
<td><strong>16</strong></td>
<td>uint32[4]</td>
<td><code>bg_color</code>，背景左上角颜色（RGB-，0-255）</td>
</tr>
<tr>
<td><strong>32</strong></td>
<td>uint32[4]</td>
<td><code>bg_color</code>，背景右上角颜色（RGB-，0-255）</td>
</tr>
<tr>
<td><strong>48</strong></td>
<td>uint32[4]</td>
<td><code>bg_color</code>，背景左下角颜色（RGB-，0-255）</td>
</tr>
<tr>
<td><strong>64</strong></td>
<td>uint32[4]</td>
<td><code>bg_color</code>，背景右下角颜色（RGB-，0-255）</td>
</tr>
<tr>
<td><strong>80</strong></td>
<td>uint32[4]</td>
<td><code>light_pos1</code>，光源1（XYZ-，0-1）</td>
</tr>
<tr>
<td><strong>96</strong></td>
<td>uint32[4]</td>
<td><code>light_pos2</code>，光源2（XYZ-，0-1）</td>
</tr>
<tr>
<td><strong>112</strong></td>
<td>uint32[4]</td>
<td><code>light_pos3</code>，光源3（XYZ-，0-1）</td>
</tr>
<tr>
<td><strong>128</strong></td>
<td>uint32[4]</td>
<td><code>light_color1</code>，光源1颜色（RGB-，0-1）</td>
</tr>
<tr>
<td><strong>144</strong></td>
<td>uint32[4]</td>
<td><code>light_color2</code>，光源2颜色（RGB-，0-1）</td>
</tr>
<tr>
<td><strong>160</strong></td>
<td>uint32[4]</td>
<td><code>light_color3</code>，光源3颜色（RGB-，0-1）</td>
</tr>
<tr>
<td><strong>176</strong></td>
<td>uint32[4]</td>
<td><code>ambient</code>，环境光（RGB-，0-1）</td>
</tr>
<tr>
<td><strong>192</strong></td>
<td>byte[68]</td>
<td><code>sub_title</code>，游戏标题（空字符结尾, S-JIS编码）</td>
</tr>
<tr>
<td><strong>260</strong></td>
<td>byte[64]</td>
<td><code>icon_file_normal</code>，普通图标文件名（空字符结尾），注2</td>
</tr>
<tr>
<td><strong>324</strong></td>
<td>byte[64]</td>
<td><code>icon_file_copy</code>，拷贝图标文件名（空字符结尾），注2</td>
</tr>
<tr>
<td><strong>388</strong></td>
<td>byte[64]</td>
<td><code>icon_file_delete</code>，删除图标文件名（空字符结尾），注2</td>
</tr>
<tr>
<td><strong>452</strong></td>
<td>byte[512]</td>
<td>全0</td>
</tr>
</tbody>
</table>
<p>注1：游戏标题<code>sub_title</code>显示为2行，该值即为在标题的第几个字节换行，如图：</p>
<p><img alt="" src="/Users/xuanwu/work/聚聚/中文博客集锦/源数据/博客聚合/babyno.top/content/imgs/posts/2023-10-04-parsing-ps2-3d-icon/1.jpg"/></p>
<p>注2：每个游戏存档可以对应3个图标<code>icon</code>文件，分别在不同场景显示。</p>
<p>可以看到<code>icon.sys</code>文件里主要提供了背景、光照等数据，另外一个比较重要的部分是3d图标所在的文件名。</p>
<h2>03 解析<code>icon</code>文件</h2>
<p>不像<code>icon.sys</code>文件，每个游戏的<code>icon</code>文件是不确定的，大小不确定，数量也不确定，但至少会有1个。有的游戏拷贝图标和删除图标与普通图标共用一个图标。</p>
<h3>3.1 文件结构</h3>
<table>
<thead><tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Icon头</td>
<td>固定大小，20个字节</td>
</tr>
<tr>
<td>顶点段</td>
<td>保存图标模型的所有顶点和法线数据</td>
</tr>
<tr>
<td>动画段</td>
<td>保存图标模型动画帧信息</td>
</tr>
<tr>
<td>纹理段</td>
<td>保存图标模型纹理</td>
</tr>
</tbody>
</table>
<h3>3.2 <code>Icon</code>头</h3>
<p><code>Icon</code>头存储了我们解码不同数据段所需的所有重要信息，其中包括：</p>
<ul>
<li>“顶点段”中包含的顶点数量以及动画形状的数量</li>
<li>纹理数据是否经过压缩</li>
</ul>
<p>在图标文件中，<code>Icon</code>头总是位于偏移量 0 处。以下是<code>Icon</code>头结构：</p>
<table>
<thead><tr>
<th>Offset</th>
<th>Length</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>uint32</td>
<td><code>magic</code>：<code>0x010000</code></td>
</tr>
<tr>
<td>0004</td>
<td>uint32</td>
<td><code>animation_shapes</code>，动画形状，注1</td>
</tr>
<tr>
<td>0008</td>
<td>uint32</td>
<td><code>tex_type</code>，纹理类型，注2</td>
</tr>
<tr>
<td>0012</td>
<td>uint32</td>
<td>未知，固定值<code>0x3F800000</code></td>
</tr>
<tr>
<td>0016</td>
<td>uint32</td>
<td><code>vertex_count</code>，顶点数量，必定是3的倍数</td>
</tr>
</tbody>
</table>
<p>注1：图标模型有几套不同的顶点数据，对应不同的动作，称之为“形状”。将不同的形状循环渲染，即可形成动画效果。</p>
<p>注2：“纹理类型”这部分尚不明确，该值是4字节整形，我总结出来每个位相应的功能如下表，未必正确：</p>
<table>
<thead><tr>
<th>mask</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0001</td>
<td>未知</td>
</tr>
<tr>
<td>0010</td>
<td>未知</td>
</tr>
<tr>
<td>0100</td>
<td>图标文件中存在纹理数据，有些游戏（如ICO）没有纹理数据，图标全黑</td>
</tr>
<tr>
<td>1000</td>
<td>图标文件中的纹理数据是被压缩过的</td>
</tr>
</tbody>
</table>
<h3>3.3 顶点段</h3>
<p>PS2 图标中的多边形总是由三个顶点形成的三角形组成。由于顶点是按一定规律排列的，因此只需按照规律读取顶点数据，就能轻松构建多边形。利用<code>OpenGL</code>或类似工具渲染这些数据，就能得到一个漂亮的图标线框。</p>
<p>“顶点段”包含图标中所有顶点的数据。每个顶点数据包含一组顶点坐标、法线坐标、纹理坐标以及一组<code>RGBA</code>数据，因此，拥有<code>m</code>个顶点和 <code>n</code>个形状的“顶点段”数据结构如下：</p>
<p><img alt="" src="/Users/xuanwu/work/聚聚/中文博客集锦/源数据/博客聚合/babyno.top/content/imgs/posts/2023-10-04-parsing-ps2-3d-icon/%E5%AD%98%E5%82%A8%E5%8D%A1-Vertex.jpg"/></p>
<h4>顶点坐标</h4>
<p>每个顶点坐标占用8字节，结构如下：</p>
<table>
<thead><tr>
<th>Offset</th>
<th>Length</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>int16</td>
<td>X坐标，使用时需除以4096</td>
</tr>
<tr>
<td>0002</td>
<td>int16</td>
<td>Y坐标，使用时需除以4096</td>
</tr>
<tr>
<td>0004</td>
<td>int16</td>
<td>Z坐标，使用时需除以4096</td>
</tr>
<tr>
<td>0006</td>
<td>uint16</td>
<td>未知</td>
</tr>
</tbody>
</table>
<h4>法线坐标</h4>
<p>每个法线坐标与顶点坐标数据结构一致。</p>
<h4>纹理坐标</h4>
<p>每个纹理坐标占用4字节，结构如下：</p>
<table>
<thead><tr>
<th>Offset</th>
<th>Length</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>int16</td>
<td>U坐标，使用时需除以4096</td>
</tr>
<tr>
<td>0002</td>
<td>int16</td>
<td>V坐标，使用时需除以4096</td>
</tr>
</tbody>
</table>
<h4>顶点RGBA</h4>
<p>每个顶点颜色占用4字节，结构如下：</p>
<table>
<thead><tr>
<th>Offset</th>
<th>Length</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>uint8</td>
<td>R，0-255</td>
</tr>
<tr>
<td>0001</td>
<td>uint8</td>
<td>G，0-255</td>
</tr>
<tr>
<td>0002</td>
<td>uint8</td>
<td>B，0-255</td>
</tr>
<tr>
<td>0003</td>
<td>uint8</td>
<td>A，0-255</td>
</tr>
</tbody>
</table>
<h3>3.4 动画段</h3>
<p>很遗憾关于“动画段”里的大部分内容，我还没完全搞懂含义。不过不用太在意，利用“顶点坐标插值”，仍然可以完成动画动作。</p>
<p>以下是“动画段”的数据结构：</p>
<p><img alt="" src="/Users/xuanwu/work/聚聚/中文博客集锦/源数据/博客聚合/babyno.top/content/imgs/posts/2023-10-04-parsing-ps2-3d-icon/%E5%AD%98%E5%82%A8%E5%8D%A1-Animation.jpg"/></p>
<p>“动画段”包含“动画头”和若干“动画帧”，每个“动画帧”包含若干“关键帧”。</p>
<h4>动画头</h4>
<p>“动画头”结构如下：</p>
<table>
<thead><tr>
<th>Offset</th>
<th>Length</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>uint32</td>
<td><code>magic</code>：0x01</td>
</tr>
<tr>
<td>0004</td>
<td>uint32</td>
<td><code>frame length</code>：“动画帧”完成一个循环所需的“播放帧”，根据这个值可以计算出每个“动画帧”对应的“播放帧”数量</td>
</tr>
<tr>
<td>0008</td>
<td>float32</td>
<td><code>anim speed</code>：播放速度，作用未知</td>
</tr>
<tr>
<td>0012</td>
<td>uint32</td>
<td><code>play offset</code>：起始播放帧，作用未知</td>
</tr>
<tr>
<td>0016</td>
<td>uint32</td>
<td><code>frame count</code>：“动画段”一共有几个“动画帧”，一般一个“形状”对应一个“动画帧”</td>
</tr>
</tbody>
</table>
<h4>帧数据<code>Frame Data</code></h4>
<p>“帧数据”直接位于“动画头”之后。</p>
<table>
<thead><tr>
<th>Offset</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>u32</td>
<td>Shape id</td>
</tr>
<tr>
<td>0004</td>
<td>u32</td>
<td>Number of keys</td>
</tr>
<tr>
<td>0008</td>
<td>u32</td>
<td>UNKNOWN</td>
</tr>
<tr>
<td>0012</td>
<td>u32</td>
<td>UNKNOWN</td>
</tr>
</tbody>
</table>
<h4>关键帧<code>Frame Key</code></h4>
<table>
<thead><tr>
<th>Offset</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>f32</td>
<td>Time</td>
</tr>
<tr>
<td>0004</td>
<td>f32</td>
<td>Value</td>
</tr>
</tbody>
</table>
<h3>3.5 纹理段</h3>
<p>纹理是像素为<code>128x128</code>的图片，使用<code>TIM</code>图像格式进行编码。根据<code>Icon头</code>里的<code>tex_type</code>字段，纹理分为未压缩和压缩两种类型。</p>
<h4>未压缩纹理</h4>
<p>未压缩纹理的像素格式为<code>BGR555</code>，其中B、G、R各占用5<code>bit</code>，总共15<code>bit</code>，占用2字节（1个<code>bit</code>冗余）。如图：</p>
<pre><code>High-order byte:    Low-order byte:
X B B B B B G G     G G G R R R R R

X = Don't care, R = Red, G = Green, B = Blue
</code></pre>
<p>因此原始图片大小固定为128x128x2字节。如果需将它的像素格式转为<code>RGB24</code>，可以用如下方法：</p>
<pre><code>High-order byte:     Middle-order byte:    Low-order byte:
R R R R R 0 0 0      G G G G G 0 0 0       B B B B B 0 0 0
</code></pre>
<p>将5<code>bit</code>的色彩值转为8<code>bit</code>时，需将低3位补0。经过上述转换，每像素字节数变为3字节。同理也可将格式转为<code>RGBA32</code>，每像素字节数变为4字节。</p>
<h4>压缩纹理</h4>
<p>压缩纹理使用非常简单的<code>RLE</code>算法进行压缩。第一个<code>u32</code>是压缩纹理数据的大小。其后的数据始终为<code>u16</code>的<code>rle_code</code>和<code>rle_data</code>交替出现，直到结束。
<code>rle_data</code>有两个变量：<code>data</code>数量<code>x</code>和重复次数<code>y</code>。<code>rle_code</code>作为计数器存在，如果小于<code>0xFF00</code>，则<code>x = 1</code>，<code>y = rle_code</code>；如果大于等于<code>0xFF00</code>，则<code>x = (0x10000 - rle_code)</code>，<code>y = 1</code>。如下图。</p>
<p><img alt="" src="/Users/xuanwu/work/聚聚/中文博客集锦/源数据/博客聚合/babyno.top/content/imgs/posts/2023-10-04-parsing-ps2-3d-icon/%E5%AD%98%E5%82%A8%E5%8D%A1-RLE.jpg"/></p>
<p>将压缩纹理解压后，再根据上一节的内容即可转换为<code>RGB24</code>或<code>RGBA32</code>的图片。</p>
<h2>04 结尾</h2>
<p>至此为止图标的相关文件已经解析完毕了，万事俱备只欠东风，下一篇我们即将开始渲染模式，使用<code>PyGame</code>和<code>ModernGL</code>将渲染动画显示出来。</p>
<h2>05 参考资料</h2>
<ul>
<li><a href="https://www.ps2savetools.com/documents/iconsys-format/">gothi - icon.sys format</a></li>
<li><a href="http://www.csclub.uwaterloo.ca:11068/mymc/ps2icon-0.5.pdf">Martin Akesson - PS2 Icon Format v0.5</a></li>
</ul>
