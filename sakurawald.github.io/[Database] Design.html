<h2><a href="https://github.com/sakurawald/sakurawald.github.io/blob/master/source/_posts/database-design.md">仓库源文</a>，<a href="https://sakurawald.github.io/posts/database-design">站点原文</a></h2>
<h1>Database Design</h1>
<p>{% raw %}
$$
\boxed{@}
% Color %
\newcommand\c[2]{\textcolor{#1}{#2}}
\newcommand\r[1]{\textcolor{red}{#1}}
\newcommand\g[1]{\textcolor{green}{#1}}
\newcommand\b[1]{\textcolor{blue}{#1}}
\newcommand\red[1]{\textcolor{red}{#1}}
\newcommand\blue[1]{\textcolor{blue}{#1}}
\newcommand\green[1]{\textcolor{green}{#1}}
\newcommand\black[1]{\textcolor{black}{#1}}
\newcommand\white[1]{\textcolor{white}{#1}}
\newcommand\cyan[1]{\textcolor{cyan}{#1}}
\newcommand\magenta[1]{\textcolor{magenta}{#1}}
\newcommand\yellow[1]{\textcolor{yellow}{#1}}
\newcommand\orange[1]{\textcolor{orange}{#1}}
\newcommand\lime[1]{\textcolor{lime}{#1}}
\newcommand\pink[1]{\textcolor{pink}{#1}}
\newcommand\darkgray[1]{\textcolor{darkgray}{#1}}
\newcommand\gray[1]{\textcolor{gray}{#1}}
\newcommand\lightgray[1]{\textcolor{lightgray}{#1}}
\newcommand\brown[1]{\textcolor{brown}{#1}}
\newcommand\olive[1]{\textcolor{olive}{#1}}
\newcommand\purple[1]{\textcolor{purple}{#1}}
\newcommand\teal[1]{\textcolor{teal}{#1}}
\newcommand\violet[1]{\textcolor{violet}{#1}}
\newcommand\hotpink[1]{\textcolor{hotpink}{#1}}
\newcommand\blueviolet[1]{\textcolor{blueviolet}{#1}}
\newcommand\navyblue[1]{\textcolor{navyblue}{#1}}
\newcommand\peach[1]{\textcolor{Peach}{#1}}
\newcommand\orangeRed[1]{\textcolor{OrangeRed}{#1}}
\newcommand\salmon[1]{\textcolor{Salmon}{#1}}
\newcommand\skyblue[1]{\textcolor{SkyBlue}{#1}}
\newcommand\springreen[1]{\textcolor{SpringGreen}{#1}}
\newcommand\aqua[1]{\textcolor{aqua}{#1}}
\newcommand\navy[1]{\textcolor{navy}{#1}}
\newcommand\silver[1]{\textcolor{silver}{#1}}
\newcommand\fuchsia[1]{\textcolor{fuchsia}{#1}}
\newcommand\maroon[1]{\textcolor{maroon}{#1}}
\definecolor{luo}{RGB}{102,204,255}
\definecolor{miku}{RGB}{57,197,187} 
\newcommand\luo[1]{\textcolor{luo}{#1}}
\newcommand\miku[1]{\textcolor{miku}{#1}}</p>
<p>% Typography %
\newcommand\a[1]{\begin{aligned}#1\end{aligned}}
\newcommand\t[1]{\text{#1}}
\newcommand\tb[1]{\text{\textcolor{blue}{#1}}}
\newcommand\lb[1]{\left{\begin{aligned} #1 \end{aligned}\right.}
\newcommand\lrb[1]{\lb{\rb{#1}}}
\newcommand\rb[1]{\left.\begin{aligned} #1 \end{aligned}\right}}
\newcommand\env[2]{\begin{#1}#2\end{#1}}
\newcommand\step[1]{\textbf{ (#1) }}</p>
<p>% Misc %
\newcommand\s[1]{{#1}}
\newcommand\qed{\quad\square}
\newcommand\define{\dot{=}}
\newcommand\then{\implies}
\newcommand\rounddown[1]{\lfloor{#1}\rfloor}
\newcommand\roundup[1]{\lceil{#1}\rceil}
\newcommand\graph[4]{#1 = (#2, #3) \quad |#2| = #4}
\newcommand\G{G = (V, E) \quad |V| = n}
\newcommand\so{\therefore}
\newcommand\comment[1]{\quad\text{(#1)}}
\newcommand\note[1]{\quad\text{(#1)}}
\newcommand\bt[1]{\boxed{\text{#1}}}
\newcommand\max[1]{\textbf{ max } {#1} }
\newcommand\min[1]{\textbf{ min } {#1} }
\newcommand\IF{\textbf{ IF }}
\newcommand\if{\textbf{ if }}
\newcommand\IS{\textbf{ IS }}
\newcommand\is{\textbf{ is }}
\newcommand\do{\textbf{ do }}
\newcommand\dowhile{\textbf{ do while }}
\newcommand\dountil{\textbf{ do until }}
\newcommand\find{\textbf{ find }}
\newcommand\until{\textbf{ until }}
\newcommand\thereisa{\textbf{ There is a }}
\newcommand\thereisan{\textbf{ There is an }}
\newcommand\hasno{\textbf{ has no }}
\newcommand\has{\textbf{ has }}
\newcommand\but{\textbf{ but }}
\newcommand\however{\textbf{ however }}
\newcommand\AND{\textbf{ AND }}
\newcommand\OR{\textbf{ OR }}
\newcommand\NOT{\textbf{ NOT }}
\newcommand\THEN{\textbf{ THEN }}
\newcommand\IN{\textbf{ in }}
\newcommand\NOTIN{\textbf{ NOT-IN }}
\newcommand\assume{\textbf{ Assuming that: }}
\newcommand\contradictory{\textbf{ Thus lead to contradiction }}
\newcommand\proof{\textbf{Proof: }}
\newcommand\st{\textbf{ such that }}
\newcommand\hold{\text{ holds }}
\newcommand\lhs{\text{ LHS }}
\newcommand\rhs{\text{ RHS }}
\newcommand\wlg{\text{ Without loss of generality }}
\newcommand\nb{\text{ nota bene }}
\newcommand\analogously{\text{ analogously }}
\newcommand\viceversa{\textbf{ viceversa }}
\newcommand\let{\textbf{ let }}
\newcommand\as{\textbf{ as }}
\newcommand\for{\textbf{ As for }}
\newcommand\select{\textbf{ SELECT }}
\newcommand\m[1]{\mathit{#1}}
\newcommand+[1]{\mathcal{#1}}
\newcommand\warnning[1]{\colorbox{Blue}{\textcolor{Yellow}{#1}}}
\newcommand\error[1]{\colorbox{Black}{\textcolor{White}{#1}}}
$$</p>
<p>{% endraw %}</p>
<h2>Design Process</h2>
<p>$$
\t{Design Process} \lb{
&amp; \t{Design Stage} \lb{
&amp; \t{Conceptual-Design Phase} \
&amp; \t{Logical-Design Phase} \
&amp; \t{Physical-Design Phase}
} \</p>
<p>&amp; \t{Design Choice}
}
$$</p>
<h2>Entity-Relationship Model</h2>
<p><code>E-R模型</code> 采用3个 <code>基本概念</code>：<code>实体集</code>，<code>联系集</code>，<code>属性</code></p>
<h3>Entity-Set</h3>
<p><code>实体 (Entity)</code>：可区别于所有其他对象的一个对象，通过一组 <code>属性</code> 来表示。</p>
<p><code>实体集 (Entity-Set)</code>：<code>相同类型</code> 的 <code>实体</code> 的 <code>集合</code>。</p>
<h3>Relationship-Set</h3>
<p><code>联系 (Relationship)</code>：指 <code>多个实体</code> 之间的 <code>相互关联</code>。</p>
<p><code>联系集 (Relationship-Set)</code>：<code>相同类型</code> 的 <code>联系</code> 的 <code>集合</code>。</p>
<ul>
<li><code>描述性属性 (Descriptive Attribute)</code></li>
<li><code>度 (Degree)</code>：参与 <code>联系集</code> 的 <code>实体集</code> 的 <code>数目</code></li>
</ul>
<blockquote><p>练习机： 的即<code>实体</code> 之间的 <code>关联</code> ，<code>实体集</code> $E_1, E_2,\cdots, E_n$ <code>参与</code> <code>联系集</code> $R$</p>
<p><code>角色 (Role)</code>：<code>实体</code> 在 <code>联系</code> 中扮演的 <code>功能</code></p>
<blockquote><p><code>自环联系集 (Recursive Relationship-Set)</code>：即存在 <code>实体集</code> 以 <code>不同的身份</code> 参与 <code>联系</code></p>
</blockquote>
</blockquote>
<h3>Attribute</h3>
<p><code>域 (Domain)</code> / <code>值集 (Value Set)</code> ：<code>属性</code> 的 <code>可取值集合</code></p>
<p><code>属性</code> 有以下几种 <code>分类方式</code>
$$
\t{Attribute} \lb{
&amp; \t{Classification 1} \lb{
&amp; \t{Simple Attribute} \
&amp; \t{Composite Attribute}
} \
&amp; \t{Classification 2} \lb{
&amp; \t{Single-Valued Attribute} \
&amp; \t{Multi-Valued Attribute}
} \
&amp; \t{Derived Attribute}</p>
<p>}
$$</p>
<h4>Single Attribute &amp; Composite Attribute</h4>
<p><code>复合属性 (Composite Attribute)</code> 由 <code>简单属性 (Simple Attribute)</code> 所组成。</p>
<blockquote><p>实际上，<code>同样的概念</code> 可能是 <code>复合属性</code> 也可能是 <code>简单属性</code>，这取决于 <code>具体需求</code>。</p>
<p>同理，对于 <code>单值属性</code> 和 <code>多值属性</code> 也有类似的情况。</p>
</blockquote>
<pre><code class="lang-mermaid">graph TD;
address --&gt; state(state)
address --&gt; city(city)
address(address) --&gt; street(street)
address --&gt; postal_code(postal_code)
street --&gt; street_number(street_number)
street --&gt; street_name(street_name)
street --&gt; apartment_number(apartment_number)
</code></pre>
<h4>Single-Valued Attribute &amp; Multi-Valued Attribute</h4>
<p><code>多值属性</code> 使用 <code>花括号</code> 包围 <code>属性名</code>：$\s{phone_numer}$</p>
<table>
<thead><tr>
<th>id</th>
<th>name</th>
<th>phone_number</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Alice</td>
<td>12345678901&lt;br /&gt;12345678902&lt;br /&gt;12345678903</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>12345678904</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<h4>Derived Attribute</h4>
<p><code>派生属性 (Derived Attribute)</code>  可以通过 <code>其他属性</code> 导出。</p>
<p>如 <code>age</code> 可以通过 <code>birthday</code> 导出。</p>
<h3>Constraint</h3>
<p><code>约束 (Constraint)</code> 是 <code>数据库中的数据</code> 必须要满足的 <code>条件</code></p>
<h4>Mapping Cardinality</h4>
<p><code>映射基数 (Mapping Cardinality)</code> 用于表示 一个 <code>实体</code> 通过 一个 <code>联系集</code> 所 <code>能能关联的实体个数</code>。</p>
<p>常见的 <code>映射基数</code>  如下：</p>
<ul>
<li><code>one-to-one</code></li>
</ul>
<pre><code class="lang-mermaid">graph LR;
subgraph A
a1
a2
a3
a4
end

subgraph B
b1
b2
b3
end

a1 --- b1
a2 --- b2
a3 --- b3
</code></pre>
<ul>
<li><code>one-to-many</code></li>
</ul>
<pre><code class="lang-mermaid">graph LR;
subgraph A
a1
a2
a3
end

subgraph B
b1
b2
b3
b4
b5
end

a1 --- b1
a1 --- b2
a2 --- b3
</code></pre>
<ul>
<li><code>many-to-one</code></li>
</ul>
<pre><code class="lang-mermaid">graph LR;
subgraph A
a1
a2
a3
a4
a5
end

subgraph B
b1
b2
b3
end

a1 --- b1
a2 --- b1
a3 --- b2
</code></pre>
<ul>
<li><code>many-to-many</code></li>
</ul>
<pre><code class="lang-mermaid">graph LR;
subgraph A
a1
a2
a3
a4
end

subgraph B
b1
b2
b3
b4
end
a1 --- b1
a1 --- b2
a2 --- b1
a3 --- b3
</code></pre>
<blockquote><p>n.b. <code>一</code> 只能表示 <code>确切地要有1个实体</code>，而 <code>多</code> 可以是 <code>零个或多个实体</code>。</p>
<p>这里所说的 <code>实体个数</code> 都是 <code>至多的实体个数</code></p>
</blockquote>
<h4>Participation Constraint</h4>
<p>$$
\t{Participation Constraint} \lb{
&amp; \t{Total Participation} \
&amp; \t{Partial Participation}
}
$$</p>
<p><code>全部参与 (Total Participation)</code>： <code>实体集</code> $E$ 的 <code>每个实体都参与</code>  到 <code>联系集</code>  $R$ 的 <code>至少一个联系</code> 中。</p>
<p><code>部分参与 (Partial Participation)</code>：<code>实体集</code> $E$ 中 <code>只有部分实体参与</code> 到联系集<code>$R$ 的</code>至少一个联系` 中。</p>
<h4>Key</h4>
<h5>Identify entity</h5>
<p><code>码/关键字 (Key)</code> 用于在 <code>实体集</code> 中 <code>唯一地标识</code>  某个 <code>实体</code>。</p>
<blockquote><p>可以用 <code>关系模式</code> 中的 <code>超码</code>，<code>主码</code>，<code>候选码</code> 等概念应用于 <code>实体集</code></p>
</blockquote>
<p>我们使用 <code>主码</code> 来区别 <code>实体</code></p>
<h5>Identify Relationship</h5>
<p>同理，我们也用 <code>主码</code> 来在 <code>联系集</code> 中 <code>区分</code> <code>联系</code>。</p>
<p>设 <code>主码</code> $E_i$ 表示 <code>构成实体集</code> $E_i$ <code>的主码的属性集合</code>。</p>
<p><code>联系集的主码</code> 构成依赖于 <code>与之相同的联系集</code> $R$ <code>所相关联的属性结合</code>：</p>
<ul>
<li>若 <code>联系集</code> $R$ 没有 <code>属性</code> 与之相 <code>关联</code>$\implies primary-key(E_1) \cup primary-key(E_2) \cup\cdots \cup primary-key(E_n)$</li>
<li>若 <code>联系集</code> $R$ 有 <code>属性</code> $a_1, a_2,\cdots,a_m$ 与之相 <code>关联</code> $\implies primary-key(E_1) \cup primary-key(E_2) \cup \cdots \cup primary-key(E_n) \r{\cup \s{a_1,a_2,\cdots, a_m}}$</li>
</ul>
<blockquote><p>考虑 <code>student</code> 和 <code>instructor</code> 的 <code>二元联系 advisor</code>：</p>
<ul>
<li>从student到instructor是 <code>多对一</code> 的：<code>advisor的主码</code> 选用 <code>student的主码</code> </li>
<li>从student到instructor是 <code>一对多</code> 的：<code>advisor的主码</code> 选用 <code>instructor的主码</code></li>
<li>从student到instructor是 <code>一对一</code> 的：<code>advisor的主码</code> 选用 <code>student的主码</code> 或者 <code>instructor的主码</code> 都可以。</li>
<li>从student到instructor是 <code>多对多</code> 的：<code>advisor的主码</code> 选用 <code>student的主码</code> 和 <code>instructor的主码</code> 的 <code>并集</code> </li>
</ul>
</blockquote>
<h2>E-R Diagram</h2>
<h3>Definition</h3>
<p><code>E-R图</code> 的 <code>主要构件 (Component)</code>：</p>
<ul>
<li><code>分成两部分的矩形</code>：表示 <code>实体集</code></li>
<li><code>菱形</code>：表示 <code>联系集</code></li>
<li><code>未分隔的矩形</code>：表示 <code>联系集的属性</code></li>
<li><code>线段</code>： <code>连接</code> <code>实体集</code> 和 <code>联系集</code></li>
<li><code>虚线</code>： <code>连接</code> <code>联系集的属性</code> 和 <code>联系集</code></li>
<li><code>双线</code>： 表示 <code>实体</code> 在 <code>联系集</code> 中的 <code>参与度</code></li>
<li><code>双菱形</code>： <code>连接</code> <code>弱实体集</code> 的 <code>标志性联系集</code></li>
</ul>
<h4> </h4>
<h3>Weak-Entity Set</h3>
<p><code>弱实体集 (Weak Entity Set)</code>：没有 <code>足够的属性</code> 以形成 <code>主码</code> 的 <code>实体集</code></p>
<p><code>强实体集 (Strong Entity Set)</code>：有 <code>主码</code> 的 <code>实体集</code></p>
<hr/>
<p><code>弱实体集</code> 必须 <code>依赖于</code> <code>标识实体集 (Identifying Entity Set) / 属主实体集 （Owner Entity Set)</code>，而我们将建立这种依赖的 <code>联系</code> 称为 <code>标识性联系 (Identifying Relationship)</code></p>
<p><code>标识性联系</code> 具有如下特点：</p>
<ul>
<li>从 <code>弱实体集</code> 到 <code>标识实体集</code> 是 <code>多对一</code> ，且 <code>弱实体集</code>  在 <code>标识性联系</code> 中是 <code>全部参与的</code></li>
<li>没有 <code>描述性属性</code></li>
</ul>
<hr/>
<p><code>弱实体集的分辨码 (Discriminator) / 部分码</code>：用于 <code>区分</code> <code>依赖于特定强实体集</code>的 <code>弱实体集</code> 。</p>
<blockquote><p><code>弱实体集的主码</code> = <code>强实体集的主码</code> + <code>弱实体集的分辨码</code></p>
<p>如果 <code>弱实体集</code> 仅在 <code>单个地方</code> 被使用到，则可以考虑将 <code>弱实体集</code> 直接 <code>编码</code> 为 <code>属主实体集</code> 的 <code>一个属性</code>。</p>
</blockquote>
<p><code>弱实体集</code> 的 <code>绘图规则</code>：</p>
<ul>
<li><code>弱实体集的分辨符</code> 使用 <code>虚下划线</code> 表示</li>
<li><code>关联</code> <code>弱实体集</code>  和 <code>强实体集</code> 的 <code>联系集</code>  应当用 <code>双菱形</code> 表示</li>
</ul>
