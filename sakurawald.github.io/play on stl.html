<h2>原文：<a href="https://sakurawald.github.io/posts/play-on-stl">play on stl</a></h2>
<hr/>
<p>title: play on stl
date: 2022-04-18 22:44:00
tags:</p>
<ul>
<li>stl</li>
<li>cpp</li>
</ul>
<hr/>
<h1>Code Snippet</h1>
<pre><code class="language-cpp">/* Template Begin */
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
#include &lt;bitset&gt;
#include &lt;numeric&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;tuple&gt;
#include &lt;complex&gt;
#include &lt;limits.h&gt;
#include &lt;stack&gt;
#include &lt;sstream&gt;
using namespace std;
/* Template End */
</code></pre>
<h3>ctype.h</h3>
<p>| Function | Note |
| ---- | ---- |
| isalpha() |  |
| isdigit() |  |
| islower() |  |
| isupper() |  |
| ispunct() |  |
| isblank() | C标准库只为\t和space返回非0值 |
| tolower() |  |
| toupper() |  |</p>
<h3>limits.h</h3>
<p>| Macro Constant |
| ---- |
| INT_MIN |
| LONG_MIN |
| LLONG_MIN |
| UINT_MIN |
| ULLONG_MIN |</p>
<h3>math.h</h3>
<h4>Trigonometric Functions</h4>
<p>| Function | Note |
| ---- | ---- |
| sin(), cos(), tan(), asin(), acos(), atan() |  |
| atan2() | 返回给定坐标的角度 |
注：这些 <code>三角函数</code> 输入均为 <code>浮点数</code>，默认使用 <code>弧度</code>作为单位。</p>
<h4>Hyperbolic Functions</h4>
<p>| Function |
| ---- |
| sinh(), cosh(), tanh(), asinh(), acosh(), atanh() |</p>
<h4>Exponential and Logarithmic Functions</h4>
<p>| Function | Note |
| ---- | ---- |
| exp() | 返回自然常数的指定指数值 |
| log() | 返回以自然常数为底的对数 |
| log10() | 返回以10为底的对数 |
| log2() | 返回以2为底的对数 |</p>
<h4>Power Functions</h4>
<p>| Function | Note |
| ---- | ---- |
| pow() | 该函数底层通过浮点数进行计算, 存在精度损失问题. 若确实需要使用, 请配合round() |
| sqrt() | 返回平方根 |
| bqrt() | 返回立方根 |
| hypot() | 返回直角三角形的斜边 |</p>
<h4>Rounding and Remainder Functions</h4>
<p>| Function |
| ---- |
| floow() |
| ceil() |</p>
<h4>Other Functions</h4>
<p>| Function | Note |
| ---- | ---- |
| abs() | 用于求整数的绝对值 (用于浮点数时存在精度问题) |
| fabs() | 用于求浮点数的绝对值 |</p>
<h4>Classification Macro/Functions</h4>
<p>| Macro/Function | Note |
| ---- | ---- |
| isinf() | 判断浮点数是否无穷大 |
| isnan() | 判断浮点数是否为实数 |</p>
<h4>Comparison Macro/Functions</h4>
<p>| Function |
| ---- |
| isgreater() |
| isgreaterequal() |</p>
<h3>stdio.h</h3>
<h4>Formatted Input/Output</h4>
<p>| Function | Note |
| ---- | ---- |
| scanf() | 格式化输入 |
| printf() | 格式化输出 |
| sscanf() | 格式化输入到字符串 |
| sprintf() | 格式化输出到字符串 |
| getchar() | 该方法不会跳过空白字符(回车, 换行, 空格) |
| gets() | 输入1行 (以<code>\n</code>作为分隔符) 字符串 |
| puts() | 输出1行字符串 (该方法会在末尾自动添加<code>\n</code>) |</p>
<h4>Macros</h4>
<p>| Macro | Note |
| ---- | ---- |
| EOF | 值为-1的整数, 作为 <code>文件流的末尾标识字符</code> .&lt;br&gt;注: EOF并不属于 <code>文件内容</code> 的一部分, 它只是一个 流状态标识符 |
| NULL | 整数值为0的字符, 作为 字符串的末尾标识字符.&lt;br&gt;注: NULL字符 确实属于 C语言风格字符串 的内容的一部分 |
| size_t | 无符号类型整数&lt;br&gt;注: 当其作为循环变量并与int类型的增量相运算时, 将存在类型转化不兼容 |</p>
<h3>stdlib.h</h3>
<h4>String Conversion</h4>
<p>| Function | Note |
| ---- | ---- |
| atoi(), atof(), atol(), atoll() | 转换string到int, double, long, long long |
| strtod(), strtoll(), strtoul(), strtoull() | 转换string(解释为以base为基数)到long, long long, unsigned long, unsigned long long |</p>
<h4>Pseudo-Random Sequence Generation</h4>
<p>| Function | Note |
| ---- | ---- |
| srand() | 初始化随机数种子 |
| rand() | 生成下一个随机数 |</p>
<h4>Dynamic Memory Management</h4>
<p>| Function | Note |
| ---- | ---- |
| malloc() |  |
| calloc() | 该方法会自动进行填0初始化 |
| reallocI() |  |
| free() | 释放动态申请的内存 |</p>
<h4>Searching and Sorting</h4>
<p>| Function | Note |
| ---- | ---- |
| qsort() | 快速排序 |
| bsearch() | 二分查找 |</p>
<h3>string.h</h3>
<h4>Copying</h4>
<p>| Function |
| ---- |
| memcpy() |
| memmove() |
| strcpy() |</p>
<h4>Concatenation</h4>
<p>| Function |
| ---- |
| strcat() |</p>
<h4>Comparison</h4>
<p>| Function |
| ---- |
| memcmp() |
| strcmp() |</p>
<h4>Searching</h4>
<p>| Function |
| ---- |
| memchr() |
| strchr() |
| strrchr() |
| strpbrk() |
| strcspn() |
| strspn() |
| strstr() |
| strtok() |</p>
<h4>Other</h4>
<p>| Function | Note |
| ---- | ---- |
| memset() | 该方法本质是 字符串. 若需要填充整数, 则只有下列整数的可行的: 0, -1 |
| strlen() | 该方法不计入字符串末尾的结束字符 |</p>
<h3>time.h</h3>
<h4>Time Manipulation</h4>
<p>| Function |
| ---- |
| clock() |
| difftime() |
| mktime() |
| time() |</p>
<h4>Conversion</h4>
<p>| Function |
| ---- |
| asctime() |
| ctime() |
| gmtime() |
| localtime() |
| strftime() |</p>
<h2>Containers</h2>
<h3>vector</h3>
<h3>queue</h3>
<h3>deque</h3>
<h3>stack</h3>
<h3>list</h3>
<h3>set</h3>
<h3>map</h3>
<h3>unordered_map</h3>
<h3>unordered_set</h3>
<h2>Other Libraries</h2>
<p>| Library |
| ---- |
| algorithm |
| bitset |
| chrono |
| codecvt |
| complex |
| exception |
| functional |
| initializer_list |
| iterator |
| limits |
| locale |
| memory |
| new |
| numeric |
| random |
| ratio |
| regex |
| stdexcept |
| string |
| system_error |
| tuple |
| typeindex |
| typeinfo |
| type_traits |
| utility |
| valarray |</p>
<h2>Code Snippets</h2>
<h3>Initialize the Array with Fixed-Element</h3>
<ul>
<li><code>定义时</code> 使用 <code>列表初始化</code></li>
</ul>
<pre><code class="language-cpp">  int arr[10] = {1,2,3};
</code></pre>
<pre><code class="language-cpp">1 2 3 0 0 0 0 0 0 0
</code></pre>
<blockquote>
<p><code>列表初始化</code> 会 <code>列表的元素</code>填充到 <code>数组的前几个元素</code>，<code>数组的剩余元素</code>一律 <code>填0</code></p>
</blockquote>
<ul>
<li>使用 <code>memset</code>进行 <code>内存字符填充</code></li>
</ul>
<pre><code class="language-cpp">  int arr[10];
  memset(arr, 0, sizeof(array));
</code></pre>
<pre><code class="language-cpp">0 0 0 0 0 0 0 0 0 0
</code></pre>
<blockquote>
<p>注意：该种方法只能用于填充 <code>0</code>和 <code>-1</code></p>
</blockquote>
<ul>
<li>利用 <code>全局变量</code>自动 <code>初始化填0</code>的特性</li>
</ul>
<pre><code class="language-cpp">int arr[10];
int main() {
  for (int i = 0; i &lt; 10; ++i) {
    printf("%d ", arr[i]);
  }
  return 0;
}
</code></pre>
<pre><code class="language-cpp">0 0 0 0 0 0 0 0 0 0
</code></pre>
<ul>
<li>使用 <code>fill()</code> 填充函数</li>
</ul>
<pre><code class="language-cpp">  int arr[10];
  fill(arr, arr + 10, 2022);
</code></pre>
<pre><code class="language-cpp">2022 2022 2022 2022 2022 2022 2022 2022 2022 2022
</code></pre>
<blockquote>
<p><code>fill_n()</code> 只用 <code>指定值</code> 填充 <code>前n个元素</code></p>
<pre><code class="language-cpp">int arr[10];
fill_n(arr, 3, 2020);
</code></pre>
<pre><code class="language-cpp">2020 2020 2020 0 8 0 75 0 16875376 0
</code></pre>
</blockquote>
<h3>Initialize the Array with Generated-Element</h3>
<ul>
<li>使用 <code>generate()</code> 生成函数</li>
</ul>
<pre><code class="language-cpp">  int arr[10];
  generate(arr, arr + 10, []() { return rand() % 5; });
</code></pre>
<pre><code class="language-cpp">1 2 4 0 4 4 3 3 2 4
</code></pre>
<blockquote>
<p>如果需要让 <code>generate()</code> 保存 <code>状态</code>，则可以利用 <code>静态局部变量</code>来实现。</p>
<blockquote>
<p>用 <code>全局变量</code>也可以，但 <code>静态局部变量</code>使得 <code>代码结构</code>更加 <code>紧凑</code></p>
</blockquote>
<pre><code class="language-cpp">  int arr[10];
  generate(arr, arr + 10, []() {
      static int i = 1;
      return i *= 2;
  });
</code></pre>
<pre><code>2 4 8 16 32 64 128 256 512 1024
</code></pre>
</blockquote>
<h3>Generate Lexicographical-Permutation</h3>
<ul>
<li>使用 <code>next_permutation()</code></li>
</ul>
<pre><code class="language-cpp">  string words = "abc";
  do {
    cout &lt;&lt; words &lt;&lt; endl;
  } while (next_permutation(words.begin(), words.end()));
</code></pre>
<pre><code class="language-cpp">abc
acb
bac
bca
cab
cba
</code></pre>
<blockquote>
<p>同理，<code>prev_permutation()</code>则是 <code>生成上一个排列</code></p>
</blockquote>
<p>相关辅助函数：<code>is_permutation()</code></p>
<h3>Hash Function</h3>
<ul>
<li>使用 <code>hash结构体模板</code></li>
</ul>
<pre><code class="language-cpp">  hash&lt;string&gt; string_hash;
  string first_words = "abc";
  string second_words = "cba";

  printf("hash(first_words) = %lld", string_hash(first_words));
  printf("\n");
  printf("hash(second_words) = %lld", string_hash(second_words));
</code></pre>
<pre><code class="language-cpp">hash(first_words) = 3663726644998027833
hash(second_words) = -4830583261295167161
</code></pre>
<h3>Find the Index of A Specific Element</h3>
<ul>
<li>使用 <code>find()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90};
  int index = find(arr, arr + 10, 70) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="language-cpp">index = 7
</code></pre>
<ul>
<li>使用 <code>find_if()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90};
  int index = find_if(arr, arr + 10, [](const auto &amp;obj) {
      return obj != 0 &amp;&amp; obj % 15 == 0;
  }) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="language-cpp">index = 3
</code></pre>
<h3>Find the Index of A Subsequence</h3>
<ul>
<li>使用 <code>find_first()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 30, 40, 50, 10, 20, 30, 40, 50, 60, 70, 80, 90};
  int needle[] = {30, 40, 50};
  int index = find_first_of(arr, arr + 13, needle, needle + 3) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="language-cpp">index = 1
</code></pre>
<blockquote>
<p><code>find_first_of()</code> ：返回 <code>第一个相等的子序列</code>的 <code>首元素下标</code></p>
<p><code>find_end()</code>：返回 <code>最后一个相等的子序列</code>的 <code>首元素下标</code></p>
</blockquote>
<ul>
<li>使用 <code>search()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90};
  int needle[] = {30, 40, 50};
  int index = search(arr, arr + 10, needle, needle + 3) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="language-cpp">index = 3
</code></pre>
<blockquote>
<p><code>search</code>返回的是 <code>第一个满足条件的元素</code></p>
</blockquote>
<blockquote>
<p>默认的 <code>search()</code>使用的是 <code>相等谓词</code>，我们也可以自定义 <code>二元相等谓词</code></p>
<pre><code class="language-cpp">int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int needle[] = {9, 16, 25};
int index = search(arr, arr + 10, needle, needle + 3, [](const auto &amp;o1, const auto &amp;o2) {
 return o1  * o1 == o2;
}) - arr;
printf("index = %d", index);
</code></pre>
<pre><code class="language-cpp">index = 3
</code></pre>
</blockquote>
<blockquote>
<p>此外，如果我们的 <code>子序列</code>是 <code>相同元素组成的指定长度的子序列</code>，则可以直接使用 <code>search_n()</code></p>
<pre><code class="language-cpp">int arr[] = {0, 1, 2, 9, 9, 5, 6, 7, 8, 9, 10};
int index = search_n(arr, arr + 10, 2, 9) - arr;
printf("index = %d", index);
</code></pre>
<pre><code class="language-cpp">index = 3
</code></pre>
</blockquote>
<h3>Find in Two-Consecutive Elements</h3>
<ul>
<li>使用 <code>find_adjacent()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 10, 20, 20, 40, 50, 60, 70, 80, 90};
  int index = adjacent_find(arr, arr + 10, [](const auto &amp;o1, const auto &amp;o2){
    return o1 == o2;
  }) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="language-cpp">index = 2
</code></pre>
<h3>Count the number of elements for which predicate is true</h3>
<ul>
<li>使用 <code>count_if()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int cnt = count_if(arr, arr + 10, [](const auto &amp;o1) {
      return o1 % 2 == 0;
  });
  printf("cnt = %d", cnt);
</code></pre>
<pre><code class="language-cpp">cnt = 5
</code></pre>
<h3>Return the First Position where Two Ranges differs</h3>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 30, 4, 5, 6, 7, 8, 9};
  int needle[] = {0, 1, 2};
  pair&lt;int *, int *&gt; ret = mismatch(arr, arr + 10, needle);
  printf("ret-&gt;first = %d", ret.first - arr);
  printf("\n");
  printf("ret-&gt;second = %d", ret.second - needle);
</code></pre>
<pre><code class="language-cpp">ret-&gt;first = 3
ret-&gt;second = 3
</code></pre>
<blockquote>
<p><code>mismatch()</code> 默认使用的 <code>二元相等谓词</code> 就是 <code>operator=</code>。</p>
<p>如果需要，可以自定义 <code>二元相等谓词</code></p>
</blockquote>
<blockquote>
<p><code>equal()</code> 与 <code>mismatch()</code>类似，但它只返回 <code>是否相等</code></p>
</blockquote>
<h3>Test For-All and Exist</h3>
<ul>
<li>使用 <code>all_of()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 2, 4, 6, 8, 10};
  bool flag = all_of(arr, arr + 6, [](const auto&amp;o1){
    return o1 % 2 == 0;
  });
  cout &lt;&lt; flag;
</code></pre>
<pre><code class="language-cpp">1
</code></pre>
<blockquote>
<p><code>any_of()</code>同理，它可以测试是否有 <code>任何一个元素</code>满足 <code>条件</code>。</p>
<p><code>none_of()</code> 可以用 <code>all_of()</code> 取反来实现。</p>
</blockquote>
<h3>Apply function to range</h3>
<ul>
<li>使用 <code>for_each()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  for_each(arr, arr + 10, [](const auto &amp; o1){
    cout &lt;&lt; o1 * o1 &lt;&lt; " ";
  });
</code></pre>
<pre><code class="language-cpp">0 1 4 9 16 25 36 49 64 81
</code></pre>
<h3>Remove Duplicates</h3>
<ul>
<li>使用 <code>sort()</code> 配合 <code>unique()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {10, 10, 20, 30, 40, 50, 10, 60, 70, 80};
  unique(arr, arr + 10);
  for (int i = 0; i &lt; 10; ++i) {
    printf("%d ", arr[i]);
  }
</code></pre>
<pre><code class="language-cpp">10 20 30 40 50 10 60 70 80 80
</code></pre>
<blockquote>
<p>n.b. <code>unique()</code> 的 <code>语义</code>并不是 <code>去除序列的重复元素</code>，而是 <code>去除序列的连续的重复元素 (只保留一个相同元素)</code>。</p>
<p>上述例子中只有 <code>连续的10</code>被去除。</p>
<p>如果确实要去除 <code>序列中所有的重复元素</code>，则应当先 <code>sort()</code>使得 <code>所有的相同元素</code>是 <code>连续排列的</code>，再使用 <code>unique()</code></p>
</blockquote>
<blockquote>
<p>该函数也有 <code>可复制到指定输出流的版本</code> <code>unique_copy()</code></p>
</blockquote>
<h3>Print Range</h3>
<ul>
<li>使用 <code>for_each()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  for_each(arr, arr + 10, [](const auto &amp;item) {
      cout &lt;&lt; item &lt;&lt; " ";
  });
</code></pre>
<ul>
<li>使用 <code>copy()</code></li>
</ul>
<pre><code class="language-cpp">  copy(arr, arr + 10, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<h3>Copy range of elements</h3>
<ul>
<li>使用 <code>copy()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int dest[10];
  copy(arr, arr + 10, dest);
</code></pre>
<blockquote>
<p>可以使用 <code>带谓词的版本</code> <code>copy_if()</code></p>
<p>如果需要 <code>反向遍历</code>，可以使用 <code>copy_backward()</code></p>
</blockquote>
<h3>Move range of elements</h3>
<ul>
<li>使用 <code>move()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  move(arr, arr + 2, arr + 3);
</code></pre>
<pre><code class="language-cpp">0 1 2 0 1 5 6 7 8 9
</code></pre>
<blockquote>
<p><code>move()</code>方法允许 <code>目标内存区域</code>和 <code>来源内存区域</code>发生 <code>重叠</code>。</p>
<p>但是，<code>move()</code>不保证 <code>来源内存区域</code>的 <code>内容</code>仍 <code>保持原样</code></p>
</blockquote>
<h3>Transform Range</h3>
<ul>
<li>使用 <code>transform()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  transform(arr, arr + 10, arr, [](const auto &amp; o1){
    return o1 * o1;
  });
  copy(arr, arr + 10, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 4 9 16 25 36 49 64 81
</code></pre>
<blockquote>
<p><code>transform()</code>可以指定 <code>输出目标流</code>，并且允许 <code>输出目标流</code>和 <code>输入流</code>发生 <code>重叠</code>。</p>
<p>有点类似 <code>for_each()</code>，但 <code>for_each()</code>经常用于 <code>非修改性操作</code>，而 <code>transform()</code> 用于 <code>修改性操作</code></p>
</blockquote>
<h3>Replace Values in Range</h3>
<ul>
<li>使用 <code>replace()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  replace(arr, arr + 10, 3, 3000);
</code></pre>
<pre><code class="language-cpp">0 1 2 3000 4 5 6 7 8 9
</code></pre>
<blockquote>
<p>可以使用 <code>带谓词版本的</code> <code>replace_if()</code>来替代 <code>replace()</code>：只有当 <code>谓词</code> <code>测试通过</code>时，才会用 <code>新值</code> 替换 <code>当前元素</code></p>
</blockquote>
<ul>
<li>使用 <code>replace_copy()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int dest[10];
  replace_copy(arr, arr + 10, dest, 3, 3000);
  copy(arr, arr + 10, ostream_iterator&lt;int&gt;(cout, " "));
  printf("\n");
  copy(dest, dest + 10, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 2 3000 4 5 6 7 8 9
</code></pre>
<blockquote>
<p>相比于 <code>replace()</code>而言，<code>replace_copy()</code>可以指定 <code>修改结果的输出流</code>。</p>
<blockquote>
<p>特别地，<code>replace_copy()</code>可以重新将 <code>输出流</code>指定为 <code>输入流</code></p>
<p>在这个情况下，<code>replace_copy()</code>等价于 <code>replace()</code></p>
</blockquote>
</blockquote>
<blockquote>
<p>此外，还有一个 <code>带谓词版本的</code> <code>repalce_copy_if()</code></p>
<p>我们称它是<code>万能的替换函数</code>，因为它可以取代：<code>repalce()</code>，<code>replace_if()</code>，<code>replace_copy()</code></p>
</blockquote>
<h3>Reverse Range</h3>
<ul>
<li>使用 <code>reverse()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  reverse(arr, arr + 10);
</code></pre>
<pre><code class="language-cpp">9 8 7 6 5 4 3 2 1 0
</code></pre>
<blockquote>
<p><code>可复制到指定输出流的版本</code> <code>reverse_copy()</code></p>
</blockquote>
<h3>Rotate left the elements in range</h3>
<ul>
<li>使用 <code>rotate()</code></li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  rotate(arr, arr + 3, arr + 10);
</code></pre>
<pre><code class="language-cpp">3 4 5 6 7 8 9 0 1 2
</code></pre>
<h3>Rearrange elements in range</h3>
<ul>
<li>使用 <code>random_shuffle()</code> 随机生成函数</li>
</ul>
<pre><code class="language-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  random_shuffle(arr, arr + 10);
</code></pre>
<pre><code class="language-cpp">8 1 9 2 0 5 7 3 4 6
</code></pre>
<blockquote>
<p>该方法可用于 <code>洗牌算法</code></p>
</blockquote>
<h3>Merge (Operating on Sorted Ranges)</h3>
<ul>
<li>使用 <code>set_intersection()</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; A = {1, 2, 3};
  vector&lt;int&gt; B = {3, 4, 5, 6};
  sort(A.begin(), A.end());
  sort(B.begin(), B.end());
  vector&lt;int&gt; result(10);
  auto it = set_intersection(A.begin(), A.end(), B.begin(), B.end(), result.begin());
  copy(result.begin(), it, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">3
</code></pre>
<ul>
<li>集合交 -&gt; <code>set_union()</code></li>
<li>集合差 -&gt; <code>set_difference()</code></li>
<li>集合对称差 -&gt; <code>set_symmetric_difference()</code></li>
<li>归并 -&gt; <code>merge()</code>：<code>归并操作</code></li>
</ul>
<blockquote>
<p>相比于 <code>set_union()</code>而言，<code>merge()</code>会 <code>保留多个相同的元素</code></p>
</blockquote>
<ul>
<li>原址性归并 -&gt; <code>inplace_merge()</code>：<code>原址性的归并操作</code></li>
</ul>
<pre><code class="language-cpp">    vector&lt;int&gt; arr = {1, 1, 2, 3, 4, 2, 3, 4, 5, 6, 7};
    inplace_merge(arr.begin(), arr.begin() + 5, arr.end());
    ```

```cpp
     1 1 2 2 3 3 4 4 5 6 7
    ```

- 测试包含关系 -&gt; `includes()`
- &gt; ```cpp
    &gt; vector&lt;int&gt; A = {0,1,2,3,4,5,6,7,8,9};
    &gt; vector&lt;int&gt; B = {3,4,5,6};
    &gt; cout &lt;&lt; includes(A.begin(), A.end(), B.begin(), B.end());
    &gt; printf("\n");
    &gt; cout &lt;&lt; includes(B.begin(), B.end(), A.begin(), A.end());
    &gt; ```
    &gt; 
    &gt; ```cpp
    &gt; 1
    &gt; 0
    &gt; ```

&gt; n.b. 上述的 `所有的归并操作`在使用之前，都需要用 `sort()` 对 `集合A` 和 `集合B` 进行 `预处理`。
&gt; 
&gt; 否则将导致输出结果的错误。

### Min/Max

- 最小元素/最大元素 -&gt; `min_element()` 和 `max_element()`
	 
     ```cpp
     vector&lt;int&gt; v = {3, 5, 2, 7, 1, 9, 4};
     int index = min_element(v.begin(), v.end()) - v.begin();
     printf("%d ", index);
     ```

     ```cpp
     4
     ```
   
     &gt; `minmax_element()`返回一个 `(最小值迭代器，最大值迭代器)`的 `二元组`

### Heap

`堆操作函数`将一个 `数组`维护 `堆结构`，但除此之外，我们还需要一个 `表示堆大小的整数`。

&gt; n.b. `数组的大小` 不一定等于 `堆的大小`，我们有可能 `只使用数组中的一部分连续区域` 来构成 `堆`
&gt; 
&gt; n.b. 使用 `数组`时需要 `额外维护一个表示堆大小的整数`。但如果使用的是 `vector`，则可以 `在每次堆操作后`手动地 `维护vector`，使得 `vector的大小`始终与 `heap的大小` 相等。

&gt; 与 `Java`的是，`C++`的 `Heap`默认是 `最大堆`，同理，`基于Heap的PriorityQueue`也默认是 `最大优先队列`

- `make_heap()`
    
    ```cpp
      vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
      make_heap(v.begin(), v.end());
      copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    ```
    
    ```cpp
    9 7 8 6 4 5 1 2 0 3
    ```
    
- `pop_heap()`
    
    ```cpp
      vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
      make_heap(v.begin(), v.end());
      copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
      printf("\n");
    
      pop_heap(v.begin(), v.end());
      v.pop_back();
      copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    ```
    
    ```cpp
    9 7 8 6 4 5 1 2 0 3
    8 7 5 6 4 3 1 2 0
    ```
    
- `push_heap()`
    
    ```cpp
      vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
      make_heap(v.begin(), v.end());
      copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
      printf("\n");
    
      v.push_back(10);
      push_heap(v.begin(), v.end());
      copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    ```
    
    ```cpp
    9 7 8 6 4 5 1 2 0 3
    10 9 8 6 7 5 1 2 0 3 4
    ```
    

除此之外，还有一些 `辅助操作`。

- `sort_heap()`
    
    ```cpp
      vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
      make_heap(v.begin(), v.end());
      copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
      printf("\n");
    
      sort_heap(v.begin(), v.end());
      copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    ```
    
    ```cpp
    9 7 8 6 4 5 1 2 0 3
    0 1 2 3 4 5 6 7 8 9
    ```
    
- `is_heap()`
    
    ```cpp
      vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
      make_heap(v.begin(), v.end());
      copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
      printf("\n");
    
      cout &lt;&lt; is_heap(v.begin(), v.end());
    ```
    
    ```cpp
    9 7 8 6 4 5 1 2 0 3
    1
    ```
    

大部分情况下，如果需要使用 `优先队列`可以首先考虑 `priority_queue`。

但如果需要一些更底层的操作，可以使用 `heap functions`

### Binary Search

- 下界函数/上界函数

```cpp
  vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int ret1 = lower_bound(v.begin(), v.end(), 3) - v.begin();
  int ret2 = upper_bound(v.begin(), v.end(), 3) - v.begin();
  printf("lower_bound = %d ", ret1);
  printf("\n");
  printf("upper_bound = %d ", ret2);
</code></pre>
<pre><code class="language-cpp">lower_bound = 3
upper_bound = 4
</code></pre>
<blockquote>
<p>n.b. <code>lower_bound()</code>和 <code>upper_bound()</code>的 <code>语义</code> 可能直观上和 <code>名称</code>不同。</p>
<p>但实际上， <code>lower_bound()</code>指的是 <code>not less than</code></p>
<p>而 <code>upper_bound()</code> 指的是 <code>greater than</code></p>
</blockquote>
<ul>
<li><code>binary_search()</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  bool found = binary_search(v.begin(), v.end(), 3);
  printf("found = %d", found);
</code></pre>
<pre><code class="language-cpp">found = 1
</code></pre>
<blockquote>
<p>如果 <code>已知序列是有序的</code>，则可以用 <code>binary search</code>代替 <code>linear search</code>来获得更高的效率。</p>
<p>但是，如果需要获取 <code>下标</code>，则需要使用 <code>lower_bound()</code>来进行 <code>二分查找</code></p>
<blockquote>
<p>尽管C标准库确实有一个 <code>bsearch()</code>函数，但该函数原型对于C++的很多数据结构来说，并不适合。</p>
</blockquote>
</blockquote>
<ul>
<li><p><code>equal_range()</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0, 1, 2, 3, 3, 5, 6, 7, 8, 9};
  auto ret = equal_range(v.begin(), v.end(), 3);
  printf("first = %d\n", ret.first - v.begin());
  printf("second = %d\n", ret.second - v.begin());
</code></pre>
<pre><code class="language-cpp">first = 3
second = 5
</code></pre>
<blockquote>
<p>需要在 <code>有序序列</code>中查找 <code>一段连续的相同的元素</code>的 <code>下标范围</code>，则可以使用 <code>equal_range()</code></p>
</blockquote>
</li>
</ul>
<h3>Sorting</h3>
<ul>
<li><p><code>sort()</code>：<code>快速排序</code>，<code>非稳定性的</code></p>
</li>
<li><p><code>stable_sort()</code>：<code>稳定性的排序</code></p>
</li>
<li><p><code>partial_sort()</code>：<code>划分排序</code>，可以按照 <code>基准元素</code>将 <code>序列</code> 进行 <code>划分</code>为 <code>两个部分</code></p>
</li>
<li><p><code>is_sorted()</code>：判断 <code>序列</code>是否所有元素满足 <code>偏序关系</code></p>
<blockquote>
<p>通常情况下，我们定义的 <code>偏序关系</code>也就是 <code>operator &lt;</code>。</p>
<p>在这个意义上，<code>is_sorted()</code> 默认是 <code>判断序列是否升序</code>，</p>
<p>如果希望判断 <code>序列是否是降序的</code>，可以利用 <code>反向迭代器</code>来实现。</p>
</blockquote>
<pre><code class="language-cpp">vector&lt;int&gt; increase = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
vector&lt;int&gt; decrease = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
cout &lt;&lt; is_sorted(increase.begin(), increase.end()) &lt;&lt; endl;
cout &lt;&lt; is_sorted(decrease.begin(), decrease.end()) &lt;&lt; endl;
cout &lt;&lt; is_sorted(decrease.rbegin(), decrease.rend());
</code></pre>
<pre><code class="language-cpp">1
0
1
</code></pre>
</li>
<li><p><code>nth_element()</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {4, 7, 6, 8, 9, 2, 1, 3, 5};
  nth_element(v.begin(), v.begin() + 1, v.end());
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">1 2 4 3 5 6 7 9 8
</code></pre>
<blockquote>
<p><code>nth_element()</code>可以使得 <code>序列中指定位置的值</code>为 <code>排序该序列后该位置放置的元素</code>。</p>
<p>但除了让 <code>指定位置为排序后的序列应放置的元素</code>之外， <code>其他位置的元素</code>可能会受到 <code>位置改变的副作用</code></p>
</blockquote>
</li>
</ul>
<h3>Partitions</h3>
<ul>
<li><p><code>partition()</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {5, 3, 7, 4, 2, 9, 0, 8, 1};
  int ret = partition(v.begin(), v.end(), [](const auto&amp;o1){
    return o1 &lt; 4;
  }) - v.begin();
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
  printf("\nthe index of the first element in the second group: %d", ret);

</code></pre>
<pre><code class="language-cpp">1 3 0 2 4 9 7 8 5
the index of the first element in the second group: 4
</code></pre>
<blockquote>
<p><code>partition()</code> 划分函数 将 <code>序列</code>按照 <code>一元谓词</code>划分为 <code>2个部分</code>：</p>
<ul>
<li>第1部分：满足谓词的元素</li>
<li>第2部分：不满足谓词的元素</li>
</ul>
<p>它的返回值是 <code>第2部分的第一个元素的下标</code></p>
<blockquote>
<p>n.b. 我们可以发现，STL中很多关于 <code>2划分</code> 所返回的下标，均遵循 <code>the index of the first element in the second group</code>的原则。</p>
<p>同样地，类似的规律有 <code>取头不取尾的区间表示方法 [begin, end)</code></p>
</blockquote>
<blockquote>
<p>变种版本：<code>partition_copy()</code>，<code>stable_partition()</code></p>
</blockquote>
</blockquote>
</li>
<li><p><code>is_partitioned()</code></p>
</li>
<li><p><code>partition_point()</code></p>
<pre><code class="language-cpp">vector&lt;int&gt; v = {5, 3, 7, 4, 2, 9, 0, 8, 1};
int ret = partition(v.begin(), v.end(), [](const auto &amp;o1) {
   return o1 &lt; 4;
}) - v.begin();
copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
printf("\nthe index of the first element in the second group: %d", ret);
// partition_point()
auto point = partition_point(v.begin(), v.end(), [](const auto &amp;o1) {
   return o1 &lt; 4;
});
printf("\n");
for (auto iter = v.begin(); iter != point; iter++) {
 printf("%d ", *iter);
}
</code></pre>
<pre><code class="language-cpp">1 3 0 2 4 9 7 8 5
the index of the first element in the second group: 4
1 3 0 2
</code></pre>
<p>可用于 <code>反求</code> <code>划分的分割点的迭代器</code></p>
</li>
</ul>
<h3>Bitset</h3>
<p><code>位图 (bitset)</code> 是C++ 容器库之外的一个数据结构，它用 <code>1个二进制位</code>表示 <code>1个逻辑型变量</code>。</p>
<p>相比于 <code>char (8-bit)</code>而言，更 <code>节约空间</code>。</p>
<p>更重要的是，<code>bitset</code>提供了一些方便的 <code>数据操作函数</code>和 <code>数据查询函数</code>，以及对 <code>字符串输出</code>的支持。</p>
<ul>
<li><p>数据操作函数</p>
<ul>
<li><code>置位 (set)</code>：将 <code>指定下标的位</code>设置为 <code>1</code></li>
<li><code>复位 (reset)</code>：将 <code>指定下标的位</code>设置为 <code>0</code></li>
<li><code>翻转 (flip)</code>：将 <code>指定下标的位</code>进行 <code>翻转</code></li>
</ul>
</li>
<li><p>数据查询函数</p>
<ul>
<li><p><code>测试 (test)</code>：返回 <code>指定下标的位</code></p>
</li>
<li><p><code>计数 (count)</code>：返回 <code>被置位的位数</code></p>
<ul>
<li><code>全部已置位 (all)</code>：是否 <code>所有的位</code>都被 <code>置位</code></li>
<li><code>任何已置位 (any)</code>：是否 <code>任何一个位</code>被 <code>置位</code></li>
<li><code>没有已置位 (none)</code>：是否 <code>没有任何一个位</code>被 <code>置位</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">  bitset&lt;32&gt; bits;
  bits.set(0,true);
  cout &lt;&lt; bits;
</code></pre>
<pre><code class="language-cpp">00000000000000000000000000000001
</code></pre>
<blockquote>
<p>在 <code>空间紧张</code>的情况下，<code>bitset&lt;size&gt;</code>可能会优于 <code>vector&lt;bool&gt;</code>。</p>
<blockquote>
<p>事实上，这并不一定。因为 <code>vector&lt;bool&gt;</code>和 <code>普通的泛化vector</code>不同，</p>
<p>它是 <code>vector模板的特例化</code>，具体库实现很有可能针对 <code>vector&lt;bool&gt;</code>做出特别的优化。</p>
</blockquote>
<p>但不同于 <code>vector</code>的 <code>动态伸缩</code>， <code>bitset</code>的大小是通过 <code>模板</code>固定的，在编译期确立和内存空间。</p>
</blockquote>
<h3>Complex</h3>
<p>STL库提供的 <code>复数</code>实现，同时重载了 <code>运算符</code>。</p>
<pre><code class="language-cpp">  complex&lt;int&gt; a = {1,2};
  complex&lt;int&gt; b = {3,4};
  cout &lt;&lt; a + b;
</code></pre>
<pre><code class="language-cpp">(4,6)
</code></pre>
<h3>Ratio</h3>
<p>由C++提供的 <code>比例 (Ratio)</code>库。可以直接作为 <code>分数</code>库使用。</p>
<pre><code class="language-cpp">  typedef ratio&lt;1, 2&gt; one_half;
  typedef ratio&lt;2, 3&gt; two_thirds;
  ratio_add&lt;one_half, two_thirds&gt; sum;
  printf("fraction: %d/%d", sum.num, sum.den);
</code></pre>
<pre><code class="language-cpp">fraction: 7/6
</code></pre>
<blockquote>
<p>他们本质上是 <code>宏</code>，只能在 <code>编译期</code>确定数值。</p>
</blockquote>
<h3>Tuple</h3>
<p>当需要表示 <code>多种数据类型的有序序列</code>，则可以使用 <code>元组 (Tuple)</code>。</p>
<blockquote>
<p>比如如果需要返回 <code>2个返回值</code>时，比起 <code>structure</code>来说，<code>tuple</code>会更加方便</p>
<blockquote>
<p>实际上，有另一个东西叫 <code>make_pair()</code></p>
</blockquote>
</blockquote>
<ul>
<li>Construct Tuple and Get Elements</li>
</ul>
<pre><code class="language-cpp">  tuple&lt;string, int&gt; t1("hello", 100);
  cout &lt;&lt; "get&lt;0&gt; = " &lt;&lt; get&lt;0&gt;(t1) &lt;&lt; endl;
  cout &lt;&lt; "get&lt;1&gt; = " &lt;&lt; get&lt;1&gt;(t1);
</code></pre>
<pre><code class="language-cpp">get&lt;0&gt; = hello
get&lt;1&gt; = 100
</code></pre>
<blockquote>
<p>实际上，比起 <code>构造器</code>而言， 我们更经常使用 <code>make_tuple()</code> 来构造元组。</p>
</blockquote>
<pre><code class="language-cpp">auto t2 = make_tuple("hello", "world", 100);
</code></pre>
<ul>
<li>Use <code>tie()</code> to Unpack Tuple</li>
</ul>
<pre><code class="language-cpp">  auto tuple = make_tuple("hello", "world", 100);

  string str1;
  string str2;
  int num;
  tie(str1, str2, num) = tuple;

  cout &lt;&lt; str1 &lt;&lt; endl;
  cout &lt;&lt; str2 &lt;&lt; endl;
  cout &lt;&lt; num &lt;&lt; endl;
</code></pre>
<pre><code class="language-cpp">hello
world
100
</code></pre>
<blockquote>
<p>如果只需要 <code>unpack</code>其中 <code>某些元素</code>，则可以使用 <code>std::ignore</code>来进行 <code>占位</code></p>
</blockquote>
<pre><code class="language-cpp">auto tuple = make_tuple("hello", "world", 100);

string str1;
int num;
tie(str1, std::ignore, num) = tuple;

cout &lt;&lt; str1 &lt;&lt; endl;
cout &lt;&lt; num &lt;&lt; endl;
</code></pre>
<h3>Utility</h3>
<ul>
<li><code>swap()</code></li>
<li><code>make_pair()</code>
如果只需要 <code>2元组</code>的情况下，用 <code>make_pair()</code>会比 <code>make_tuple()</code>方便非常多。后者的 <code>accessor</code>用起来比较麻烦。</li>
</ul>
<h3>Accumulate values in range</h3>
<ul>
<li>使用 <code>accumulate()</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0,1,2,3,4,5,6,7,8,9};
  int sum = accumulate(v.begin(), v.end(), 0);
  cout &lt;&lt; sum;
</code></pre>
<pre><code class="language-cpp">45
</code></pre>
<blockquote>
<p><code>accumulate()</code> 不仅仅是用于 <code>累加</code>，它还支持 <code>带有二元谓词的版本</code>。</p>
<p>可以利用 <code>二元谓词</code>来实现 <code>累减</code>，<code>累乘</code>，<code>累除</code>等</p>
</blockquote>
<pre><code class="language-cpp">vector&lt;int&gt; v = {1, 2, 3, 4};
int sum = accumulate(v.begin(), v.end(), 1, [](const auto &amp;o1, const auto &amp;o2) {
   return o1 * o2;
});
cout &lt;&lt; sum;
</code></pre>
<pre><code class="language-cpp">24
</code></pre>
<h3>Compute adjacent difference of range</h3>
<ul>
<li>使用 <code>adjacent_difference()</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {1,4,6,10};
  adjacent_difference(v.begin(), v.end(), v.begin());
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">1 3 2 4
</code></pre>
<blockquote>
<p><code>adjacent_difference()</code> 不但可以用于 <code>差分</code>，还可以进行 <code>和分</code>，<code>积分</code>，<code>商分</code></p>
</blockquote>
<pre><code class="language-cpp">vector&lt;int&gt; v = {1, 4, 6, 10};
adjacent_difference(v.begin(), v.end(), v.begin(), [](const auto &amp;o1, const auto &amp;o2) {
return o1 * o2;
});
copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">1 4 24 60
</code></pre>
<h3>Compute cumulative inner product of range</h3>
<ul>
<li>使用 <code>inner_product()</code></li>
</ul>
<pre><code class="language-cpp">  int init = 100;
  vector&lt;int&gt; a = {10, 20, 30};
  vector&lt;int&gt; b = {1, 2, 3};
  int ret = inner_product(a.begin(), a.end(), b.begin(), init);
  cout &lt;&lt; ret;
</code></pre>
<pre><code class="language-cpp">240
</code></pre>
<blockquote>
<p>n.b. 使用 <code>inner_product()</code> 时需要保证 <code>矢量a</code>和 <code>矢量b</code>的 <code>长度相等</code>。</p>
<blockquote>
<p>在 <code>两个矢量的长度不等的情况下</code>，STL仍然会取 <code>较长的矢量</code>进行运算， 而<code>较短的矢量</code>的 <code>越界值</code>将是 <code>不可预测的</code></p>
</blockquote>
</blockquote>
<blockquote>
<p>可以使用 <code>带谓词版本的 inner_product()</code>来模拟 <code>inner_product()</code></p>
</blockquote>
<pre><code class="language-cpp">int init = 100;
vector&lt;int&gt; a = {10, 20, 30};
vector&lt;int&gt; b = {1, 2, 3};
int ret = inner_product(a.begin(), a.end(), b.begin(), init, [](const auto &amp;o1, const auto &amp;o2) {
 return o1 + o2;
}, [](const auto &amp;o1, const auto &amp;o2) {
   return o1 * o2;
});
</code></pre>
<pre><code class="language-cpp">240
</code></pre>
<h3>Compute partial sums of range</h3>
<ul>
<li>使用 <code>partial_sum()</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; a = {1, 2, 3, 4, 5};
  partial_sum(a.begin(), a.end(), a.begin());
  copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">1 3 6 10 15
</code></pre>
<blockquote>
<p>同理，使用带二元谓词的版本，我们可以实现：<code>部分差</code>，<code>部分乘</code>，<code>部分商</code></p>
</blockquote>
<h3>Store increasing sequence</h3>
<ul>
<li>使用 <code>iota()</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; v(10);
  iota(v.begin(), v.end(), 3);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">3 4 5 6 7 8 9 10 11 12
</code></pre>
<blockquote>
<p><code>iota()</code>底层使用 <code>operator++ 运算符</code>来实现 <code>递增</code></p>
</blockquote>
<h3>Function Object</h3>
<h4>Base Classes</h4>
<p><code>函数对象</code>即利用 <code>结构体/对象</code>的 <code>operator()</code>运算符重载，完成类似 <code>普通函数</code>的 <code>函数调用</code>。</p>
<ul>
<li><code>unary_function()</code></li>
</ul>
<pre><code class="language-cpp">struct IsOdd {
    bool operator() (int number) {
      return number % 2 != 0;
    }
};

int main() {
  IsOdd function_object;
  cout &lt;&lt; function_object(3) &lt;&lt; endl;
  cout &lt;&lt; function_object(2);
  return 0;
}
</code></pre>
<pre><code class="language-cpp">1
0
</code></pre>
<blockquote>
<p>本质上来说，<code>函数对象</code>就是一个 <code>结构体</code>。</p>
</blockquote>
<pre><code class="language-cpp">struct IsOdd {
   bool operator() (int number) {
     return number % 2 != 0;
   }
} function_object;
</code></pre>
<ul>
<li><code>binary_function()</code></li>
</ul>
<pre><code class="language-cpp">int main() {
  struct Add {
      int operator() (int o1, int o2) {
        return o1 + o2;
      }
  } function_object;
  cout &lt;&lt; function_object(1, 2) &lt;&lt; endl;
  return 0;
}
</code></pre>
<pre><code class="language-cpp">3
</code></pre>
<blockquote>
<p><code>函数对象</code>一般用于 <code>predicate function</code>和 <code>comparison function</code>。</p>
<p>在大部分的场景下，可以用 <code>lambda表达式</code> 代替 <code>函数对象</code> 作为 <code>callable</code>。</p>
</blockquote>
<h4>Operator Classes</h4>
<h5>Arithmetic Operation</h5>
<ul>
<li><p><code>plus</code></p>
<pre><code class="language-cpp">int main() {
  plus&lt;int&gt; function_object;
  cout &lt;&lt; function_object(1,2);
  return 0;
}
</code></pre>
<pre><code class="language-cpp">3
</code></pre>
</li>
<li><p><code>minus</code></p>
</li>
<li><p><code>multiplies</code></p>
</li>
<li><p><code>divides</code></p>
</li>
<li><p><code>modulus</code></p>
</li>
<li><p><code>negate</code></p>
</li>
</ul>
<blockquote>
<p>上述 <code>算术操作函数对象</code>可以非常方便地用于 <code>transform()</code></p>
</blockquote>
<h5>Comparison Operation</h5>
<ul>
<li><code>equal_to</code></li>
<li><code>not_equal_to</code></li>
<li><code>greater</code></li>
<li><code>less</code></li>
<li><code>greater_equal</code></li>
<li><code>less_equal</code></li>
</ul>
<blockquote>
<p><code>greater</code>和 <code>less</code>经常用于 <code>UDT</code>的 <code>优先队列</code>定义。</p>
</blockquote>
<blockquote>
<p><code>比较器函数</code>的 <code>基本用法</code>可以依据 <code>传入参数</code>来进行 <code>测试</code>。</p>
<p>但我们也可以 <code>绑定某个 参数</code>为 <code>常数</code>。</p>
</blockquote>
<pre><code class="language-cpp">vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int cnt = count_if(v.begin(), v.end(), bind2nd(greater&lt;int&gt;(), 3));
cout &lt;&lt; cnt;
</code></pre>
<pre><code class="language-cpp">6
</code></pre>
<h5>Logical Operations</h5>
<ul>
<li><code>logical_and</code></li>
<li><code>logical_or</code></li>
<li><code>logical_not</code></li>
</ul>
<h5>Adaptor and Conversion Functions</h5>
<h6>Negators</h6>
<ul>
<li><p><code>not1</code></p>
<pre><code class="language-cpp">struct IsOdd {
    bool operator()(const int &amp;x) const { return x % 2 != 0; }
    typedef int argument_type;
};

int main() {
  vector&lt;int&gt; v = {0, 2, 4, 6, 5};
  int cnt = count_if(v.begin(), v.end(), not1(IsOdd()));
  cout &lt;&lt; cnt;
  return 0;
}
</code></pre>
<pre><code class="language-cpp">4
</code></pre>
</li>
<li><p><code>not2</code></p>
</li>
</ul>
<blockquote>
<p><code>not1</code> 和 <code>not2</code> 可以对 <code>现有的谓词</code>进行 <code>取反</code>。</p>
<p>但他们仅支持 <code>函数对象</code>，并不适用于 <code>lambda表达式</code></p>
<blockquote>
<p><code>not1</code> 和 <code>not2</code> 实质上是 <code>基于结构体模板的</code>，而 <code>lambda</code>本质上属于 <code>函数</code>而不是 <code>结构体</code></p>
</blockquote>
</blockquote>
<blockquote>
<p>在用 <code>not1</code>和 <code>not2</code>进行 <code>取反</code>时还必须要求定义 <code>typedef int argument_type</code>，而且对于 <code>运算符函数</code>必须用 <code>const</code>作修饰。</p>
<p>使用并不方便。</p>
</blockquote>
<h6>Parameter Binders</h6>
<ul>
<li><code>bind1st()</code></li>
<li><code>bind2nd()</code></li>
</ul>
<blockquote>
<p><code>bind1st()</code> 和 <code>bind2nd()</code> 适用于 <code>操作类的函数对象</code>。</p>
<p>一般与 <code>Comparison Functions</code>搭配使用。</p>
</blockquote>
<h6>Conversors</h6>
<ul>
<li><code>ptr_fun()</code>：</li>
<li><code>mem_fun()</code>：</li>
</ul>
<pre><code class="language-cpp">     vector &lt;string*&gt; numbers;
     numbers.push_back ( new string ("one") );
     numbers.push_back ( new string ("two") );
     numbers.push_back ( new string ("three") );
     numbers.push_back ( new string ("four") );
     numbers.push_back ( new string ("five") );
   
     vector &lt;int&gt; lengths ( numbers.size() );
     transform (numbers.begin(), numbers.end(), lengths.begin(), mem_fun(&amp;string::length));
   
     for (int i=0; i&lt;5; i++) {
       cout &lt;&lt; *numbers[i] &lt;&lt; " has " &lt;&lt; lengths[i] &lt;&lt; " letters.\n";
     }
   ```
	
```cpp
one has 3 letters.
two has 3 letters.
three has 5 letters.
four has 4 letters.
five has 4 letters.
</code></pre>
<ul>
<li><code>mem_fun_ref()</code>：</li>
</ul>
<pre><code class="language-cpp">    vector&lt;string&gt; numbers;
    numbers.push_back("one");
    numbers.push_back("two");
    numbers.push_back("three");
    numbers.push_back("four");
    numbers.push_back("five");
  
    vector&lt;int&gt; lengths(numbers.size());
    transform(numbers.begin(), numbers.end(), lengths.begin(), mem_fun_ref(&amp;string::length));
  
    for (int i = 0; i &lt; 5; i++) {
      cout &lt;&lt; numbers[i] &lt;&lt; " has " &lt;&lt; lengths[i] &lt;&lt; " letters.\n";
    }
   ```
   
 ```cpp
 one has 3 letters.
 two has 3 letters.
 three has 5 letters.
 four has 4 letters.
 five has 4 letters.
</code></pre>
<blockquote>
<p><code>mem_fun()</code> 和 <code>mem_fun_ref()</code> 可以在 <code>流操作</code>时将 <code>成员函数</code> 转化为 <code>函数对象</code>，可以用于 <code>调用对象的getter函数</code>。
<code>mem_fun()</code>：适用于 <code>指针版本</code>，如 <code>容器的元素</code> 是 <code>指针类型</code>
<code>mem_fun_ref()</code>：适用于 <code>引用版本</code>，如 <code>容器的元素</code> 是 <code>引用类型</code></p>
</blockquote>
<h4>Instrumental Types</h4>
<ul>
<li><p><code>unary_negate()</code> 和 <code>binary_negate()</code>：和 <code>not1()</code> 和 <code>not2()</code> 一样 <code>鸡肋</code></p>
</li>
<li><p><code>binder1st()</code>和 <code>binder2nd()</code>：有点像 <code>编译版的bind1st()</code>和 <code>编译版的bind2nd()</code></p>
<pre><code class="language-cpp">  binder1st&lt;greater&lt;int&gt;&gt; greater_than_10(greater&lt;int&gt;(), 10);
</code></pre>
</li>
<li><p><code>pointer_to_unary_function()</code> 和 <code>pointer_to_binary_function()</code></p>
</li>
<li><p><code>mem_fun_t()</code> ， <code>mem_fun1_t()</code>，<code>const_mem_fun_t()</code>，<code>const_mem_fun1_t()</code>，<code>mem_fun_ref_t()</code>，<code>mem_fun1_ref_t()</code>，<code>const_mem_fun_ref_t()</code>，<code>const_mem_fun1_ref_t()</code></p>
</li>
</ul>
<h3>Initializer List</h3>
<p><code>initializer_list</code> 是一种 <code>数据类型</code>，存储 <code>某种类型的元素</code>的 <code>列表</code>。</p>
<pre><code class="language-cpp">  auto a = {10,20,30};
  copy(a.begin(),a.end(),ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">10 20 30
</code></pre>
<h3>Vector</h3>
<p>数据结构 <code>矢量</code>，提供和 <code>数组</code>等效的功能。</p>
<h4>Constructor &amp; Destructor</h4>
<h5>Constructor</h5>
<ul>
<li><code>empty container constructor</code></li>
<li><code>initializer list constructor</code></li>
<li><code>fill constructor</code>: k elements with specific value</li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; v(10, 3);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">3 3 3 3 3 3 3 3 3 3
</code></pre>
<ul>
<li><code>range constructor</code> copy from <code>ierator</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; src = {0,1,2,3};
  vector&lt;int&gt; v(src.begin() + 1, src.end());
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">1 2 3
</code></pre>
<ul>
<li><code>copy constructor (and copying with allocator)</code>: copy from <code>another vector</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; src = {0,1,2,3};
  vector&lt;int&gt; v(src);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 2 3
</code></pre>
<blockquote>
<p>以下两种写法都是调用 <code>拷贝构造函数</code>。</p>
<blockquote>
<p><code>operator=</code> 赋值运算符 等价于 <code>copy constructor</code></p>
</blockquote>
</blockquote>
<pre><code class="language-cpp">vector&lt;int&gt; a;
vector&lt;int&gt; b(a);
vector&lt;int&gt; b = a;
</code></pre>
<ul>
<li><code>move constructor (and moving with allocator)</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; a = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  vector&lt;int&gt; b(a, a.get_allocator());

  cout &lt;&lt; "a: ";
  copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, " "));
  cout &lt;&lt; endl;
  cout &lt;&lt; "b: ";
  copy(b.begin(), b.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">a: 0 1 2 3 4 5 6 7 8 9
b: 0 1 2 3 4 5 6 7 8 9
</code></pre>
<h5>Destructor</h5>
<p><code>vector</code>会 <code>自动地</code> 释放 <code>元素所使用的内存</code></p>
<h4>Iterators</h4>
<ul>
<li><code>begin()</code> and <code>end()</code></li>
<li><code>rbegin()</code> and <code>rend()</code></li>
<li><code>cbegin()</code> and <code>cend()</code></li>
<li><code>crbegin()</code> and <code>crend()</code></li>
</ul>
<h4>Capacity</h4>
<ul>
<li><p><code>size()</code></p>
<blockquote>
<p><code>size</code>信息是作为 <code>vector的属性</code>而存在的。
可在 <code>常数时间</code>内获取到。</p>
<blockquote>
<p>但 <code>strlen()</code>不是，对于 <code>大字符串</code>，不要频繁地调用 <code>strlen()</code></p>
</blockquote>
</blockquote>
</li>
<li><p><code>resize()</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0,1,2};
  v.resize(5);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 2 0 0
</code></pre>
</li>
<li><p><code>empty()</code></p>
</li>
<li><p><code>capacity()</code>：获取 <code>vector的底层数组</code>的 <code>大小</code></p>
</li>
<li><p><code>reserve()</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0,1,2};
  printf("before reserve: capacity = %d\n", v.capacity());
  v.reserve(10);
  printf("after reserve: capacity = %d\n", v.capacity());
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">before reserve: 3
after reserve: 10
0 1 2
</code></pre>
<blockquote>
<p>如果 <code>事先知道</code>需要添加的 <code>元素的数量</code>，则可以先用 <code>reserve()</code>来 <code>一次性</code>完成 <code>预分配</code>。</p>
<blockquote>
<p><code>reserve(int n)</code> 只 <code>保证</code> <code>vector的底层数组</code>的 <code>大小</code>足够满足 <code>n元素</code>，如果 <code>vector的底层数组</code>已经大于n，则该语句会被简单地忽略。</p>
</blockquote>
<p>如果没有使用 <code>reserve()</code>，则在插入 <code>大量元素</code>时，<code>vector的底层数组</code>可能会经历 <code>多次的动态扩容</code>，浪费不必要的资源。</p>
</blockquote>
</li>
<li><p><code>shrink_to_fit()</code>：<code>动态缩容</code>使得 <code>capacity = size</code></p>
</li>
</ul>
<h4>Element Access</h4>
<ul>
<li><p>Return <code>reference</code></p>
<ul>
<li><code>operator []</code>，<code>at()</code></li>
<li><code>front()</code> ，<code>back()</code></li>
</ul>
<blockquote>
<p>尽管这些 <code>access function</code>返回的确实是 <code>引用</code>，</p>
<p>但还需要注意 <code>隐含的值拷贝</code>。</p>
<p>如果真的希望 <code>取到vector的元素的引用</code>，并且让 <code>数据修改</code>反映到 <code>vector内部的元素</code>中，需要设置 <code>refenence LHS</code>以避免 <code>值拷贝</code></p>
<ul>
<li><code>value copy</code></li>
</ul>
</blockquote>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0,1,2};
  int num = v[0];
  num = 43;
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 2
</code></pre>
<ul>
<li><code>reference copy</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0,1,2};
  int &amp; num = v[0];
  num = 43;
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">43 1 2
</code></pre>
</li>
<li><p>Return <code>reference</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0, 1, 2};
  int *num = v.data();
  copy(num, num + 3, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 2
</code></pre>
<blockquote>
<p><code>data()</code>返回的是 <code>vector的底层数组</code></p>
</blockquote>
</li>
</ul>
<h4>Modifiers</h4>
<ul>
<li><code>assign</code>：assign n elements with specific values</li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; v(10);
  v.assign(3, 5);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">5 5 5
</code></pre>
<blockquote>
<p>n.b. <code>assign</code> 相当于 <code>重新初始化</code>vector，<code>vector中旧的数据</code>会被 <code>删除</code>！</p>
</blockquote>
<ul>
<li><p><code>push_back()</code> and <code>pop_back()</code></p>
</li>
<li><p><code>insert()</code> and <code>erase()</code></p>
<ul>
<li><code>insert()</code></li>
</ul>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  v.insert(v.begin() + 1, 3, 9999);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 9999 9999 9999 1 2 3 4 5 6 7 8 9
</code></pre>
<blockquote>
<p>n.b. <code>insert</code>的 <code>position</code>的 <code>语义</code>是：<code>欲插入元素</code> 将插入在 <code>该position的元素之前</code>。</p>
<p>或者等价地说：<code>欲插入元素</code>在 <code>插入后</code> 应该 <code>位于position的位置</code></p>
</blockquote>
<ul>
<li><p><code>erase()</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  v.erase(v.begin() + 1);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 2 3 4 5 6 7 8 9
</code></pre>
</li>
</ul>
</li>
<li><p><code>clear()</code></p>
</li>
<li><p><code>swap()</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; a(3, 100);
  vector&lt;int&gt; b(5, 200);

  a.swap(b);
  int &amp; the_value_from_a = a[0];
  the_value_from_a = 9999;

  copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, " "));
  cout &lt;&lt; endl;
  copy(b.begin(), b.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">9999 200 200 200 200
100 100 100
</code></pre>
<blockquote>
<p><code>swap()</code>原理是直接 <code>交换</code> 两个 <code>vector的底层数组的指针</code></p>
</blockquote>
</li>
<li><p><code>emplace()</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  v.emplace(v.begin() + 1, 9999);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 9999 1 2 3 4 5 6 7 8 9
</code></pre>
<blockquote>
<p>相比于 <code>insert()</code>，<code>push_front()</code> 和 <code>push_back()</code> 将 <code>构造好的元素</code> 传递给 <code>Modifier</code>。</p>
<p><code>emplace()</code>并不传递 <code>已经构造好的元素</code>，而是传递 <code>用于构造这个元素的参数列表</code>：这样做有利于 <code>减少不必要的元素值拷贝</code>，而 <code>直接在vector的底层数组</code>上 <code>构造元素</code>。</p>
</blockquote>
<blockquote>
<p><code>emplace_back()</code> 同理。</p>
</blockquote>
<pre><code class="language-cpp">vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
v.emplace_back(9999);
copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 2 3 4 5 6 7 8 9 9999
</code></pre>
</li>
</ul>
<h4><code>vector&lt;bool&gt;</code></h4>
<ul>
<li><code>vector&lt;bool&gt;</code> 是 <code>vector</code>的 <code>模板特例化</code>，它和 <code>generic vector template</code>相比，有以下特点：</li>
<li><code>vector&lt;bool&gt;</code>的 <code>底层存储</code>并不一定是用 <code>bool[]</code>的。<code>library</code>可能选择 <code>其他底层存储方式</code>，并且尽可能地保证 <code>仅使用1位来表示真值</code></li>
<li>不同于 <code>常规的vector</code>使用 <code>allocator</code> <code>分配对象</code>， <code>vector&lt;bool&gt;</code>的 <code>位数据</code>可以被 <code>直接地设置</code>在 <code>内部存储</code></li>
<li>多出一个 <code>flip()</code> 翻转函数</li>
<li><code>vector&lt;bool&gt;</code> 的 <code>accesstor</code>返回的是 用于指向单个为的 <code>reference类型</code> 而不是 <code>bool类型</code></li>
</ul>
<blockquote>
<p>也就是说，使用 <code>vector&lt;bool&gt;</code> 并不会比 <code>bitset&lt;&gt;</code> 占用 <code>更多空间</code>或 <code>更多时间</code>。
在正常情况下，无法创建 <code>真正的泛化的 vector&lt;bool&gt;</code>，而取而代之的是 <code>特例化的 vector&lt;bool&gt;</code></p>
</blockquote>
<h3>list</h3>
<p>STL中的 <code>list</code> 是 <code>doubly_linked_list</code></p>
<p>如果需要 <code>singly_linked_list</code> 则需要使用 <code>forward_list</code>。</p>
<blockquote>
<p>n.b. <code>forward_list</code>的 <code>性能</code> 几乎和 <code>Handwritten C-style singly-linked-list</code>没有差别！</p>
<blockquote>
<p><code>forward_list</code>为了 <code>性能</code>甚至没有 <code>size()</code>。</p>
</blockquote>
</blockquote>
<h4>Operations</h4>
<ul>
<li><p><code>splice()</code></p>
<pre><code class="language-cpp">  list&lt;int&gt; list1 = {0, 1, 2};
  list&lt;int&gt; list2 = {100, 200, 300};
  list1.splice(list1.begin(), list2);

  cout &lt;&lt; "list1: ";
  copy(list1.begin(), list1.end(), ostream_iterator&lt;int&gt;(cout, " "));
  cout &lt;&lt; endl &lt;&lt; "list2: ";
  copy(list2.begin(), list2.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">list1: 100 200 300 0 1 2
list2:
</code></pre>
<blockquote>
<p><code>splice()</code> 可以 <code>非常方便</code>地对 <code>2个链表</code>进行 <code>衔接操作</code>。</p>
</blockquote>
</li>
<li><p><code>remove()</code></p>
<pre><code class="language-cpp">  list&lt;int&gt; list1 = {0, 1, 2, 3, 4, 2, 2, 2};
  list1.remove(2);
  copy(list1.begin(), list1.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 3 4
</code></pre>
<blockquote>
<p>n.b. <code>remove()</code>的 <code>语义</code>是 <code>移除所有的符合条件的相等元素</code>，而不是 <code>移除第一个符合条件的相等元素</code></p>
<blockquote>
<p>带谓词的版本 <code>remove_if()</code></p>
</blockquote>
</blockquote>
</li>
<li><p><code>unique()</code> and <code>merge()</code></p>
<blockquote>
<p>n.b. <code>unique()</code>的 <code>语义</code> 和之前所提到的 <code>std::unique()</code>是相同的，都是指 <code>remove consecutive equivalent elements</code>，如果需要确保 <code>移除整个容器中的相等元素</code>，需要进行预处理 <code>sort()</code></p>
</blockquote>
</li>
</ul>
<h3>Array</h3>
<p>STL的<code>array</code>数据结构仅仅是 <code>ordinary array</code> 的 <code>包装类</code>。</p>
<pre><code class="language-cpp">  array&lt;int, 10&gt; num = {0,1,2,3};
  copy(num.begin(), num.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">0 1 2 3 0 0 0 0 0 0
</code></pre>
<blockquote>
<p><code>array</code>提供了比 <code>ordinal array</code>更加方便的 <code>辅助函数</code>，但又没有 <code>vector</code>的 <code>复杂性</code>。</p>
<p>如果你期望保持 <code>ordinal array</code>的众多 <code>特性</code>，同时不期望使用 <code>auto extendend/extracted</code></p>
</blockquote>
<pre><code class="language-cpp">array&lt;int, 10&gt; num = {0, 1, 2, 3};
num.fill(100);
printf("size = %d\n", num.size());
copy(num.begin(), num.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="language-cpp">size = 10
100 100 100 100 100 100 100 100 100 100
</code></pre>
<ul>
<li><code>size()</code></li>
</ul>
<p>传统的<code>C-Style数组</code>在 <code>参数传递</code>时比较麻烦，但使用 <code>array</code>可以避免这个问题。</p>
<ul>
<li><code>iterator</code></li>
</ul>
<p><code>array</code>可以使用 <code>iterator对象</code>，与其他STL函数的配合编码更加方便。</p>
<blockquote>
<p>另外，<code>array</code>继承了 <code>ordinary</code>的 <code>传统特性</code>：允许 <code>下标越界</code>。</p>
</blockquote>
<pre><code class="language-cpp">array&lt;int, 10&gt; arr;

for (int i = -10; i &lt; 20; ++i) {
 cout &lt;&lt; arr[i] &lt;&lt; " ";
}
</code></pre>
<pre><code class="language-cpp">4199804 0 6422000 0 -6 -1 0 0 0 0 8 0 4199705 0 8 0 75 0 8224624 0 16 11 8224592 0 4199367 0 0 0 75 0
</code></pre>
<ul>
<li><code>fill()</code></li>
</ul>
<p><code>array</code>在 <code>完全兼容</code> <code>ordinal array</code>的所有 <code>初始化方法</code>之外，</p>
<p>还提供了一个非常有用的函数：<code>fill()</code></p>
<blockquote>
<p>对于 <code>ordinal array</code>，我们可以使用 <code>memset()</code>。</p>
<p>但遗憾的是，该函数只适用于填充 <code>0</code>和 <code>-1</code></p>
</blockquote>
<pre><code class="language-cpp">  array&lt;array&lt;int, 10&gt;, 3&gt; num;
  num.fill(array&lt;int, 10&gt;{100,200,300});
  for (int i = 0; i &lt; num.size(); ++i) {
    for (int j = 0; j &lt; num[i].size(); ++j) {
      cout &lt;&lt; num[i][j] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
  }
</code></pre>
<pre><code class="language-cpp[">100 200 300 0 0 0 0 0 0 0
100 200 300 0 0 0 0 0 0 0
100 200 300 0 0 0 0 0 0 0
</code></pre>
<h3>deque</h3>
<p>STL的 <code>deque</code> 即 <code>doubly linked list</code>。</p>
<p>此外，STL的 <code>stack</code>和 <code>queue</code> 均是基于 <code>deque</code>实现的</p>
<h3>priority_queue</h3>
<p>不同于Java的 <code>PriorityQueue</code>，C++的STL的 <code>priority_queue</code>默认是 <code>大顶堆</code>。</p>
<pre><code class="language-cpp">template &lt;class T, class Container = vector&lt;T&gt;,
  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;
</code></pre>
<blockquote>
<p><code>priority_queue</code> 底层使用的是 <code>heap functions</code>。</p>
<p><code>data source</code>可以来自 <code>多种类型的容器</code>，只需要通过 <code>range constructor</code>来构造 <code>priority_queue</code>即可。</p>
</blockquote>
<ul>
<li><p><code>max-imum heap</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; a = {1, 5, 2, 8, 3, 6, 4};
  priority_queue&lt;int&gt; PQ(a.begin(), a.end());

  while (!PQ.empty()) {
    cout &lt;&lt; PQ.top() &lt;&lt; " ";
    PQ.pop();
  }
</code></pre>
<pre><code class="language-cpp">8 6 5 4 3 2 1
</code></pre>
</li>
<li><p><code>min-imum heap</code></p>
<pre><code class="language-cpp">  vector&lt;int&gt; a = {1, 5, 2, 8, 3, 6, 4};
  priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; PQ(a.begin(), a.end());

  while (!PQ.empty()) {
    cout &lt;&lt; PQ.top() &lt;&lt; " ";
    PQ.pop();
  }
</code></pre>
<pre><code class="language-cpp">1 2 3 4 5 6 8
</code></pre>
<blockquote>
<p>同理，也可以使用 <code>custom comparison function</code></p>
</blockquote>
<pre><code class="language-cpp">vector&lt;int&gt; a = {1, 5, 2, 8, 3, 6, 4};
struct comp {
   bool operator()(const int &amp;o1, const int &amp;o2) {
     return o1 &gt; o2;
   }
};
priority_queue&lt;int, vector&lt;int&gt;, comp&gt; PQ(a.begin(), a.end());

while (!PQ.empty()) {
 cout &lt;&lt; PQ.top() &lt;&lt; " ";
 PQ.pop();
}
</code></pre>
<pre><code class="language-cpp">1 2 3 4 5 6 8
</code></pre>
</li>
</ul>
<h3>Map</h3>
<p><code>map</code>中的 <code>条目 (entry)</code>类型为</p>
<pre><code class="language-cpp">typedef pair&lt;const Key, T&gt; value_type;
</code></pre>
<h4>map</h4>
<p>STL中的 <code>map</code>底层数据结构是基于 <code>Red-Black Tree</code> 的，通过 <code>operator &lt;</code>来完成 <code>比较</code>。</p>
<p>而且，可以直接对 <code>map</code>进行 <code>迭代</code>来得出 <code>已排序的key序列</code></p>
<ul>
<li><p><code>operator[]</code></p>
<ul>
<li>如果key已存在，则返回 map[key]</li>
<li>如果key不存在，则等价于：(*((this-&gt;insert(make_pair(k,mapped_type()))).first)).second</li>
</ul>
<blockquote>
<p>如果使用 <code>at()</code>，则会在 <code>key不存在时</code>，抛出 <code>异常</code></p>
</blockquote>
<pre><code class="language-cpp">map&lt;int, string&gt; m;
m[1] = "first";
m[2] = "second";
m[3] = "third";
m[4] = "four";
printf("size = %d\n", m.size());
m[5];
printf("size = %d, value = %s\n", m.size(), m[5].c_str());
m[100000000];
printf("size = %d, value = %s\n", m.size(), m[100000000].c_str());
</code></pre>
<pre><code class="language-cpp">size = 4
size = 5, value =
size = 6, value =
</code></pre>
<p>n.b. 无论何时，对 <code>map</code>使用 <code>operator[]</code> 至多只会使得 <code>size</code> <code>增1</code></p>
<p>n.b. 当 <code>访问map中不存在的key时</code>，会自动 <code>创建并插入pair (按默认值创建value)</code></p>
<p>如果 <code>value的类型</code>是 <code>UDT</code>，则需要提供 <code>no parameter constructor</code>，否则无法通过编译。
如下面的例子，将 <code>编译失败</code>：</p>
<pre><code class="language-cpp">class Person {
public:
 string name;

public:
 Person(const string &amp;name) : name(name) {}
};


int main() {

map&lt;int, Person&gt; m;
m[0];
printf("size = %d, value = %s\n", m.size(), m[0].name.c_str());

return 0;
}
</code></pre>
<pre><code class="language-cpp">main.cpp:42:7: note: candidate: 'Person::Person(Person&amp;&amp;)'
main.cpp:42:7: note:   candidate expects 1 argument, 0 provided
</code></pre>
</li>
<li><p>iterator</p>
</li>
</ul>
<pre><code class="language-cpp">  map&lt;int, string&gt; m;
  m[2] = "second";
  m[1] = "first";
  m[3] = "third";
  m[4] = "four";

  for (auto iter = m.begin(); iter != m.end(); iter++) {
    cout &lt;&lt; iter-&gt;first &lt;&lt; ", " &lt;&lt; iter-&gt;second &lt;&lt; endl;
  }
  return 0;
</code></pre>
<pre><code class="language-cpp">1, first
2, second
3, third
4, four
</code></pre>
<blockquote>
<p>由于 <code>map</code>底层使用的是 <code>red black tree</code>，所以可以利用 <code>map</code>来进行 <code>排序</code></p>
</blockquote>
<ul>
<li><code>insert()</code>：通常来说可以使用 <code>operator[]</code> 代替</li>
<li><code>erase()</code></li>
</ul>
<pre><code class="language-cpp">  map&lt;int, string&gt; m;
  m[2] = "second";
  m[1] = "first";
  m[3] = "third";
  m[4] = "four";

  m.erase(2);
  m.erase(5);

  for (auto iter = m.begin(); iter != m.end(); iter++) {
    cout &lt;&lt; iter-&gt;first &lt;&lt; ", " &lt;&lt; iter-&gt;second &lt;&lt; endl;
  }
</code></pre>
<pre><code class="language-cpp">1, first
3, third
4, four
</code></pre>
<blockquote>
<p>n.b. 如果 <code>欲删除的key</code>不存在，则 <code>无事发生</code></p>
</blockquote>
<ul>
<li><code>find()</code>：get <code>iterator</code> to element</li>
</ul>
<pre><code class="language-cpp">  map&lt;int, string&gt; m;
  m[2] = "second";
  m[1] = "first";
  m[3] = "third";
  m[4] = "four";

  auto iter = m.find(5);
  printf(iter == m.end() ? "not found" : "found");
  printf("\nsize = %d", m.size());
</code></pre>
<pre><code class="language-cpp">not found
size = 4
</code></pre>
<blockquote>
<p>相比于 <code>operator[]</code>在 <code>未找到元素时</code>会 <code>自动插入默认对</code>而言，使用 <code>find()</code>来 <code>判断元素是否存在</code>可以避免 <code>浪费空间</code>。</p>
<p>而且更重要的，<code>find()</code>是 <code>幂等的</code></p>
</blockquote>
<ul>
<li><p><code>count()</code>：count elements with a specific key</p>
<blockquote>
<p>n.b. 如果仅仅是为了判断 <code>是否存在某个key</code>，那么相比于 <code>find()</code>写法的麻烦，我们可以用 <code>count() == 0</code>来代替 <code>find()</code></p>
</blockquote>
</li>
</ul>
<h4>miltimap</h4>
<p>与 <code>map</code> 的区别在于， <code>miltimap</code>支持 <code>不同pair有重复的key</code>。</p>
<ul>
<li><p><code>erase()</code></p>
<blockquote>
<p>对于 <code>传值的erase()</code>，将 <code>删除所有符合条件的元素</code>。</p>
</blockquote>
</li>
</ul>
<h3>Set</h3>
<h4>set</h4>
<p>STL的 <code>set</code> 是基于 <code>red-black tree</code>的，此外，它的 <code>元素</code>必须是 <code>const</code>的，只能 <code>插入元素</code>或 <code>删除元素</code>，而不能 <code>修改元素</code>。</p>
<pre><code class="language-cpp">  set&lt;int&gt; S;
  S.insert(1);
  S.insert(2);
  S.insert(2);
  S.insert(3);
  S.insert(4);

  printf("size = %d\n", S.size());
  printf("count(2) = %d\n", S.count(2));
</code></pre>
<pre><code class="language-cpp">size = 4
count(2) = 1
</code></pre>
<blockquote>
<p>n.b. 对于 <code>set</code>来说，如果 <code>欲插入的元素</code>已存在，则会忽略后续的插入（而不是 <code>覆盖插入</code>）。</p>
</blockquote>
<h4>multiset</h4>
<h3>unordered_map</h3>
<h4>unordered_map</h4>
<p><code>unordered_map</code> 基于 <code>bucket</code>而非 <code>red-black tree</code>，通过 <code>hash function</code>来 <code>索引</code> 指定的 <code>key</code>。</p>
<blockquote>
<p>因此，<code>unordered_map</code> 中的 <code>key</code> 是 <code>无序的</code></p>
</blockquote>
<blockquote>
<p>因此，通常比 <code>map</code> 更快</p>
</blockquote>
<ul>
<li><code>Bucket Functions</code></li>
</ul>
<p>| Function | Note |
| ---- | ---- |
| bucket_count() | return number of buckets |
| max_bucket_count() | return maximum number of buckets |
| bucket_size() | return bucket size |
| bucket() | locate element's bucket |</p>
<ul>
<li><code>Hash Policy Functions</code></li>
</ul>
<p>| Function | Note |
| ---- | ---- |
| load_factor() | return load factor |
| max_load_factor() | get or set maximum load factor |
| rehash() | set number of buckets |
| reserve() | request a capacity change |</p>
<h4>unordered_multimap</h4>
<h3>unordered_set</h3>
<h4>unordered_set</h4>
<p>与 <code>unordered_map</code>类似，均是基于 <code>bucket</code>的。</p>
<h4>unordered_multiset</h4>
<h3>Compute Remainder and Quotient</h3>
<ul>
<li><code>remainder()</code></li>
</ul>
<h3>Branch</h3>
<ul>
<li><code>setjmp()</code> and <code>longjmp()</code></li>
</ul>
<pre><code class="language-cpp">  jmp_buf  env;
  printf("before set jump\n");
  int val = setjmp(env);
  printf("after set jump\n");

  printf("val = %d\n", val);

  printf("before longjmp()\n");
  if (!val) longjmp(env, 1);
  printf("after longjmp()\n");
</code></pre>
<pre><code class="language-cpp">before set jump
after set jump
val = 0
before longjmp()
after set jump
val = 1
before longjmp()
after longjmp()
</code></pre>
<blockquote>
<p><code>goto</code>只支持 <code>函数内跳转</code>，但 <code>setjmp() and longjmp()</code>可以支持 <code>跨函数跳转</code></p>
</blockquote>
<blockquote>
<p>使用 <code>setjmp()</code>保存 <code>过程调用环境</code>，然后用 <code>longjmp()</code>进行 <code>jump</code>。</p>
</blockquote>
<p>一个跨函数的例子。</p>
<pre><code class="language-cpp">int foo();
int bar();
jmp_buf env;
int val;

int foo() {
  printf("enter foo()\n");

  val = setjmp(env);

  printf("before call bar()\n");
  bar();
  printf("after call bar()\n");

  printf("leave foo()\n");
  return 100;
}

int bar() {
  printf("enter bar()\n");


  printf("before longjmp()\n");
  if (val != 1) longjmp(env, 1);
  printf("before longjmp()\n");

  printf("leave bar()\n");
  return 200;
}


int main() {
  foo();
  return 0;
}
</code></pre>
<pre><code class="language-cpp">enter foo()
before call bar()
enter bar()
before longjmp()
before call bar()
enter bar()
before longjmp()
before longjmp()
leave bar()
after call bar()
leave foo()
</code></pre>
<ul>
<li><code>goto</code></li>
</ul>
<pre><code class="language-cpp">int main() {

  for (int i = 0; i &lt; 100; ++i) {
    for (int j = 0; j &lt; 100; ++j) {

      if (i == 10 &amp;&amp; j == 20) {
        goto ok;
      }
    
    }
  }

  ok: 0xdead;

  printf("bye\n");
  return 0;
}
</code></pre>
<pre><code>bye
</code></pre>
<p>关于 <code>跳出外层循环</code>，更推荐的写法是给 <code>外层循环</code>加 <code>控制标记</code></p>
<pre><code class="language-cpp">int main() {

  bool flag = true;
  for (int i = 0; flag &amp;&amp; i &lt; 100; ++i) {
    for (int j = 0; j &lt; 100; ++j) {

      // break the outer loop
      if (i == 10 &amp;&amp; j == 20) {
        flag = false;
        break;
      }
    
    }
  }

  printf("bye\n");
  return 0;
}
</code></pre>
<h3>The incremental of size_t and size_type</h3>
<pre><code class="language-cpp">  char c_str[] = "china";
  string cpp_str = "china";

  printf("strlen(c_str) = %d\n", strlen(c_str));
  printf("cpp_str.size() = %d\n", cpp_str.size());

  //
  int c_str_size = strlen(c_str) + 1;
  printf("c_str_size = %d\n", c_str_size);

  int cpp_str_size = cpp_str.size() + 1;
  printf("cpp_str_size = %d\n", cpp_str_size);
</code></pre>
<pre><code class="language-cpp">strlen(c_str) = 5
cpp_str.size() = 5
c_str_size = 6
cpp_str_size = 6
</code></pre>
<blockquote>
<p><code>size_t</code>和 <code>size_type</code> 本质上是 <code>unsigned long long</code></p>
<p>在 <code>强制转化</code> 为 <code>int</code> 时属于 <code>narrowing conversion</code>。</p>
<p>对他们执行 <code>递增操作</code>时应使用 <code>递增操作符</code> 而不是直接 <code>+1</code>。</p>
<blockquote>
<p>直接 <code>+1</code>的含义为 <code>将unsigned long long 窄化为int，然后加上int型的1</code>。该操作是 <code>未定义的</code>，取决于具体实现。</p>
</blockquote>
</blockquote>
<pre><code class="language-cpp">Clang-Tidy: Narrowing conversion from 'unsigned long long' to signed type 'int' is implementation-defined
</code></pre>
<h3>Exit the program</h3>
<ul>
<li><p>Terminate</p>
<ul>
<li><code>abort()</code>：abnormal termination, raises the <code>SIGABRT signal</code>, do not cleanup</li>
<li><code>exit()</code>：normal termination, do cleanup</li>
<li><code>quick_exit()</code>：normal termination, do not cleanup</li>
<li><code>_Exit()</code></li>
</ul>
</li>
<li><p>Terminate</p>
<ul>
<li><p><code>atexit()</code></p>
<pre><code class="language-cpp">  auto post = [](){
    printf("bye\n");
  };
  atexit(post);

  printf("before return\n");
</code></pre>
<pre><code class="language-cpp">before return
bye
</code></pre>
</li>
<li><p><code>at_quick_exit()</code></p>
</li>
</ul>
</li>
<li><p>Get system environment</p>
<ul>
<li><p><code>getenv()</code></p>
<pre><code class="language-cpp">  char * java_home = getenv("JAVA_HOME");
  printf("%s", java_home);
</code></pre>
<pre><code class="language-cpp">D:\Program Files (x86)\Java\jdk1.8.0_291
</code></pre>
</li>
</ul>
</li>
<li><p>Execute commands</p>
<ul>
<li><code>system()</code></li>
</ul>
</li>
</ul>
<h3>Time</h3>
<h4>Time Manipulation</h4>
<ul>
<li><code>clock()</code></li>
</ul>
<pre><code class="language-cpp">int main() {

  for (int i = 0; i &lt; 1000000; ++i) {}

  clock_t t = clock();
  printf("clock ticks since the program launched = %d", t);

  return 0;
}
</code></pre>
<pre><code class="language-cpp">clock ticks since the program launched = 10
</code></pre>
<blockquote>
<p><code>clock()</code> 计数的是 <code>从程序启动以来所经历的时间刻</code>。</p>
</blockquote>
<pre><code class="language-cpp">  typedef long clock_t;
</code></pre>
<blockquote>
<p>如果需要获取 <code>秒数</code>则要除以 <code>CLOCKS_PER_SECOND</code></p>
</blockquote>
<ul>
<li><code>time()</code></li>
</ul>
<pre><code class="language-cpp">int main() {

  time_t timer;
  time(&amp;timer);

  printf("timer = %d\n", timer);
  return 0;
}
</code></pre>
<pre><code class="language-cpp">timer = 1650518640
</code></pre>
<pre><code class="language-cpp">__MINGW_EXTENSION typedef __int64 __time64_t;
typedef __time64_t time_t;
</code></pre>
<blockquote>
<p><code>time_t</code>本质上是 <code>__int64</code>。</p>
<p>直接使用 <code>__int64</code> 或者 <code>long long</code>也可以被接受。</p>
</blockquote>
<ul>
<li><code>mktime()</code></li>
</ul>
<pre><code class="language-cpp">int main() {

  /* Get current timestamp &amp; use localtime() to get related struct tm */
  time_t raw_time;
  time(&amp;raw_time);
  struct tm * timeinfo = localtime(&amp;raw_time);

  /* Modify the struct tm &amp; use mktime() to get related timestamp */
  timeinfo-&gt;tm_year = 2022 - 1900;
  timeinfo-&gt;tm_mon = 4 - 1;
  timeinfo-&gt;tm_mday = 21;

  time_t timestamp = mktime(timeinfo);
  printf("timestamp = %d\n", timestamp);
  return 0;
}
</code></pre>
<pre><code class="language-cpp">timestamp = 1650519507
</code></pre>
<p><code>localtime()</code>：timestamp -&gt; tm
<code>mktime()</code> ：tm -&gt; timestamp</p>
<blockquote>
<p>对于 <code>struct tm</code>实例，我们不是直接构造，而是通过获取 <code>当前时间戳</code>，然后转化得到 <code>当前时间戳所对应的tm</code>，再修改 <code>tm的属性字段</code>，最后通过 <code>mktime()</code>来获得 <code>修改后的tm对应的时间戳</code></p>
</blockquote>
<blockquote>
<p><code>tm_wday</code> 和 <code>tm_yday</code>字段被 <code>忽略</code></p>
</blockquote>
<blockquote>
<p><code>year</code>从 <code>1900</code>开始，<code>month</code>从 <code>0</code>开始</p>
</blockquote>
<ul>
<li><code>difftime()</code></li>
</ul>
<h4>Conversion</h4>
<ul>
<li><code>asctime()</code>：tm -&gt; string</li>
<li><code>ctime()</code>：timestamp -&gt; string</li>
<li><code>gmtime()</code>：timestamp -&gt; tm(UTC)</li>
<li><code>localtime()</code>：timestamp tm(local)</li>
<li><code>strftime()</code>：format tm -&gt; string</li>
</ul>
<blockquote>
<p><code>strftime()</code>虽然提供了 <code>格式化tm结构</code>的功能，但 <code>struct tm</code>本身已经包含了足够的信息，可以非常方便地 <code>自定义格式化函数</code></p>
</blockquote>
<h3>Code Pointer</h3>
<p>除了常规的类型指针外，传统C语言还有一种指针称作 <code>代码指针</code>。</p>
<p>通过对 <code>代码片段</code>运用 <code>地址运算符</code>可以得到 <code>该代码片段的地址</code>。</p>
<pre><code class="language-cpp">int main() {

  s1:
  printf("hi\n");

  printf("address of s1 = %d\n", &amp;&amp; s1);

  void (*foo) (void) = reinterpret_cast&lt;void (*)(void)&gt;(4199857);
  foo();

  return 0;
}
</code></pre>
<pre><code class="language-cpp">hi
address of s1 = 4199857
hi
address of s1 = 4199857
hi
address of s1 = 4199857
hi
address of s1 = 4199857
hi
address of s1 = 4199857
hi
......
</code></pre>
<h3>Remove Const-Qualified</h3>
<h4><code>const_cast&lt;&gt;()</code></h4>
<pre><code class="language-cpp">  string str = "abc";
  char *str_data = const_cast&lt;char *&gt;(str.data());
  str_data[0] = 'A';
  cout &lt;&lt; str;
</code></pre>
<pre><code class="language-cpp">Abc
</code></pre>
