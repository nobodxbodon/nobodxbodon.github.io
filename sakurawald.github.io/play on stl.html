<h2><a href="https://github.com/sakurawald/sakurawald.github.io/blob/master/source/_posts/play-on-stl.md">仓库源文</a>，<a href="https://sakurawald.github.io/posts/play-on-stl">站点原文</a></h2>
<h1>Code Snippet</h1>
<pre><code class="lang-cpp">/* Template Begin */
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;deque&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
#include &lt;bitset&gt;
#include &lt;numeric&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;
#include &lt;tuple&gt;
#include &lt;complex&gt;
#include &lt;limits.h&gt;
#include &lt;stack&gt;
#include &lt;sstream&gt;
using namespace std;
/* Template End */
</code></pre>
<h3>ctype.h</h3>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalpha()</td>
<td></td>
</tr>
<tr>
<td>isdigit()</td>
<td></td>
</tr>
<tr>
<td>islower()</td>
<td></td>
</tr>
<tr>
<td>isupper()</td>
<td></td>
</tr>
<tr>
<td>ispunct()</td>
<td></td>
</tr>
<tr>
<td>isblank()</td>
<td>C標準庫只為\t和space返回非0值</td>
</tr>
<tr>
<td>tolower()</td>
<td></td>
</tr>
<tr>
<td>toupper()</td>
</tr>
</tbody>
</table>
<h3>limits.h</h3>
<table>
<thead><tr>
<th>Macro Constant</th>
</tr>
</thead>
<tbody>
<tr>
<td>INT_MIN</td>
</tr>
<tr>
<td>LONG_MIN</td>
</tr>
<tr>
<td>LLONG_MIN</td>
</tr>
<tr>
<td>UINT_MIN</td>
</tr>
<tr>
<td>ULLONG_MIN</td>
</tr>
</tbody>
</table>
<h3>math.h</h3>
<h4>Trigonometric Functions</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>sin(), cos(), tan(), asin(), acos(), atan()</td>
<td></td>
</tr>
<tr>
<td>atan2()</td>
<td>返回給定坐標的角度</td>
</tr>
</tbody>
</table>
<p>註：這些 <code>三角函數</code> 輸入均為 <code>浮點數</code>，默認使用 <code>弧度</code>作為單位。</p>
<h4>Hyperbolic Functions</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>sinh(), cosh(), tanh(), asinh(), acosh(), atanh()</td>
</tr>
</tbody>
</table>
<h4>Exponential and Logarithmic Functions</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>exp()</td>
<td>返回自然常數的指定指數值</td>
</tr>
<tr>
<td>log()</td>
<td>返回以自然常數為底的對數</td>
</tr>
<tr>
<td>log10()</td>
<td>返回以10為底的對數</td>
</tr>
<tr>
<td>log2()</td>
<td>返回以2為底的對數</td>
</tr>
</tbody>
</table>
<h4>Power Functions</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>pow()</td>
<td>該函數底層通過浮點數進行計算, 存在精度損失問題. 若確實需要使用, 請配合round()</td>
</tr>
<tr>
<td>sqrt()</td>
<td>返回平方根</td>
</tr>
<tr>
<td>bqrt()</td>
<td>返回立方根</td>
</tr>
<tr>
<td>hypot()</td>
<td>返回直角三角形的斜邊</td>
</tr>
</tbody>
</table>
<h4>Rounding and Remainder Functions</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>floow()</td>
</tr>
<tr>
<td>ceil()</td>
</tr>
</tbody>
</table>
<h4>Other Functions</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs()</td>
<td>用於求整數的絕對值 (用於浮點數時存在精度問題)</td>
</tr>
<tr>
<td>fabs()</td>
<td>用於求浮點數的絕對值</td>
</tr>
</tbody>
</table>
<h4>Classification Macro/Functions</h4>
<table>
<thead><tr>
<th>Macro/Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>isinf()</td>
<td>判斷浮點數是否無窮大</td>
</tr>
<tr>
<td>isnan()</td>
<td>判斷浮點數是否為實數</td>
</tr>
</tbody>
</table>
<h4>Comparison Macro/Functions</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>isgreater()</td>
</tr>
<tr>
<td>isgreaterequal()</td>
</tr>
</tbody>
</table>
<h3>stdio.h</h3>
<h4>Formatted Input/Output</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>scanf()</td>
<td>格式化輸入</td>
</tr>
<tr>
<td>printf()</td>
<td>格式化輸出</td>
</tr>
<tr>
<td>sscanf()</td>
<td>格式化輸入到字符串</td>
</tr>
<tr>
<td>sprintf()</td>
<td>格式化輸出到字符串</td>
</tr>
<tr>
<td>getchar()</td>
<td>該方法不會跳過空白字符(回車, 換行, 空格)</td>
</tr>
<tr>
<td>gets()</td>
<td>輸入1行 (以<code>\n</code>作為分隔符) 字符串</td>
</tr>
<tr>
<td>puts()</td>
<td>輸出1行字符串 (該方法會在末尾自動添加<code>\n</code>)</td>
</tr>
</tbody>
</table>
<h4>Macros</h4>
<table>
<thead><tr>
<th>Macro</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>EOF</td>
<td>值為-1的整數, 作為 <code>文件流的末尾標識字符</code> .&lt;br&gt;註: EOF並不屬於 <code>文件內容</code> 的一部分, 它只是一個 流狀態標識符</td>
</tr>
<tr>
<td>NULL</td>
<td>整數值為0的字符, 作為 字符串的末尾標識字符.&lt;br&gt;註: NULL字符 確實屬於 C語言風格字符串 的內容的一部分</td>
</tr>
<tr>
<td>size_t</td>
<td>無符號類型整數&lt;br&gt;註: 當其作為循環變量並與int類型的增量相運算時, 將存在類型轉化不兼容</td>
</tr>
</tbody>
</table>
<h3>stdlib.h</h3>
<h4>String Conversion</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>atoi(), atof(), atol(), atoll()</td>
<td>轉換string到int, double, long, long long</td>
</tr>
<tr>
<td>strtod(), strtoll(), strtoul(), strtoull()</td>
<td>轉換string(解釋為以base為基數)到long, long long, unsigned long, unsigned long long</td>
</tr>
</tbody>
</table>
<h4>Pseudo-Random Sequence Generation</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>srand()</td>
<td>初始化隨機數種子</td>
</tr>
<tr>
<td>rand()</td>
<td>生成下一個隨機數</td>
</tr>
</tbody>
</table>
<h4>Dynamic Memory Management</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>malloc()</td>
<td></td>
</tr>
<tr>
<td>calloc()</td>
<td>該方法會自動進行填0初始化</td>
</tr>
<tr>
<td>reallocI()</td>
<td></td>
</tr>
<tr>
<td>free()</td>
<td>釋放動態申請的內存</td>
</tr>
</tbody>
</table>
<h4>Searching and Sorting</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>qsort()</td>
<td>快速排序</td>
</tr>
<tr>
<td>bsearch()</td>
<td>二分查找</td>
</tr>
</tbody>
</table>
<h3>string.h</h3>
<h4>Copying</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>memcpy()</td>
</tr>
<tr>
<td>memmove()</td>
</tr>
<tr>
<td>strcpy()</td>
</tr>
</tbody>
</table>
<h4>Concatenation</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>strcat()</td>
</tr>
</tbody>
</table>
<h4>Comparison</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>memcmp()</td>
</tr>
<tr>
<td>strcmp()</td>
</tr>
</tbody>
</table>
<h4>Searching</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>memchr()</td>
</tr>
<tr>
<td>strchr()</td>
</tr>
<tr>
<td>strrchr()</td>
</tr>
<tr>
<td>strpbrk()</td>
</tr>
<tr>
<td>strcspn()</td>
</tr>
<tr>
<td>strspn()</td>
</tr>
<tr>
<td>strstr()</td>
</tr>
<tr>
<td>strtok()</td>
</tr>
</tbody>
</table>
<h4>Other</h4>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>memset()</td>
<td>該方法本質是 字符串. 若需要填充整數, 則只有下列整數的可行的: 0, -1</td>
</tr>
<tr>
<td>strlen()</td>
<td>該方法不計入字符串末尾的結束字符</td>
</tr>
</tbody>
</table>
<h3>time.h</h3>
<h4>Time Manipulation</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>clock()</td>
</tr>
<tr>
<td>difftime()</td>
</tr>
<tr>
<td>mktime()</td>
</tr>
<tr>
<td>time()</td>
</tr>
</tbody>
</table>
<h4>Conversion</h4>
<table>
<thead><tr>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>asctime()</td>
</tr>
<tr>
<td>ctime()</td>
</tr>
<tr>
<td>gmtime()</td>
</tr>
<tr>
<td>localtime()</td>
</tr>
<tr>
<td>strftime()</td>
</tr>
</tbody>
</table>
<h2>Containers</h2>
<h3>vector</h3>
<h3>queue</h3>
<h3>deque</h3>
<h3>stack</h3>
<h3>list</h3>
<h3>set</h3>
<h3>map</h3>
<h3>unordered_map</h3>
<h3>unordered_set</h3>
<h2>Other Libraries</h2>
<table>
<thead><tr>
<th>Library</th>
</tr>
</thead>
<tbody>
<tr>
<td>algorithm</td>
</tr>
<tr>
<td>bitset</td>
</tr>
<tr>
<td>chrono</td>
</tr>
<tr>
<td>codecvt</td>
</tr>
<tr>
<td>complex</td>
</tr>
<tr>
<td>exception</td>
</tr>
<tr>
<td>functional</td>
</tr>
<tr>
<td>initializer_list</td>
</tr>
<tr>
<td>iterator</td>
</tr>
<tr>
<td>limits</td>
</tr>
<tr>
<td>locale</td>
</tr>
<tr>
<td>memory</td>
</tr>
<tr>
<td>new</td>
</tr>
<tr>
<td>numeric</td>
</tr>
<tr>
<td>random</td>
</tr>
<tr>
<td>ratio</td>
</tr>
<tr>
<td>regex</td>
</tr>
<tr>
<td>stdexcept</td>
</tr>
<tr>
<td>string</td>
</tr>
<tr>
<td>system_error</td>
</tr>
<tr>
<td>tuple</td>
</tr>
<tr>
<td>typeindex</td>
</tr>
<tr>
<td>typeinfo</td>
</tr>
<tr>
<td>type_traits</td>
</tr>
<tr>
<td>utility</td>
</tr>
<tr>
<td>valarray</td>
</tr>
</tbody>
</table>
<h2>Code Snippets</h2>
<h3>Initialize the Array with Fixed-Element</h3>
<ul>
<li><code>定義時</code> 使用 <code>列表初始化</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[10] = {1,2,3};
</code></pre>
<pre><code class="lang-cpp">1 2 3 0 0 0 0 0 0 0
</code></pre>
<blockquote><p><code>列表初始化</code> 會 <code>列表的元素</code>填充到 <code>數組的前幾個元素</code>，<code>數組的剩余元素</code>一律 <code>填0</code></p>
</blockquote>
<ul>
<li>使用 <code>memset</code>進行 <code>內存字符填充</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[10];
  memset(arr, 0, sizeof(array));
</code></pre>
<pre><code class="lang-cpp">0 0 0 0 0 0 0 0 0 0
</code></pre>
<blockquote><p>註意：該種方法只能用於填充 <code>0</code>和 <code>-1</code></p>
</blockquote>
<ul>
<li>利用 <code>全局變量</code>自動 <code>初始化填0</code>的特性</li>
</ul>
<pre><code class="lang-cpp">int arr[10];
int main() {
  for (int i = 0; i &lt; 10; ++i) {
    printf("%d ", arr[i]);
  }
  return 0;
}
</code></pre>
<pre><code class="lang-cpp">0 0 0 0 0 0 0 0 0 0
</code></pre>
<ul>
<li>使用 <code>fill()</code> 填充函數</li>
</ul>
<pre><code class="lang-cpp">  int arr[10];
  fill(arr, arr + 10, 2022);
</code></pre>
<pre><code class="lang-cpp">2022 2022 2022 2022 2022 2022 2022 2022 2022 2022
</code></pre>
<blockquote><p><code>fill_n()</code> 只用 <code>指定值</code> 填充 <code>前n個元素</code></p>
<pre><code class="lang-cpp">int arr[10];
fill_n(arr, 3, 2020);
</code></pre>
<pre><code class="lang-cpp">2020 2020 2020 0 8 0 75 0 16875376 0
</code></pre>
</blockquote>
<h3>Initialize the Array with Generated-Element</h3>
<ul>
<li>使用 <code>generate()</code> 生成函數</li>
</ul>
<pre><code class="lang-cpp">  int arr[10];
  generate(arr, arr + 10, []() { return rand() % 5; });
</code></pre>
<pre><code class="lang-cpp">1 2 4 0 4 4 3 3 2 4
</code></pre>
<blockquote><p>如果需要讓 <code>generate()</code> 保存 <code>狀態</code>，則可以利用 <code>靜態局部變量</code>來實現。</p>
<blockquote><p>用 <code>全局變量</code>也可以，但 <code>靜態局部變量</code>使得 <code>代碼結構</code>更加 <code>緊湊</code></p>
</blockquote>
<pre><code class="lang-cpp">  int arr[10];
  generate(arr, arr + 10, []() {
      static int i = 1;
      return i *= 2;
  });
</code></pre>
<pre><code>2 4 8 16 32 64 128 256 512 1024
</code></pre>
</blockquote>
<h3>Generate Lexicographical-Permutation</h3>
<ul>
<li>使用 <code>next_permutation()</code></li>
</ul>
<pre><code class="lang-cpp">  string words = "abc";
  do {
    cout &lt;&lt; words &lt;&lt; endl;
  } while (next_permutation(words.begin(), words.end()));
</code></pre>
<pre><code class="lang-cpp">abc
acb
bac
bca
cab
cba
</code></pre>
<blockquote><p>同理，<code>prev_permutation()</code>則是 <code>生成上一個排列</code></p>
</blockquote>
<p>相關輔助函數：<code>is_permutation()</code></p>
<h3>Hash Function</h3>
<ul>
<li>使用 <code>hash結構體模板</code></li>
</ul>
<pre><code class="lang-cpp">  hash&lt;string&gt; string_hash;
  string first_words = "abc";
  string second_words = "cba";

  printf("hash(first_words) = %lld", string_hash(first_words));
  printf("\n");
  printf("hash(second_words) = %lld", string_hash(second_words));
</code></pre>
<pre><code class="lang-cpp">hash(first_words) = 3663726644998027833
hash(second_words) = -4830583261295167161
</code></pre>
<h3>Find the Index of A Specific Element</h3>
<ul>
<li>使用 <code>find()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90};
  int index = find(arr, arr + 10, 70) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="lang-cpp">index = 7
</code></pre>
<ul>
<li>使用 <code>find_if()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90};
  int index = find_if(arr, arr + 10, [](const auto &amp;obj) {
      return obj != 0 &amp;&amp; obj % 15 == 0;
  }) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="lang-cpp">index = 3
</code></pre>
<h3>Find the Index of A Subsequence</h3>
<ul>
<li>使用 <code>find_first()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 30, 40, 50, 10, 20, 30, 40, 50, 60, 70, 80, 90};
  int needle[] = {30, 40, 50};
  int index = find_first_of(arr, arr + 13, needle, needle + 3) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="lang-cpp">index = 1
</code></pre>
<blockquote><p><code>find_first_of()</code> ：返回 <code>第一個相等的子序列</code>的 <code>首元素下標</code></p>
<p><code>find_end()</code>：返回 <code>最後一個相等的子序列</code>的 <code>首元素下標</code></p>
</blockquote>
<ul>
<li>使用 <code>search()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 10, 20, 30, 40, 50, 60, 70, 80, 90};
  int needle[] = {30, 40, 50};
  int index = search(arr, arr + 10, needle, needle + 3) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="lang-cpp">index = 3
</code></pre>
<blockquote><p><code>search</code>返回的是 <code>第一個滿足條件的元素</code></p>
<p>默認的 <code>search()</code>使用的是 <code>相等謂詞</code>，我們也可以自定義 <code>二元相等謂詞</code></p>
<pre><code class="lang-cpp">int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int needle[] = {9, 16, 25};
int index = search(arr, arr + 10, needle, needle + 3, [](const auto &amp;o1, const auto &amp;o2) {
 return o1  * o1 == o2;
}) - arr;
printf("index = %d", index);
</code></pre>
<pre><code class="lang-cpp">index = 3
</code></pre>
<p>此外，如果我們的 <code>子序列</code>是 <code>相同元素組成的指定長度的子序列</code>，則可以直接使用 <code>search_n()</code></p>
<pre><code class="lang-cpp">int arr[] = {0, 1, 2, 9, 9, 5, 6, 7, 8, 9, 10};
int index = search_n(arr, arr + 10, 2, 9) - arr;
printf("index = %d", index);
</code></pre>
<pre><code class="lang-cpp">index = 3
</code></pre>
</blockquote>
<h3>Find in Two-Consecutive Elements</h3>
<ul>
<li>使用 <code>find_adjacent()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 10, 20, 20, 40, 50, 60, 70, 80, 90};
  int index = adjacent_find(arr, arr + 10, [](const auto &amp;o1, const auto &amp;o2){
    return o1 == o2;
  }) - arr;
  printf("index = %d", index);
</code></pre>
<pre><code class="lang-cpp">index = 2
</code></pre>
<h3>Count the number of elements for which predicate is true</h3>
<ul>
<li>使用 <code>count_if()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int cnt = count_if(arr, arr + 10, [](const auto &amp;o1) {
      return o1 % 2 == 0;
  });
  printf("cnt = %d", cnt);
</code></pre>
<pre><code class="lang-cpp">cnt = 5
</code></pre>
<h3>Return the First Position where Two Ranges differs</h3>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 30, 4, 5, 6, 7, 8, 9};
  int needle[] = {0, 1, 2};
  pair&lt;int *, int *&gt; ret = mismatch(arr, arr + 10, needle);
  printf("ret-&gt;first = %d", ret.first - arr);
  printf("\n");
  printf("ret-&gt;second = %d", ret.second - needle);
</code></pre>
<pre><code class="lang-cpp">ret-&gt;first = 3
ret-&gt;second = 3
</code></pre>
<blockquote><p><code>mismatch()</code> 默認使用的 <code>二元相等謂詞</code> 就是 <code>operator=</code>。</p>
<p>如果需要，可以自定義 <code>二元相等謂詞</code></p>
<p><code>equal()</code> 與 <code>mismatch()</code>類似，但它只返回 <code>是否相等</code></p>
</blockquote>
<h3>Test For-All and Exist</h3>
<ul>
<li>使用 <code>all_of()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 2, 4, 6, 8, 10};
  bool flag = all_of(arr, arr + 6, [](const auto&amp;o1){
    return o1 % 2 == 0;
  });
  cout &lt;&lt; flag;
</code></pre>
<pre><code class="lang-cpp">1
</code></pre>
<blockquote><p><code>any_of()</code>同理，它可以測試是否有 <code>任何一個元素</code>滿足 <code>條件</code>。</p>
<p><code>none_of()</code> 可以用 <code>all_of()</code> 取反來實現。</p>
</blockquote>
<h3>Apply function to range</h3>
<ul>
<li>使用 <code>for_each()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  for_each(arr, arr + 10, [](const auto &amp; o1){
    cout &lt;&lt; o1 * o1 &lt;&lt; " ";
  });
</code></pre>
<pre><code class="lang-cpp">0 1 4 9 16 25 36 49 64 81
</code></pre>
<h3>Remove Duplicates</h3>
<ul>
<li>使用 <code>sort()</code> 配合 <code>unique()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {10, 10, 20, 30, 40, 50, 10, 60, 70, 80};
  unique(arr, arr + 10);
  for (int i = 0; i &lt; 10; ++i) {
    printf("%d ", arr[i]);
  }
</code></pre>
<pre><code class="lang-cpp">10 20 30 40 50 10 60 70 80 80
</code></pre>
<blockquote><p>n.b. <code>unique()</code> 的 <code>語義</code>並不是 <code>去除序列的重復元素</code>，而是 <code>去除序列的連續的重復元素 (只保留一個相同元素)</code>。</p>
<p>上述例子中只有 <code>連續的10</code>被去除。</p>
<p>如果確實要去除 <code>序列中所有的重復元素</code>，則應當先 <code>sort()</code>使得 <code>所有的相同元素</code>是 <code>連續排列的</code>，再使用 <code>unique()</code></p>
<p>該函數也有 <code>可復製到指定輸出流的版本</code> <code>unique_copy()</code></p>
</blockquote>
<h3>Print Range</h3>
<ul>
<li>使用 <code>for_each()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  for_each(arr, arr + 10, [](const auto &amp;item) {
      cout &lt;&lt; item &lt;&lt; " ";
  });
</code></pre>
<ul>
<li>使用 <code>copy()</code></li>
</ul>
<pre><code class="lang-cpp">  copy(arr, arr + 10, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<h3>Copy range of elements</h3>
<ul>
<li>使用 <code>copy()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int dest[10];
  copy(arr, arr + 10, dest);
</code></pre>
<blockquote><p>可以使用 <code>帶謂詞的版本</code> <code>copy_if()</code></p>
<p>如果需要 <code>反向遍歷</code>，可以使用 <code>copy_backward()</code></p>
</blockquote>
<h3>Move range of elements</h3>
<ul>
<li>使用 <code>move()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  move(arr, arr + 2, arr + 3);
</code></pre>
<pre><code class="lang-cpp">0 1 2 0 1 5 6 7 8 9
</code></pre>
<blockquote><p><code>move()</code>方法允許 <code>目標內存區域</code>和 <code>來源內存區域</code>發生 <code>重疊</code>。</p>
<p>但是，<code>move()</code>不保證 <code>來源內存區域</code>的 <code>內容</code>仍 <code>保持原樣</code></p>
</blockquote>
<h3>Transform Range</h3>
<ul>
<li>使用 <code>transform()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  transform(arr, arr + 10, arr, [](const auto &amp; o1){
    return o1 * o1;
  });
  copy(arr, arr + 10, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">0 1 4 9 16 25 36 49 64 81
</code></pre>
<blockquote><p><code>transform()</code>可以指定 <code>輸出目標流</code>，並且允許 <code>輸出目標流</code>和 <code>輸入流</code>發生 <code>重疊</code>。</p>
<p>有點類似 <code>for_each()</code>，但 <code>for_each()</code>經常用於 <code>非修改性操作</code>，而 <code>transform()</code> 用於 <code>修改性操作</code></p>
</blockquote>
<h3>Replace Values in Range</h3>
<ul>
<li>使用 <code>replace()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  replace(arr, arr + 10, 3, 3000);
</code></pre>
<pre><code class="lang-cpp">0 1 2 3000 4 5 6 7 8 9
</code></pre>
<blockquote><p>可以使用 <code>帶謂詞版本的</code> <code>replace_if()</code>來替代 <code>replace()</code>：只有當 <code>謂詞</code> <code>測試通過</code>時，才會用 <code>新值</code> 替換 <code>當前元素</code></p>
</blockquote>
<ul>
<li>使用 <code>replace_copy()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int dest[10];
  replace_copy(arr, arr + 10, dest, 3, 3000);
  copy(arr, arr + 10, ostream_iterator&lt;int&gt;(cout, " "));
  printf("\n");
  copy(dest, dest + 10, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">0 1 2 3000 4 5 6 7 8 9
</code></pre>
<blockquote><p>相比於 <code>replace()</code>而言，<code>replace_copy()</code>可以指定 <code>修改結果的輸出流</code>。</p>
<blockquote><p>特別地，<code>replace_copy()</code>可以重新將 <code>輸出流</code>指定為 <code>輸入流</code></p>
<p>在這個情況下，<code>replace_copy()</code>等價於 <code>replace()</code></p>
</blockquote>
<p>此外，還有一個 <code>帶謂詞版本的</code> <code>repalce_copy_if()</code></p>
<p>我們稱它是<code>萬能的替換函數</code>，因為它可以取代：<code>repalce()</code>，<code>replace_if()</code>，<code>replace_copy()</code></p>
</blockquote>
<h3>Reverse Range</h3>
<ul>
<li>使用 <code>reverse()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  reverse(arr, arr + 10);
</code></pre>
<pre><code class="lang-cpp">9 8 7 6 5 4 3 2 1 0
</code></pre>
<blockquote><p><code>可復製到指定輸出流的版本</code> <code>reverse_copy()</code></p>
</blockquote>
<h3>Rotate left the elements in range</h3>
<ul>
<li>使用 <code>rotate()</code></li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  rotate(arr, arr + 3, arr + 10);
</code></pre>
<pre><code class="lang-cpp">3 4 5 6 7 8 9 0 1 2
</code></pre>
<h3>Rearrange elements in range</h3>
<ul>
<li>使用 <code>random_shuffle()</code> 隨機生成函數</li>
</ul>
<pre><code class="lang-cpp">  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  random_shuffle(arr, arr + 10);
</code></pre>
<pre><code class="lang-cpp">8 1 9 2 0 5 7 3 4 6
</code></pre>
<blockquote><p>該方法可用於 <code>洗牌算法</code></p>
</blockquote>
<h3>Merge (Operating on Sorted Ranges)</h3>
<ul>
<li>使用 <code>set_intersection()</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; A = {1, 2, 3};
  vector&lt;int&gt; B = {3, 4, 5, 6};
  sort(A.begin(), A.end());
  sort(B.begin(), B.end());
  vector&lt;int&gt; result(10);
  auto it = set_intersection(A.begin(), A.end(), B.begin(), B.end(), result.begin());
  copy(result.begin(), it, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">3
</code></pre>
<ul>
<li>集合交 -&gt; <code>set_union()</code></li>
<li>集合差 -&gt; <code>set_difference()</code></li>
<li>集合對稱差 -&gt; <code>set_symmetric_difference()</code></li>
<li>歸並 -&gt; <code>merge()</code>：<code>歸並操作</code></li>
</ul>
<blockquote><p>相比於 <code>set_union()</code>而言，<code>merge()</code>會 <code>保留多個相同的元素</code></p>
</blockquote>
<ul>
<li>原址性歸並 -&gt; <code>inplace_merge()</code>：<code>原址性的歸並操作</code></li>
</ul>
<pre><code class="lang-cpp">    vector&lt;int&gt; arr = {1, 1, 2, 3, 4, 2, 3, 4, 5, 6, 7};
    inplace_merge(arr.begin(), arr.begin() + 5, arr.end());
</code></pre>
<pre><code class="lang-cpp">     1 1 2 2 3 3 4 4 5 6 7
</code></pre>
<ul>
<li>測試包含關系 -&gt; <code>includes()</code></li>
<li><blockquote><pre><code class="lang-cpp">vector&lt;int&gt; A = {0,1,2,3,4,5,6,7,8,9};
vector&lt;int&gt; B = {3,4,5,6};
cout &lt;&lt; includes(A.begin(), A.end(), B.begin(), B.end());
printf("\n");
cout &lt;&lt; includes(B.begin(), B.end(), A.begin(), A.end());
</code></pre>
<pre><code class="lang-cpp">1
0
</code></pre>
</blockquote>
</li>
</ul>
<blockquote><p>n.b. 上述的 <code>所有的歸並操作</code>在使用之前，都需要用 <code>sort()</code> 對 <code>集合A</code> 和 <code>集合B</code> 進行 <code>預處理</code>。</p>
<p>否則將導致輸出結果的錯誤。</p>
</blockquote>
<h3>Min/Max</h3>
<ul>
<li><p>最小元素/最大元素 -&gt; <code>min_element()</code> 和 <code>max_element()</code></p>
<pre><code class="lang-cpp">   vector&lt;int&gt; v = {3, 5, 2, 7, 1, 9, 4};
   int index = min_element(v.begin(), v.end()) - v.begin();
   printf("%d ", index);
</code></pre>
<pre><code class="lang-cpp">   4
</code></pre>
<blockquote><p><code>minmax_element()</code>返回一個 <code>(最小值叠代器，最大值叠代器)</code>的 <code>二元組</code></p>
</blockquote>
</li>
</ul>
<h3>Heap</h3>
<p><code>堆操作函數</code>將一個 <code>數組</code>維護 <code>堆結構</code>，但除此之外，我們還需要一個 <code>表示堆大小的整數</code>。</p>
<blockquote><p>n.b. <code>數組的大小</code> 不一定等於 <code>堆的大小</code>，我們有可能 <code>只使用數組中的一部分連續區域</code> 來構成 <code>堆</code></p>
<p>n.b. 使用 <code>數組</code>時需要 <code>額外維護一個表示堆大小的整數</code>。但如果使用的是 <code>vector</code>，則可以 <code>在每次堆操作後</code>手動地 <code>維護vector</code>，使得 <code>vector的大小</code>始終與 <code>heap的大小</code> 相等。</p>
<p>與 <code>Java</code>的是，<code>C++</code>的 <code>Heap</code>默認是 <code>最大堆</code>，同理，<code>基於Heap的PriorityQueue</code>也默認是 <code>最大優先隊列</code></p>
</blockquote>
<ul>
<li><p><code>make_heap()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
    make_heap(v.begin(), v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  9 7 8 6 4 5 1 2 0 3
</code></pre>
</li>
<li><p><code>pop_heap()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
    make_heap(v.begin(), v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    printf("\n");

    pop_heap(v.begin(), v.end());
    v.pop_back();
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  9 7 8 6 4 5 1 2 0 3
  8 7 5 6 4 3 1 2 0
</code></pre>
</li>
<li><p><code>push_heap()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
    make_heap(v.begin(), v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    printf("\n");

    v.push_back(10);
    push_heap(v.begin(), v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  9 7 8 6 4 5 1 2 0 3
  10 9 8 6 7 5 1 2 0 3 4
</code></pre>
</li>
</ul>
<p>除此之外，還有一些 <code>輔助操作</code>。</p>
<ul>
<li><p><code>sort_heap()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
    make_heap(v.begin(), v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    printf("\n");

    sort_heap(v.begin(), v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  9 7 8 6 4 5 1 2 0 3
  0 1 2 3 4 5 6 7 8 9
</code></pre>
</li>
<li><p><code>is_heap()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {5, 6, 8, 2, 3, 9, 1, 7, 0, 4};
    make_heap(v.begin(), v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    printf("\n");

    cout &lt;&lt; is_heap(v.begin(), v.end());
</code></pre>
<pre><code class="lang-cpp">  9 7 8 6 4 5 1 2 0 3
  1
</code></pre>
</li>
</ul>
<p>大部分情況下，如果需要使用 <code>優先隊列</code>可以首先考慮 <code>priority_queue</code>。</p>
<p>但如果需要一些更底層的操作，可以使用 <code>heap functions</code></p>
<h3>Binary Search</h3>
<ul>
<li>下界函數/上界函數</li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  int ret1 = lower_bound(v.begin(), v.end(), 3) - v.begin();
  int ret2 = upper_bound(v.begin(), v.end(), 3) - v.begin();
  printf("lower_bound = %d ", ret1);
  printf("\n");
  printf("upper_bound = %d ", ret2);
</code></pre>
<pre><code class="lang-cpp">lower_bound = 3
upper_bound = 4
</code></pre>
<blockquote><p>n.b. <code>lower_bound()</code>和 <code>upper_bound()</code>的 <code>語義</code> 可能直觀上和 <code>名稱</code>不同。</p>
<p>但實際上， <code>lower_bound()</code>指的是 <code>not less than</code></p>
<p>而 <code>upper_bound()</code> 指的是 <code>greater than</code></p>
</blockquote>
<ul>
<li><code>binary_search()</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  bool found = binary_search(v.begin(), v.end(), 3);
  printf("found = %d", found);
</code></pre>
<pre><code class="lang-cpp">found = 1
</code></pre>
<blockquote><p>如果 <code>已知序列是有序的</code>，則可以用 <code>binary search</code>代替 <code>linear search</code>來獲得更高的效率。</p>
<p>但是，如果需要獲取 <code>下標</code>，則需要使用 <code>lower_bound()</code>來進行 <code>二分查找</code></p>
<blockquote><p>盡管C標準庫確實有一個 <code>bsearch()</code>函數，但該函數原型對於C++的很多數據結構來說，並不適合。</p>
</blockquote>
</blockquote>
<ul>
<li><p><code>equal_range()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {0, 1, 2, 3, 3, 5, 6, 7, 8, 9};
    auto ret = equal_range(v.begin(), v.end(), 3);
    printf("first = %d\n", ret.first - v.begin());
    printf("second = %d\n", ret.second - v.begin());
</code></pre>
<pre><code class="lang-cpp">  first = 3
  second = 5
</code></pre>
<blockquote><p>需要在 <code>有序序列</code>中查找 <code>一段連續的相同的元素</code>的 <code>下標範圍</code>，則可以使用 <code>equal_range()</code></p>
</blockquote>
</li>
</ul>
<h3>Sorting</h3>
<ul>
<li><p><code>sort()</code>：<code>快速排序</code>，<code>非穩定性的</code></p>
</li>
<li><p><code>stable_sort()</code>：<code>穩定性的排序</code></p>
</li>
<li><p><code>partial_sort()</code>：<code>劃分排序</code>，可以按照 <code>基準元素</code>將 <code>序列</code> 進行 <code>劃分</code>為 <code>兩個部分</code></p>
</li>
<li><p><code>is_sorted()</code>：判斷 <code>序列</code>是否所有元素滿足 <code>偏序關系</code></p>
<blockquote><p>通常情況下，我們定義的 <code>偏序關系</code>也就是 <code>operator &lt;</code>。</p>
<p>在這個意義上，<code>is_sorted()</code> 默認是 <code>判斷序列是否升序</code>，</p>
<p>如果希望判斷 <code>序列是否是降序的</code>，可以利用 <code>反向叠代器</code>來實現。</p>
<pre><code class="lang-cpp">   vector&lt;int&gt; increase = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   vector&lt;int&gt; decrease = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
   cout &lt;&lt; is_sorted(increase.begin(), increase.end()) &lt;&lt; endl;
   cout &lt;&lt; is_sorted(decrease.begin(), decrease.end()) &lt;&lt; endl;
   cout &lt;&lt; is_sorted(decrease.rbegin(), decrease.rend());
</code></pre>
</blockquote>
<pre><code class="lang-cpp">   1
   0
   1
</code></pre>
</li>
<li><p><code>nth_element()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {4, 7, 6, 8, 9, 2, 1, 3, 5};
    nth_element(v.begin(), v.begin() + 1, v.end());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  1 2 4 3 5 6 7 9 8
</code></pre>
<blockquote><p><code>nth_element()</code>可以使得 <code>序列中指定位置的值</code>為 <code>排序該序列後該位置放置的元素</code>。</p>
<p>但除了讓 <code>指定位置為排序後的序列應放置的元素</code>之外， <code>其他位置的元素</code>可能會受到 <code>位置改變的副作用</code></p>
</blockquote>
</li>
</ul>
<h3>Partitions</h3>
<ul>
<li><p><code>partition()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {5, 3, 7, 4, 2, 9, 0, 8, 1};
    int ret = partition(v.begin(), v.end(), [](const auto&amp;o1){
      return o1 &lt; 4;
    }) - v.begin();
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
    printf("\nthe index of the first element in the second group: %d", ret);
</code></pre>
<pre><code class="lang-cpp">  1 3 0 2 4 9 7 8 5
  the index of the first element in the second group: 4
</code></pre>
<blockquote><p><code>partition()</code> 劃分函數 將 <code>序列</code>按照 <code>一元謂詞</code>劃分為 <code>2個部分</code>：</p>
<ul>
<li>第1部分：滿足謂詞的元素</li>
<li>第2部分：不滿足謂詞的元素</li>
</ul>
<p>它的返回值是 <code>第2部分的第一個元素的下標</code></p>
<blockquote><p>n.b. 我們可以發現，STL中很多關於 <code>2劃分</code> 所返回的下標，均遵循 <code>the index of the first element in the second group</code>的原則。</p>
<p>同樣地，類似的規律有 <code>取頭不取尾的區間表示方法 [begin, end)</code></p>
<p>變種版本：<code>partition_copy()</code>，<code>stable_partition()</code></p>
</blockquote>
</blockquote>
</li>
<li><p><code>is_partitioned()</code></p>
</li>
<li><p><code>partition_point()</code></p>
<pre><code class="lang-cpp">   vector&lt;int&gt; v = {5, 3, 7, 4, 2, 9, 0, 8, 1};
   int ret = partition(v.begin(), v.end(), [](const auto &amp;o1) {
      return o1 &lt; 4;
   }) - v.begin();
   copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
   printf("\nthe index of the first element in the second group: %d", ret);
   // partition_point()
   auto point = partition_point(v.begin(), v.end(), [](const auto &amp;o1) {
      return o1 &lt; 4;
   });
   printf("\n");
   for (auto iter = v.begin(); iter != point; iter++) {
    printf("%d ", *iter);
   }
</code></pre>
<pre><code class="lang-cpp">   1 3 0 2 4 9 7 8 5
   the index of the first element in the second group: 4
   1 3 0 2
</code></pre>
<p>可用於 <code>反求</code> <code>劃分的分割點的叠代器</code></p>
</li>
</ul>
<h3>Bitset</h3>
<p><code>位圖 (bitset)</code> 是C++ 容器庫之外的一個數據結構，它用 <code>1個二進製位</code>表示 <code>1個邏輯型變量</code>。</p>
<p>相比於 <code>char (8-bit)</code>而言，更 <code>節約空間</code>。</p>
<p>更重要的是，<code>bitset</code>提供了一些方便的 <code>數據操作函數</code>和 <code>數據查詢函數</code>，以及對 <code>字符串輸出</code>的支持。</p>
<ul>
<li><p>數據操作函數</p>
<ul>
<li><code>置位 (set)</code>：將 <code>指定下標的位</code>設置為 <code>1</code></li>
<li><code>復位 (reset)</code>：將 <code>指定下標的位</code>設置為 <code>0</code></li>
<li><code>翻轉 (flip)</code>：將 <code>指定下標的位</code>進行 <code>翻轉</code></li>
</ul>
</li>
<li><p>數據查詢函數</p>
<ul>
<li><p><code>測試 (test)</code>：返回 <code>指定下標的位</code></p>
</li>
<li><p><code>計數 (count)</code>：返回 <code>被置位的位數</code></p>
<ul>
<li><code>全部已置位 (all)</code>：是否 <code>所有的位</code>都被 <code>置位</code></li>
<li><code>任何已置位 (any)</code>：是否 <code>任何一個位</code>被 <code>置位</code></li>
<li><code>沒有已置位 (none)</code>：是否 <code>沒有任何一個位</code>被 <code>置位</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-cpp">  bitset&lt;32&gt; bits;
  bits.set(0,true);
  cout &lt;&lt; bits;
</code></pre>
<pre><code class="lang-cpp">00000000000000000000000000000001
</code></pre>
<blockquote><p>在 <code>空間緊張</code>的情況下，<code>bitset&lt;size&gt;</code>可能會優於 <code>vector&lt;bool&gt;</code>。</p>
<blockquote><p>事實上，這並不一定。因為 <code>vector&lt;bool&gt;</code>和 <code>普通的泛化vector</code>不同，</p>
<p>它是 <code>vector模板的特例化</code>，具體庫實現很有可能針對 <code>vector&lt;bool&gt;</code>做出特別的優化。</p>
</blockquote>
<p>但不同於 <code>vector</code>的 <code>動態伸縮</code>， <code>bitset</code>的大小是通過 <code>模板</code>固定的，在編譯期確立和內存空間。</p>
</blockquote>
<h3>Complex</h3>
<p>STL庫提供的 <code>復數</code>實現，同時重載了 <code>運算符</code>。</p>
<pre><code class="lang-cpp">  complex&lt;int&gt; a = {1,2};
  complex&lt;int&gt; b = {3,4};
  cout &lt;&lt; a + b;
</code></pre>
<pre><code class="lang-cpp">(4,6)
</code></pre>
<h3>Ratio</h3>
<p>由C++提供的 <code>比例 (Ratio)</code>庫。可以直接作為 <code>分數</code>庫使用。</p>
<pre><code class="lang-cpp">  typedef ratio&lt;1, 2&gt; one_half;
  typedef ratio&lt;2, 3&gt; two_thirds;
  ratio_add&lt;one_half, two_thirds&gt; sum;
  printf("fraction: %d/%d", sum.num, sum.den);
</code></pre>
<pre><code class="lang-cpp">fraction: 7/6
</code></pre>
<blockquote><p>他們本質上是 <code>宏</code>，只能在 <code>編譯期</code>確定數值。</p>
</blockquote>
<h3>Tuple</h3>
<p>當需要表示 <code>多種數據類型的有序序列</code>，則可以使用 <code>元組 (Tuple)</code>。</p>
<blockquote><p>比如如果需要返回 <code>2個返回值</code>時，比起 <code>structure</code>來說，<code>tuple</code>會更加方便</p>
<blockquote><p>實際上，有另一個東西叫 <code>make_pair()</code></p>
</blockquote>
</blockquote>
<ul>
<li>Construct Tuple and Get Elements</li>
</ul>
<pre><code class="lang-cpp">  tuple&lt;string, int&gt; t1("hello", 100);
  cout &lt;&lt; "get&lt;0&gt; = " &lt;&lt; get&lt;0&gt;(t1) &lt;&lt; endl;
  cout &lt;&lt; "get&lt;1&gt; = " &lt;&lt; get&lt;1&gt;(t1);
</code></pre>
<pre><code class="lang-cpp">get&lt;0&gt; = hello
get&lt;1&gt; = 100
</code></pre>
<blockquote><p>實際上，比起 <code>構造器</code>而言， 我們更經常使用 <code>make_tuple()</code> 來構造元組。</p>
</blockquote>
<pre><code class="lang-cpp"> auto t2 = make_tuple("hello", "world", 100);
</code></pre>
<ul>
<li>Use <code>tie()</code> to Unpack Tuple</li>
</ul>
<pre><code class="lang-cpp">  auto tuple = make_tuple("hello", "world", 100);

  string str1;
  string str2;
  int num;
  tie(str1, str2, num) = tuple;

  cout &lt;&lt; str1 &lt;&lt; endl;
  cout &lt;&lt; str2 &lt;&lt; endl;
  cout &lt;&lt; num &lt;&lt; endl;
</code></pre>
<pre><code class="lang-cpp">hello
world
100
</code></pre>
<blockquote><p>如果只需要 <code>unpack</code>其中 <code>某些元素</code>，則可以使用 <code>std::ignore</code>來進行 <code>占位</code></p>
</blockquote>
<pre><code class="lang-cpp"> auto tuple = make_tuple("hello", "world", 100);

 string str1;
 int num;
 tie(str1, std::ignore, num) = tuple;

 cout &lt;&lt; str1 &lt;&lt; endl;
 cout &lt;&lt; num &lt;&lt; endl;
</code></pre>
<h3>Utility</h3>
<ul>
<li><code>swap()</code></li>
<li><code>make_pair()</code>
   如果只需要 <code>2元組</code>的情況下，用 <code>make_pair()</code>會比 <code>make_tuple()</code>方便非常多。後者的 <code>accessor</code>用起來比較麻煩。</li>
</ul>
<h3>Accumulate values in range</h3>
<ul>
<li>使用 <code>accumulate()</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; v = {0,1,2,3,4,5,6,7,8,9};
  int sum = accumulate(v.begin(), v.end(), 0);
  cout &lt;&lt; sum;
</code></pre>
<pre><code class="lang-cpp">45
</code></pre>
<blockquote><p><code>accumulate()</code> 不僅僅是用於 <code>累加</code>，它還支持 <code>帶有二元謂詞的版本</code>。</p>
<p>可以利用 <code>二元謂詞</code>來實現 <code>累減</code>，<code>累乘</code>，<code>累除</code>等</p>
<pre><code class="lang-cpp"> vector&lt;int&gt; v = {1, 2, 3, 4};
 int sum = accumulate(v.begin(), v.end(), 1, [](const auto &amp;o1, const auto &amp;o2) {
    return o1 * o2;
 });
 cout &lt;&lt; sum;
</code></pre>
</blockquote>
<pre><code class="lang-cpp"> 24
</code></pre>
<h3>Compute adjacent difference of range</h3>
<ul>
<li>使用 <code>adjacent_difference()</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; v = {1,4,6,10};
  adjacent_difference(v.begin(), v.end(), v.begin());
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">1 3 2 4
</code></pre>
<blockquote><p><code>adjacent_difference()</code> 不但可以用於 <code>差分</code>，還可以進行 <code>和分</code>，<code>積分</code>，<code>商分</code></p>
<pre><code class="lang-cpp"> vector&lt;int&gt; v = {1, 4, 6, 10};
 adjacent_difference(v.begin(), v.end(), v.begin(), [](const auto &amp;o1, const auto &amp;o2) {
 return o1 * o2;
 });
 copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
</blockquote>
<pre><code class="lang-cpp"> 1 4 24 60
</code></pre>
<h3>Compute cumulative inner product of range</h3>
<ul>
<li>使用 <code>inner_product()</code></li>
</ul>
<pre><code class="lang-cpp">  int init = 100;
  vector&lt;int&gt; a = {10, 20, 30};
  vector&lt;int&gt; b = {1, 2, 3};
  int ret = inner_product(a.begin(), a.end(), b.begin(), init);
  cout &lt;&lt; ret;
</code></pre>
<pre><code class="lang-cpp">240
</code></pre>
<blockquote><p>n.b. 使用 <code>inner_product()</code> 時需要保證 <code>矢量a</code>和 <code>矢量b</code>的 <code>長度相等</code>。</p>
<blockquote><p>在 <code>兩個矢量的長度不等的情況下</code>，STL仍然會取 <code>較長的矢量</code>進行運算， 而<code>較短的矢量</code>的 <code>越界值</code>將是 <code>不可預測的</code></p>
</blockquote>
<p>可以使用 <code>帶謂詞版本的 inner_product()</code>來模擬 <code>inner_product()</code></p>
<pre><code class="lang-cpp"> int init = 100;
 vector&lt;int&gt; a = {10, 20, 30};
 vector&lt;int&gt; b = {1, 2, 3};
 int ret = inner_product(a.begin(), a.end(), b.begin(), init, [](const auto &amp;o1, const auto &amp;o2) {
  return o1 + o2;
 }, [](const auto &amp;o1, const auto &amp;o2) {
    return o1 * o2;
 });
</code></pre>
</blockquote>
<pre><code class="lang-cpp"> 240
</code></pre>
<h3>Compute partial sums of range</h3>
<ul>
<li>使用 <code>partial_sum()</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; a = {1, 2, 3, 4, 5};
  partial_sum(a.begin(), a.end(), a.begin());
  copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">1 3 6 10 15
</code></pre>
<blockquote><p>同理，使用帶二元謂詞的版本，我們可以實現：<code>部分差</code>，<code>部分乘</code>，<code>部分商</code></p>
</blockquote>
<h3>Store increasing sequence</h3>
<ul>
<li>使用 <code>iota()</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; v(10);
  iota(v.begin(), v.end(), 3);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">3 4 5 6 7 8 9 10 11 12
</code></pre>
<blockquote><p><code>iota()</code>底層使用 <code>operator++ 運算符</code>來實現 <code>遞增</code></p>
</blockquote>
<h3>Function Object</h3>
<h4>Base Classes</h4>
<p><code>函數對象</code>即利用 <code>結構體/對象</code>的 <code>operator()</code>運算符重載，完成類似 <code>普通函數</code>的 <code>函數調用</code>。</p>
<ul>
<li><code>unary_function()</code></li>
</ul>
<pre><code class="lang-cpp">struct IsOdd {
    bool operator() (int number) {
      return number % 2 != 0;
    }
};

int main() {
  IsOdd function_object;
  cout &lt;&lt; function_object(3) &lt;&lt; endl;
  cout &lt;&lt; function_object(2);
  return 0;
}
</code></pre>
<pre><code class="lang-cpp">1
0
</code></pre>
<blockquote><p>本質上來說，<code>函數對象</code>就是一個 <code>結構體</code>。</p>
<pre><code class="lang-cpp"> struct IsOdd {
    bool operator() (int number) {
      return number % 2 != 0;
    }
 } function_object;
</code></pre>
</blockquote>
<ul>
<li><code>binary_function()</code></li>
</ul>
<pre><code class="lang-cpp">int main() {
  struct Add {
      int operator() (int o1, int o2) {
        return o1 + o2;
      }
  } function_object;
  cout &lt;&lt; function_object(1, 2) &lt;&lt; endl;
  return 0;
}
</code></pre>
<pre><code class="lang-cpp">3
</code></pre>
<blockquote><p><code>函數對象</code>一般用於 <code>predicate function</code>和 <code>comparison function</code>。</p>
<p>在大部分的場景下，可以用 <code>lambda表達式</code> 代替 <code>函數對象</code> 作為 <code>callable</code>。</p>
</blockquote>
<h4>Operator Classes</h4>
<h5>Arithmetic Operation</h5>
<ul>
<li><p><code>plus</code></p>
<pre><code class="lang-cpp">  int main() {
    plus&lt;int&gt; function_object;
    cout &lt;&lt; function_object(1,2);
    return 0;
  }
</code></pre>
<pre><code class="lang-cpp">  3
</code></pre>
</li>
<li><code>minus</code></li>
<li><code>multiplies</code></li>
<li><code>divides</code></li>
<li><code>modulus</code></li>
<li><code>negate</code></li>
</ul>
<blockquote><p>上述 <code>算術操作函數對象</code>可以非常方便地用於 <code>transform()</code></p>
</blockquote>
<h5>Comparison Operation</h5>
<ul>
<li><code>equal_to</code></li>
<li><code>not_equal_to</code></li>
<li><code>greater</code></li>
<li><code>less</code></li>
<li><code>greater_equal</code></li>
<li><code>less_equal</code></li>
</ul>
<blockquote><p><code>greater</code>和 <code>less</code>經常用於 <code>UDT</code>的 <code>優先隊列</code>定義。</p>
<p><code>比較器函數</code>的 <code>基本用法</code>可以依據 <code>傳入參數</code>來進行 <code>測試</code>。</p>
<p>但我們也可以 <code>綁定某個 參數</code>為 <code>常數</code>。</p>
<pre><code class="lang-cpp"> vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
 int cnt = count_if(v.begin(), v.end(), bind2nd(greater&lt;int&gt;(), 3));
 cout &lt;&lt; cnt;
</code></pre>
</blockquote>
<pre><code class="lang-cpp"> 6
</code></pre>
<h5>Logical Operations</h5>
<ul>
<li><code>logical_and</code></li>
<li><code>logical_or</code></li>
<li><code>logical_not</code></li>
</ul>
<h5>Adaptor and Conversion Functions</h5>
<h6>Negators</h6>
<ul>
<li><p><code>not1</code></p>
<pre><code class="lang-cpp">  struct IsOdd {
      bool operator()(const int &amp;x) const { return x % 2 != 0; }
      typedef int argument_type;
  };

  int main() {
    vector&lt;int&gt; v = {0, 2, 4, 6, 5};
    int cnt = count_if(v.begin(), v.end(), not1(IsOdd()));
    cout &lt;&lt; cnt;
    return 0;
  }
</code></pre>
<pre><code class="lang-cpp">  4
</code></pre>
</li>
<li><p><code>not2</code></p>
</li>
</ul>
<blockquote><p><code>not1</code> 和 <code>not2</code> 可以對 <code>現有的謂詞</code>進行 <code>取反</code>。</p>
<p>但他們僅支持 <code>函數對象</code>，並不適用於 <code>lambda表達式</code></p>
<blockquote><p><code>not1</code> 和 <code>not2</code> 實質上是 <code>基於結構體模板的</code>，而 <code>lambda</code>本質上屬於 <code>函數</code>而不是 <code>結構體</code></p>
</blockquote>
<p>在用 <code>not1</code>和 <code>not2</code>進行 <code>取反</code>時還必須要求定義 <code>typedef int argument_type</code>，而且對於 <code>運算符函數</code>必須用 <code>const</code>作修飾。</p>
<p>使用並不方便。</p>
</blockquote>
<h6>Parameter Binders</h6>
<ul>
<li><code>bind1st()</code></li>
<li><code>bind2nd()</code></li>
</ul>
<blockquote><p><code>bind1st()</code> 和 <code>bind2nd()</code> 適用於 <code>操作類的函數對象</code>。</p>
<p>一般與 <code>Comparison Functions</code>搭配使用。</p>
</blockquote>
<h6>Conversors</h6>
<ul>
<li><code>ptr_fun()</code>：</li>
<li><p><code>mem_fun()</code>：</p>
<pre><code class="lang-cpp">    vector &lt;string*&gt; numbers;
    numbers.push_back ( new string ("one") );
    numbers.push_back ( new string ("two") );
    numbers.push_back ( new string ("three") );
    numbers.push_back ( new string ("four") );
    numbers.push_back ( new string ("five") );

    vector &lt;int&gt; lengths ( numbers.size() );
    transform (numbers.begin(), numbers.end(), lengths.begin(), mem_fun(&amp;string::length));

    for (int i=0; i&lt;5; i++) {
      cout &lt;&lt; *numbers[i] &lt;&lt; " has " &lt;&lt; lengths[i] &lt;&lt; " letters.\n";
    }
</code></pre>
<pre><code class="lang-cpp">one has 3 letters.
two has 3 letters.
three has 5 letters.
four has 4 letters.
five has 4 letters.
</code></pre>
</li>
<li><p><code>mem_fun_ref()</code>：</p>
<pre><code class="lang-cpp">   vector&lt;string&gt; numbers;
   numbers.push_back("one");
   numbers.push_back("two");
   numbers.push_back("three");
   numbers.push_back("four");
   numbers.push_back("five");

   vector&lt;int&gt; lengths(numbers.size());
   transform(numbers.begin(), numbers.end(), lengths.begin(), mem_fun_ref(&amp;string::length));

   for (int i = 0; i &lt; 5; i++) {
     cout &lt;&lt; numbers[i] &lt;&lt; " has " &lt;&lt; lengths[i] &lt;&lt; " letters.\n";
   }
</code></pre>
<pre><code class="lang-cpp">one has 3 letters.
two has 3 letters.
three has 5 letters.
four has 4 letters.
five has 4 letters.
</code></pre>
</li>
</ul>
<blockquote><p><code>mem_fun()</code> 和 <code>mem_fun_ref()</code> 可以在 <code>流操作</code>時將 <code>成員函數</code> 轉化為 <code>函數對象</code>，可以用於 <code>調用對象的getter函數</code>。
<code>mem_fun()</code>：適用於 <code>指針版本</code>，如 <code>容器的元素</code> 是 <code>指針類型</code>
<code>mem_fun_ref()</code>：適用於 <code>引用版本</code>，如 <code>容器的元素</code> 是 <code>引用類型</code></p>
</blockquote>
<h4>Instrumental Types</h4>
<ul>
<li><code>unary_negate()</code> 和 <code>binary_negate()</code>：和 <code>not1()</code> 和 <code>not2()</code> 一樣 <code>雞肋</code></li>
<li><p><code>binder1st()</code>和 <code>binder2nd()</code>：有點像 <code>編譯版的bind1st()</code>和 <code>編譯版的bind2nd()</code></p>
<pre><code class="lang-cpp">    binder1st&lt;greater&lt;int&gt;&gt; greater_than_10(greater&lt;int&gt;(), 10);
</code></pre>
</li>
<li><p><code>pointer_to_unary_function()</code> 和 <code>pointer_to_binary_function()</code></p>
</li>
<li><code>mem_fun_t()</code> ， <code>mem_fun1_t()</code>，<code>const_mem_fun_t()</code>，<code>const_mem_fun1_t()</code>，<code>mem_fun_ref_t()</code>，<code>mem_fun1_ref_t()</code>，<code>const_mem_fun_ref_t()</code>，<code>const_mem_fun1_ref_t()</code></li>
</ul>
<h3>Initializer List</h3>
<p><code>initializer_list</code> 是一種 <code>數據類型</code>，存儲 <code>某種類型的元素</code>的 <code>列表</code>。</p>
<pre><code class="lang-cpp">  auto a = {10,20,30};
  copy(a.begin(),a.end(),ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">10 20 30
</code></pre>
<h3>Vector</h3>
<p>數據結構 <code>矢量</code>，提供和 <code>數組</code>等效的功能。</p>
<h4>Constructor &amp; Destructor</h4>
<h5>Constructor</h5>
<ul>
<li><code>empty container constructor</code></li>
<li><code>initializer list constructor</code></li>
<li><code>fill constructor</code>: k elements with specific value</li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; v(10, 3);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">3 3 3 3 3 3 3 3 3 3
</code></pre>
<ul>
<li><code>range constructor</code> copy from <code>ierator</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; src = {0,1,2,3};
  vector&lt;int&gt; v(src.begin() + 1, src.end());
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">1 2 3
</code></pre>
<ul>
<li><code>copy constructor (and copying with allocator)</code>: copy from <code>another vector</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; src = {0,1,2,3};
  vector&lt;int&gt; v(src);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">0 1 2 3
</code></pre>
<blockquote><p>以下兩種寫法都是調用 <code>拷貝構造函數</code>。</p>
<blockquote><p><code>operator=</code> 賦值運算符 等價於 <code>copy constructor</code></p>
<pre><code class="lang-cpp"> vector&lt;int&gt; a;
 vector&lt;int&gt; b(a);
 vector&lt;int&gt; b = a;
</code></pre>
</blockquote>
</blockquote>
<ul>
<li><code>move constructor (and moving with allocator)</code></li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; a = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  vector&lt;int&gt; b(a, a.get_allocator());

  cout &lt;&lt; "a: ";
  copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, " "));
  cout &lt;&lt; endl;
  cout &lt;&lt; "b: ";
  copy(b.begin(), b.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">a: 0 1 2 3 4 5 6 7 8 9
b: 0 1 2 3 4 5 6 7 8 9
</code></pre>
<h5>Destructor</h5>
<p><code>vector</code>會 <code>自動地</code> 釋放 <code>元素所使用的內存</code></p>
<h4>Iterators</h4>
<ul>
<li><code>begin()</code> and <code>end()</code></li>
<li><code>rbegin()</code> and <code>rend()</code></li>
<li><code>cbegin()</code> and <code>cend()</code></li>
<li><code>crbegin()</code> and <code>crend()</code></li>
</ul>
<h4>Capacity</h4>
<ul>
<li><p><code>size()</code></p>
<blockquote><p><code>size</code>信息是作為 <code>vector的屬性</code>而存在的。
可在 <code>常數時間</code>內獲取到。</p>
<blockquote><p>但 <code>strlen()</code>不是，對於 <code>大字符串</code>，不要頻繁地調用 <code>strlen()</code></p>
</blockquote>
</blockquote>
</li>
<li><p><code>resize()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {0,1,2};
    v.resize(5);
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  0 1 2 0 0
</code></pre>
</li>
<li><p><code>empty()</code></p>
</li>
<li><p><code>capacity()</code>：獲取 <code>vector的底層數組</code>的 <code>大小</code></p>
</li>
<li><p><code>reserve()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {0,1,2};
    printf("before reserve: capacity = %d\n", v.capacity());
    v.reserve(10);
    printf("after reserve: capacity = %d\n", v.capacity());
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  before reserve: 3
  after reserve: 10
  0 1 2
</code></pre>
<blockquote><p>如果 <code>事先知道</code>需要添加的 <code>元素的數量</code>，則可以先用 <code>reserve()</code>來 <code>一次性</code>完成 <code>預分配</code>。</p>
<blockquote><p><code>reserve(int n)</code> 只 <code>保證</code> <code>vector的底層數組</code>的 <code>大小</code>足夠滿足 <code>n元素</code>，如果 <code>vector的底層數組</code>已經大於n，則該語句會被簡單地忽略。</p>
</blockquote>
<p>如果沒有使用 <code>reserve()</code>，則在插入 <code>大量元素</code>時，<code>vector的底層數組</code>可能會經歷 <code>多次的動態擴容</code>，浪費不必要的資源。</p>
</blockquote>
</li>
<li><p><code>shrink_to_fit()</code>：<code>動態縮容</code>使得 <code>capacity = size</code></p>
</li>
</ul>
<h4>Element Access</h4>
<ul>
<li><p>Return <code>reference</code></p>
<ul>
<li><code>operator []</code>，<code>at()</code></li>
<li><p><code>front()</code> ，<code>back()</code></p>
<blockquote><p>盡管這些 <code>access function</code>返回的確實是 <code>引用</code>，</p>
<p>但還需要註意 <code>隱含的值拷貝</code>。</p>
<p>如果真的希望 <code>取到vector的元素的引用</code>，並且讓 <code>數據修改</code>反映到 <code>vector內部的元素</code>中，需要設置 <code>refenence LHS</code>以避免 <code>值拷貝</code></p>
<ul>
<li><code>value copy</code></li>
</ul>
<pre><code class="lang-cpp"> vector&lt;int&gt; v = {0,1,2};
 int num = v[0];
 num = 43;
 copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
</blockquote>
<pre><code class="lang-cpp">0 1 2
</code></pre>
<ul>
<li><code>reference copy</code></li>
</ul>
<pre><code class="lang-cpp"> vector&lt;int&gt; v = {0,1,2};
 int &amp; num = v[0];
 num = 43;
 copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">43 1 2
</code></pre>
</li>
</ul>
</li>
<li><p>Return <code>reference</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {0, 1, 2};
    int *num = v.data();
    copy(num, num + 3, ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  0 1 2
</code></pre>
<blockquote><p><code>data()</code>返回的是 <code>vector的底層數組</code></p>
</blockquote>
</li>
</ul>
<h4>Modifiers</h4>
<ul>
<li><code>assign</code>：assign n elements with specific values</li>
</ul>
<pre><code class="lang-cpp">  vector&lt;int&gt; v(10);
  v.assign(3, 5);
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">5 5 5
</code></pre>
<blockquote><p>n.b. <code>assign</code> 相當於 <code>重新初始化</code>vector，<code>vector中舊的數據</code>會被 <code>刪除</code>！</p>
</blockquote>
<ul>
<li><p><code>push_back()</code> and <code>pop_back()</code></p>
</li>
<li><p><code>insert()</code> and <code>erase()</code></p>
<ul>
<li><p><code>insert()</code></p>
<pre><code class="lang-cpp">vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
v.insert(v.begin() + 1, 3, 9999);
copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">0 9999 9999 9999 1 2 3 4 5 6 7 8 9
</code></pre>
<blockquote><p>n.b. <code>insert</code>的 <code>position</code>的 <code>語義</code>是：<code>欲插入元素</code> 將插入在 <code>該position的元素之前</code>。</p>
<p>或者等價地說：<code>欲插入元素</code>在 <code>插入後</code> 應該 <code>位於position的位置</code></p>
</blockquote>
</li>
<li><p><code>erase()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    v.erase(v.begin() + 1);
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  0 2 3 4 5 6 7 8 9
</code></pre>
</li>
</ul>
</li>
<li><p><code>clear()</code></p>
</li>
<li><p><code>swap()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; a(3, 100);
    vector&lt;int&gt; b(5, 200);

    a.swap(b);
    int &amp; the_value_from_a = a[0];
    the_value_from_a = 9999;

    copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
    copy(b.begin(), b.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  9999 200 200 200 200
  100 100 100
</code></pre>
<blockquote><p><code>swap()</code>原理是直接 <code>交換</code> 兩個 <code>vector的底層數組的指針</code></p>
</blockquote>
</li>
<li><p><code>emplace()</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    v.emplace(v.begin() + 1, 9999);
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  0 9999 1 2 3 4 5 6 7 8 9
</code></pre>
<blockquote><p>相比於 <code>insert()</code>，<code>push_front()</code> 和 <code>push_back()</code> 將 <code>構造好的元素</code> 傳遞給 <code>Modifier</code>。</p>
<p><code>emplace()</code>並不傳遞 <code>已經構造好的元素</code>，而是傳遞 <code>用於構造這個元素的參數列表</code>：這樣做有利於 <code>減少不必要的元素值拷貝</code>，而 <code>直接在vector的底層數組</code>上 <code>構造元素</code>。</p>
<p><code>emplace_back()</code> 同理。</p>
<pre><code class="lang-cpp">   vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   v.emplace_back(9999);
   copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
</blockquote>
<pre><code class="lang-cpp">   0 1 2 3 4 5 6 7 8 9 9999
</code></pre>
</li>
</ul>
<h4><code>vector&lt;bool&gt;</code></h4>
<ul>
<li><code>vector&lt;bool&gt;</code> 是 <code>vector</code>的 <code>模板特例化</code>，它和 <code>generic vector template</code>相比，有以下特點：</li>
<li><code>vector&lt;bool&gt;</code>的 <code>底層存儲</code>並不一定是用 <code>bool[]</code>的。<code>library</code>可能選擇 <code>其他底層存儲方式</code>，並且盡可能地保證 <code>僅使用1位來表示真值</code></li>
<li>不同於 <code>常規的vector</code>使用 <code>allocator</code> <code>分配對象</code>， <code>vector&lt;bool&gt;</code>的 <code>位數據</code>可以被 <code>直接地設置</code>在 <code>內部存儲</code></li>
<li>多出一個 <code>flip()</code> 翻轉函數</li>
<li><code>vector&lt;bool&gt;</code> 的 <code>accesstor</code>返回的是 用於指向單個為的 <code>reference類型</code> 而不是 <code>bool類型</code></li>
</ul>
<blockquote><p>也就是說，使用 <code>vector&lt;bool&gt;</code> 並不會比 <code>bitset&lt;&gt;</code> 占用 <code>更多空間</code>或 <code>更多時間</code>。
在正常情況下，無法創建 <code>真正的泛化的 vector&lt;bool&gt;</code>，而取而代之的是 <code>特例化的 vector&lt;bool&gt;</code></p>
</blockquote>
<h3>list</h3>
<p>STL中的 <code>list</code> 是 <code>doubly_linked_list</code></p>
<p>如果需要 <code>singly_linked_list</code> 則需要使用 <code>forward_list</code>。</p>
<blockquote><p>n.b. <code>forward_list</code>的 <code>性能</code> 幾乎和 <code>Handwritten C-style singly-linked-list</code>沒有差別！</p>
<blockquote><p><code>forward_list</code>為了 <code>性能</code>甚至沒有 <code>size()</code>。</p>
</blockquote>
</blockquote>
<h4>Operations</h4>
<ul>
<li><p><code>splice()</code></p>
<pre><code class="lang-cpp">    list&lt;int&gt; list1 = {0, 1, 2};
    list&lt;int&gt; list2 = {100, 200, 300};
    list1.splice(list1.begin(), list2);

    cout &lt;&lt; "list1: ";
    copy(list1.begin(), list1.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl &lt;&lt; "list2: ";
    copy(list2.begin(), list2.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  list1: 100 200 300 0 1 2
  list2:
</code></pre>
<blockquote><p><code>splice()</code> 可以 <code>非常方便</code>地對 <code>2個鏈表</code>進行 <code>銜接操作</code>。</p>
</blockquote>
</li>
<li><p><code>remove()</code></p>
<pre><code class="lang-cpp">    list&lt;int&gt; list1 = {0, 1, 2, 3, 4, 2, 2, 2};
    list1.remove(2);
    copy(list1.begin(), list1.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">  0 1 3 4
</code></pre>
<blockquote><p>n.b. <code>remove()</code>的 <code>語義</code>是 <code>移除所有的符合條件的相等元素</code>，而不是 <code>移除第一個符合條件的相等元素</code></p>
<blockquote><p>帶謂詞的版本 <code>remove_if()</code></p>
</blockquote>
</blockquote>
</li>
<li><p><code>unique()</code> and <code>merge()</code></p>
<blockquote><p>n.b. <code>unique()</code>的 <code>語義</code> 和之前所提到的 <code>std::unique()</code>是相同的，都是指 <code>remove consecutive equivalent elements</code>，如果需要確保 <code>移除整個容器中的相等元素</code>，需要進行預處理 <code>sort()</code></p>
</blockquote>
</li>
</ul>
<h3>Array</h3>
<p>STL的<code>array</code>數據結構僅僅是 <code>ordinary array</code> 的 <code>包裝類</code>。</p>
<pre><code class="lang-cpp">  array&lt;int, 10&gt; num = {0,1,2,3};
  copy(num.begin(), num.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
<pre><code class="lang-cpp">0 1 2 3 0 0 0 0 0 0
</code></pre>
<blockquote><p><code>array</code>提供了比 <code>ordinal array</code>更加方便的 <code>輔助函數</code>，但又沒有 <code>vector</code>的 <code>復雜性</code>。</p>
<p>如果你期望保持 <code>ordinal array</code>的眾多 <code>特性</code>，同時不期望使用 <code>auto extendend/extracted</code></p>
<pre><code class="lang-cpp"> array&lt;int, 10&gt; num = {0, 1, 2, 3};
 num.fill(100);
 printf("size = %d\n", num.size());
 copy(num.begin(), num.end(), ostream_iterator&lt;int&gt;(cout, " "));
</code></pre>
</blockquote>
<pre><code class="lang-cpp"> size = 10
 100 100 100 100 100 100 100 100 100 100
</code></pre>
<ul>
<li><p><code>size()</code></p>
<p>傳統的<code>C-Style數組</code>在 <code>參數傳遞</code>時比較麻煩，但使用 <code>array</code>可以避免這個問題。</p>
</li>
<li><p><code>iterator</code></p>
<p><code>array</code>可以使用 <code>iterator對象</code>，與其他STL函數的配合編碼更加方便。</p>
<blockquote><p>另外，<code>array</code>繼承了 <code>ordinary</code>的 <code>傳統特性</code>：允許 <code>下標越界</code>。
```cpp
array&lt;int, 10&gt; arr;</p>
</blockquote>
<p>for (int i = -10; i &lt; 20; ++i) {
cout &lt;&lt; arr[i] &lt;&lt; " ";
}</p>
<pre><code>
```cpp
4199804 0 6422000 0 -6 -1 0 0 0 0 8 0 4199705 0 8 0 75 0 8224624 0 16 11 8224592 0 4199367 0 0 0 75 0
</code></pre>
</li>
<li><p><code>fill()</code></p>
<p><code>array</code>在 <code>完全兼容</code> <code>ordinal array</code>的所有 <code>初始化方法</code>之外，</p>
<p>還提供了一個非常有用的函數：<code>fill()</code></p>
<blockquote><p>對於 <code>ordinal array</code>，我們可以使用 <code>memset()</code>。</p>
<p>但遺憾的是，該函數只適用於填充 <code>0</code>和 <code>-1</code></p>
</blockquote>
<pre><code class="lang-cpp">array&lt;array&lt;int, 10&gt;, 3&gt; num;
num.fill(array&lt;int, 10&gt;{100,200,300});
for (int i = 0; i &lt; num.size(); ++i) {
  for (int j = 0; j &lt; num[i].size(); ++j) {
    cout &lt;&lt; num[i][j] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
}
</code></pre>
<pre><code class="lang-cpp[">100 200 300 0 0 0 0 0 0 0
100 200 300 0 0 0 0 0 0 0
100 200 300 0 0 0 0 0 0 0
</code></pre>
</li>
</ul>
<h3>deque</h3>
<p>STL的 <code>deque</code> 即 <code>doubly linked list</code>。</p>
<p>此外，STL的 <code>stack</code>和 <code>queue</code> 均是基於 <code>deque</code>實現的</p>
<h3>priority_queue</h3>
<p>不同於Java的 <code>PriorityQueue</code>，C++的STL的 <code>priority_queue</code>默認是 <code>大頂堆</code>。</p>
<pre><code class="lang-cpp">template &lt;class T, class Container = vector&lt;T&gt;,
  class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue;
</code></pre>
<blockquote><p><code>priority_queue</code> 底層使用的是 <code>heap functions</code>。</p>
<p><code>data source</code>可以來自 <code>多種類型的容器</code>，只需要通過 <code>range constructor</code>來構造 <code>priority_queue</code>即可。</p>
</blockquote>
<ul>
<li><p><code>max-imum heap</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; a = {1, 5, 2, 8, 3, 6, 4};
    priority_queue&lt;int&gt; PQ(a.begin(), a.end());

    while (!PQ.empty()) {
      cout &lt;&lt; PQ.top() &lt;&lt; " ";
      PQ.pop();
    }
</code></pre>
<pre><code class="lang-cpp">  8 6 5 4 3 2 1
</code></pre>
</li>
<li><p><code>min-imum heap</code></p>
<pre><code class="lang-cpp">    vector&lt;int&gt; a = {1, 5, 2, 8, 3, 6, 4};
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; PQ(a.begin(), a.end());

    while (!PQ.empty()) {
      cout &lt;&lt; PQ.top() &lt;&lt; " ";
      PQ.pop();
    }
</code></pre>
<pre><code class="lang-cpp">  1 2 3 4 5 6 8
</code></pre>
<blockquote><p>同理，也可以使用 <code>custom comparison function</code>
  ```cpp
  vector&lt;int&gt; a = {1, 5, 2, 8, 3, 6, 4};
  struct comp {
     bool operator()(const int &amp;o1, const int &amp;o2) {
       return o1 &gt; o2;
     }
  };
  priority_queue&lt;int, vector&lt;int&gt;, comp&gt; PQ(a.begin(), a.end());</p>
</blockquote>
<p>while (!PQ.empty()) {
   cout &lt;&lt; PQ.top() &lt;&lt; " ";
   PQ.pop();
  }</p>
<pre><code>
  ```cpp
  1 2 3 4 5 6 8
</code></pre>
</li>
</ul>
<h3>Map</h3>
<p><code>map</code>中的 <code>條目 (entry)</code>類型為</p>
<pre><code class="lang-cpp">typedef pair&lt;const Key, T&gt; value_type;
</code></pre>
<h4>map</h4>
<p>STL中的 <code>map</code>底層數據結構是基於 <code>Red-Black Tree</code> 的，通過 <code>operator &lt;</code>來完成 <code>比較</code>。</p>
<p>而且，可以直接對 <code>map</code>進行 <code>叠代</code>來得出 <code>已排序的key序列</code></p>
<ul>
<li><p><code>operator[]</code></p>
<ul>
<li>如果key已存在，則返回 map[key]</li>
<li><p>如果key不存在，則等價於：(*((this-&gt;insert(make_pair(k,mapped_type()))).first)).second</p>
<blockquote><p>如果使用 <code>at()</code>，則會在 <code>key不存在時</code>，拋出 <code>異常</code></p>
</blockquote>
<pre><code class="lang-cpp">map&lt;int, string&gt; m;
m[1] = "first";
m[2] = "second";
m[3] = "third";
m[4] = "four";
printf("size = %d\n", m.size());
m[5];
printf("size = %d, value = %s\n", m.size(), m[5].c_str());
m[100000000];
printf("size = %d, value = %s\n", m.size(), m[100000000].c_str());
</code></pre>
<pre><code class="lang-cpp">size = 4
size = 5, value =
size = 6, value =
</code></pre>
<p>n.b. 無論何時，對 <code>map</code>使用 <code>operator[]</code> 至多只會使得 <code>size</code> <code>增1</code></p>
<p>n.b. 當 <code>訪問map中不存在的key時</code>，會自動 <code>創建並插入pair (按默認值創建value)</code></p>
<p>如果 <code>value的類型</code>是 <code>UDT</code>，則需要提供 <code>no parameter constructor</code>，否則無法通過編譯。
如下面的例子，將 <code>編譯失敗</code>：</p>
<p>```cpp
class Person {
public:
string name;</p>
<p>public:
Person(const string &amp;name) : name(name) {}
};</p>
</li>
</ul>
</li>
</ul>
<pre><code>int main() {

map&lt;int, Person&gt; m;
m[0];
printf("size = %d, value = %s\n", m.size(), m[0].name.c_str());

return 0;
}
```

```cpp
main.cpp:42:7: note: candidate: 'Person::Person(Person&amp;&amp;)'
main.cpp:42:7: note:   candidate expects 1 argument, 0 provided
```
</code></pre>
<ul>
<li>iterator</li>
</ul>
<pre><code class="lang-cpp">  map&lt;int, string&gt; m;
  m[2] = "second";
  m[1] = "first";
  m[3] = "third";
  m[4] = "four";

  for (auto iter = m.begin(); iter != m.end(); iter++) {
    cout &lt;&lt; iter-&gt;first &lt;&lt; ", " &lt;&lt; iter-&gt;second &lt;&lt; endl;
  }
  return 0;
</code></pre>
<pre><code class="lang-cpp">1, first
2, second
3, third
4, four
</code></pre>
<blockquote><p>由於 <code>map</code>底層使用的是 <code>red black tree</code>，所以可以利用 <code>map</code>來進行 <code>排序</code></p>
</blockquote>
<ul>
<li><code>insert()</code>：通常來說可以使用 <code>operator[]</code> 代替</li>
<li><code>erase()</code></li>
</ul>
<pre><code class="lang-cpp">  map&lt;int, string&gt; m;
  m[2] = "second";
  m[1] = "first";
  m[3] = "third";
  m[4] = "four";

  m.erase(2);
  m.erase(5);

  for (auto iter = m.begin(); iter != m.end(); iter++) {
    cout &lt;&lt; iter-&gt;first &lt;&lt; ", " &lt;&lt; iter-&gt;second &lt;&lt; endl;
  }
</code></pre>
<pre><code class="lang-cpp">1, first
3, third
4, four
</code></pre>
<blockquote><p>n.b. 如果 <code>欲刪除的key</code>不存在，則 <code>無事發生</code></p>
</blockquote>
<ul>
<li><code>find()</code>：get <code>iterator</code> to element</li>
</ul>
<pre><code class="lang-cpp">  map&lt;int, string&gt; m;
  m[2] = "second";
  m[1] = "first";
  m[3] = "third";
  m[4] = "four";

  auto iter = m.find(5);
  printf(iter == m.end() ? "not found" : "found");
  printf("\nsize = %d", m.size());
</code></pre>
<pre><code class="lang-cpp">not found
size = 4
</code></pre>
<blockquote><p>相比於 <code>operator[]</code>在 <code>未找到元素時</code>會 <code>自動插入默認對</code>而言，使用 <code>find()</code>來 <code>判斷元素是否存在</code>可以避免 <code>浪費空間</code>。</p>
<p>而且更重要的，<code>find()</code>是 <code>冪等的</code></p>
</blockquote>
<ul>
<li><p><code>count()</code>：count elements with a specific key</p>
<blockquote><p>n.b. 如果僅僅是為了判斷 <code>是否存在某個key</code>，那麽相比於 <code>find()</code>寫法的麻煩，我們可以用 <code>count() == 0</code>來代替 <code>find()</code></p>
</blockquote>
</li>
</ul>
<h4>miltimap</h4>
<p>與 <code>map</code> 的區別在於， <code>miltimap</code>支持 <code>不同pair有重復的key</code>。</p>
<ul>
<li><p><code>erase()</code></p>
<blockquote><p>對於 <code>傳值的erase()</code>，將 <code>刪除所有符合條件的元素</code>。</p>
</blockquote>
</li>
</ul>
<h3>Set</h3>
<h4>set</h4>
<p>STL的 <code>set</code> 是基於 <code>red-black tree</code>的，此外，它的 <code>元素</code>必須是 <code>const</code>的，只能 <code>插入元素</code>或 <code>刪除元素</code>，而不能 <code>修改元素</code>。</p>
<pre><code class="lang-cpp">  set&lt;int&gt; S;
  S.insert(1);
  S.insert(2);
  S.insert(2);
  S.insert(3);
  S.insert(4);

  printf("size = %d\n", S.size());
  printf("count(2) = %d\n", S.count(2));
</code></pre>
<pre><code class="lang-cpp">size = 4
count(2) = 1
</code></pre>
<blockquote><p>n.b. 對於 <code>set</code>來說，如果 <code>欲插入的元素</code>已存在，則會忽略後續的插入（而不是 <code>覆蓋插入</code>）。</p>
</blockquote>
<h4>multiset</h4>
<h3>unordered_map</h3>
<h4>unordered_map</h4>
<p><code>unordered_map</code> 基於 <code>bucket</code>而非 <code>red-black tree</code>，通過 <code>hash function</code>來 <code>索引</code> 指定的 <code>key</code>。</p>
<blockquote><p>因此，<code>unordered_map</code> 中的 <code>key</code> 是 <code>無序的</code></p>
<p>因此，通常比 <code>map</code> 更快</p>
</blockquote>
<ul>
<li><code>Bucket Functions</code></li>
</ul>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>bucket_count()</td>
<td>return number of buckets</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>return maximum number of buckets</td>
</tr>
<tr>
<td>bucket_size()</td>
<td>return bucket size</td>
</tr>
<tr>
<td>bucket()</td>
<td>locate element's bucket</td>
</tr>
</tbody>
</table>
<ul>
<li><code>Hash Policy Functions</code></li>
</ul>
<table>
<thead><tr>
<th>Function</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>load_factor()</td>
<td>return load factor</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>get or set maximum load factor</td>
</tr>
<tr>
<td>rehash()</td>
<td>set number of buckets</td>
</tr>
<tr>
<td>reserve()</td>
<td>request a capacity change</td>
</tr>
</tbody>
</table>
<h4>unordered_multimap</h4>
<h3>unordered_set</h3>
<h4>unordered_set</h4>
<p>與 <code>unordered_map</code>類似，均是基於 <code>bucket</code>的。</p>
<h4>unordered_multiset</h4>
<h3>Compute Remainder and Quotient</h3>
<ul>
<li><code>remainder()</code></li>
</ul>
<h3>Branch</h3>
<ul>
<li><code>setjmp()</code> and <code>longjmp()</code></li>
</ul>
<pre><code class="lang-cpp">  jmp_buf  env;
  printf("before set jump\n");
  int val = setjmp(env);
  printf("after set jump\n");

  printf("val = %d\n", val);

  printf("before longjmp()\n");
  if (!val) longjmp(env, 1);
  printf("after longjmp()\n");
</code></pre>
<pre><code class="lang-cpp">before set jump
after set jump
val = 0
before longjmp()
after set jump
val = 1
before longjmp()
after longjmp()
</code></pre>
<blockquote><p><code>goto</code>只支持 <code>函數內跳轉</code>，但 <code>setjmp() and longjmp()</code>可以支持 <code>跨函數跳轉</code></p>
<p>使用 <code>setjmp()</code>保存 <code>過程調用環境</code>，然後用 <code>longjmp()</code>進行 <code>jump</code>。</p>
</blockquote>
<p>一個跨函數的例子。</p>
<pre><code class="lang-cpp"> int foo();
 int bar();
 jmp_buf env;
 int val;

 int foo() {
   printf("enter foo()\n");

   val = setjmp(env);

   printf("before call bar()\n");
   bar();
   printf("after call bar()\n");

   printf("leave foo()\n");
   return 100;
 }

 int bar() {
   printf("enter bar()\n");


   printf("before longjmp()\n");
   if (val != 1) longjmp(env, 1);
   printf("before longjmp()\n");

   printf("leave bar()\n");
   return 200;
 }


 int main() {
   foo();
   return 0;
 }
</code></pre>
<pre><code class="lang-cpp"> enter foo()
 before call bar()
 enter bar()
 before longjmp()
 before call bar()
 enter bar()
 before longjmp()
 before longjmp()
 leave bar()
 after call bar()
 leave foo()
</code></pre>
<ul>
<li><code>goto</code></li>
</ul>
<pre><code class="lang-cpp">int main() {

  for (int i = 0; i &lt; 100; ++i) {
    for (int j = 0; j &lt; 100; ++j) {

      if (i == 10 &amp;&amp; j == 20) {
        goto ok;
      }

    }
  }

  ok: 0xdead;

  printf("bye\n");
  return 0;
}
</code></pre>
<pre><code>bye
</code></pre>
<p>關於 <code>跳出外層循環</code>，更推薦的寫法是給 <code>外層循環</code>加 <code>控製標記</code></p>
<pre><code class="lang-cpp"> int main() {

   bool flag = true;
   for (int i = 0; flag &amp;&amp; i &lt; 100; ++i) {
     for (int j = 0; j &lt; 100; ++j) {

       // break the outer loop
       if (i == 10 &amp;&amp; j == 20) {
         flag = false;
         break;
       }

     }
   }

   printf("bye\n");
   return 0;
 }
</code></pre>
<h3>The incremental of size_t and size_type</h3>
<pre><code class="lang-cpp">  char c_str[] = "china";
  string cpp_str = "china";

  printf("strlen(c_str) = %d\n", strlen(c_str));
  printf("cpp_str.size() = %d\n", cpp_str.size());

  //
  int c_str_size = strlen(c_str) + 1;
  printf("c_str_size = %d\n", c_str_size);

  int cpp_str_size = cpp_str.size() + 1;
  printf("cpp_str_size = %d\n", cpp_str_size);
</code></pre>
<pre><code class="lang-cpp">strlen(c_str) = 5
cpp_str.size() = 5
c_str_size = 6
cpp_str_size = 6
</code></pre>
<blockquote><p><code>size_t</code>和 <code>size_type</code> 本質上是 <code>unsigned long long</code></p>
<p>在 <code>強製轉化</code> 為 <code>int</code> 時屬於 <code>narrowing conversion</code>。</p>
<p>對他們執行 <code>遞增操作</code>時應使用 <code>遞增操作符</code> 而不是直接 <code>+1</code>。</p>
<blockquote><p>直接 <code>+1</code>的含義為 <code>將unsigned long long 窄化為int，然後加上int型的1</code>。該操作是 <code>未定義的</code>，取決於具體實現。</p>
</blockquote>
</blockquote>
<pre><code class="lang-cpp"> Clang-Tidy: Narrowing conversion from 'unsigned long long' to signed type 'int' is implementation-defined
</code></pre>
<h3>Exit the program</h3>
<ul>
<li>Terminate<ul>
<li><code>abort()</code>：abnormal termination, raises the <code>SIGABRT signal</code>, do not cleanup</li>
<li><code>exit()</code>：normal termination, do cleanup</li>
<li><code>quick_exit()</code>：normal termination, do not cleanup</li>
<li><code>_Exit()</code></li>
</ul>
</li>
<li><p>Terminate</p>
<ul>
<li><p><code>atexit()</code></p>
<pre><code class="lang-cpp">    auto post = [](){
      printf("bye\n");
    };
    atexit(post);

    printf("before return\n");
</code></pre>
<pre><code class="lang-cpp">  before return
  bye
</code></pre>
</li>
</ul>
</li>
</ul>
<pre><code>- `at_quick_exit()`
</code></pre>
<ul>
<li><p>Get system environment</p>
<ul>
<li><p><code>getenv()</code></p>
<pre><code class="lang-cpp">    char * java_home = getenv("JAVA_HOME");
    printf("%s", java_home);
</code></pre>
<pre><code class="lang-cpp">  D:\Program Files (x86)\Java\jdk1.8.0_291
</code></pre>
</li>
</ul>
</li>
<li><p>Execute commands</p>
<ul>
<li><code>system()</code></li>
</ul>
</li>
</ul>
<h3>Time</h3>
<h4>Time Manipulation</h4>
<ul>
<li><code>clock()</code></li>
</ul>
<pre><code class="lang-cpp">int main() {

  for (int i = 0; i &lt; 1000000; ++i) {}

  clock_t t = clock();
  printf("clock ticks since the program launched = %d", t);

  return 0;
}
</code></pre>
<pre><code class="lang-cpp">clock ticks since the program launched = 10
</code></pre>
<blockquote><p><code>clock()</code> 計數的是 <code>從程序啟動以來所經歷的時間刻</code>。</p>
</blockquote>
<pre><code class="lang-cpp">   typedef long clock_t;
</code></pre>
<blockquote><p>如果需要獲取 <code>秒數</code>則要除以 <code>CLOCKS_PER_SECOND</code></p>
</blockquote>
<ul>
<li><code>time()</code></li>
</ul>
<pre><code class="lang-cpp">int main() {

  time_t timer;
  time(&amp;timer);

  printf("timer = %d\n", timer);
  return 0;
}
</code></pre>
<pre><code class="lang-cpp">timer = 1650518640
</code></pre>
<pre><code class="lang-cpp"> __MINGW_EXTENSION typedef __int64 __time64_t;
 typedef __time64_t time_t;
</code></pre>
<blockquote><p><code>time_t</code>本質上是 <code>__int64</code>。</p>
<p>直接使用 <code>__int64</code> 或者 <code>long long</code>也可以被接受。</p>
</blockquote>
<ul>
<li><code>mktime()</code></li>
</ul>
<pre><code class="lang-cpp">int main() {

  /* Get current timestamp &amp; use localtime() to get related struct tm */
  time_t raw_time;
  time(&amp;raw_time);
  struct tm * timeinfo = localtime(&amp;raw_time);

  /* Modify the struct tm &amp; use mktime() to get related timestamp */
  timeinfo-&gt;tm_year = 2022 - 1900;
  timeinfo-&gt;tm_mon = 4 - 1;
  timeinfo-&gt;tm_mday = 21;

  time_t timestamp = mktime(timeinfo);
  printf("timestamp = %d\n", timestamp);
  return 0;
}
</code></pre>
<pre><code class="lang-cpp">timestamp = 1650519507
</code></pre>
<p><code>localtime()</code>：timestamp -&gt; tm
<code>mktime()</code> ：tm -&gt; timestamp</p>
<blockquote><p>對於 <code>struct tm</code>實例，我們不是直接構造，而是通過獲取 <code>當前時間戳</code>，然後轉化得到 <code>當前時間戳所對應的tm</code>，再修改 <code>tm的屬性字段</code>，最後通過 <code>mktime()</code>來獲得 <code>修改後的tm對應的時間戳</code></p>
<p><code>tm_wday</code> 和 <code>tm_yday</code>字段被 <code>忽略</code></p>
<p><code>year</code>從 <code>1900</code>開始，<code>month</code>從 <code>0</code>開始</p>
</blockquote>
<ul>
<li><code>difftime()</code></li>
</ul>
<h4>Conversion</h4>
<ul>
<li><code>asctime()</code>：tm -&gt; string</li>
<li><code>ctime()</code>：timestamp -&gt; string</li>
<li><code>gmtime()</code>：timestamp -&gt; tm(UTC)</li>
<li><code>localtime()</code>：timestamp tm(local)</li>
<li><code>strftime()</code>：format tm -&gt; string</li>
</ul>
<blockquote><p><code>strftime()</code>雖然提供了 <code>格式化tm結構</code>的功能，但 <code>struct tm</code>本身已經包含了足夠的信息，可以非常方便地 <code>自定義格式化函數</code></p>
</blockquote>
<h3>Code Pointer</h3>
<p>除了常規的類型指針外，傳統C語言還有一種指針稱作 <code>代碼指針</code>。</p>
<p>通過對 <code>代碼片段</code>運用 <code>地址運算符</code>可以得到 <code>該代碼片段的地址</code>。</p>
<pre><code class="lang-cpp">int main() {

  s1:
  printf("hi\n");

  printf("address of s1 = %d\n", &amp;&amp; s1);

  void (*foo) (void) = reinterpret_cast&lt;void (*)(void)&gt;(4199857);
  foo();

  return 0;
}
</code></pre>
<pre><code class="lang-cpp">hi
address of s1 = 4199857
hi
address of s1 = 4199857
hi
address of s1 = 4199857
hi
address of s1 = 4199857
hi
address of s1 = 4199857
hi
......
</code></pre>
<h3>Remove Const-Qualified</h3>
<h4><code>const_cast&lt;&gt;()</code></h4>
<pre><code class="lang-cpp">  string str = "abc";
  char *str_data = const_cast&lt;char *&gt;(str.data());
  str_data[0] = 'A';
  cout &lt;&lt; str;
</code></pre>
<pre><code class="lang-cpp">Abc
</code></pre>
