<h2><a href="https://github.com/sakurawald/sakurawald.github.io/blob/master/source/_posts/algorithm-multiple-knapsack-problem-and-pebble-merge-problem.md">仓库源文</a>，<a href="https://sakurawald.github.io/posts/algorithm-multiple-knapsack-problem-and-pebble-merge-problem">站点原文</a></h2>
<hr/>
<p>title: "[Algorithm] Multiple-Knapsack Problem &amp; Pebble Merge Problem"
date: 2022-04-19 07:53:00
tags:</p>
<ul>
<li>algorithm</li>
<li>dynamic_programming</li>
</ul>
<hr/>
<h1>Dynamic Programming Problems</h1>
<p>{% raw %}
$$
\boxed{@}
% Color %
\newcommand\c[2]{\textcolor{#1}{#2}}
\newcommand\r[1]{\textcolor{red}{#1}}
\newcommand\g[1]{\textcolor{green}{#1}}
\newcommand\b[1]{\textcolor{blue}{#1}}
\newcommand\red[1]{\textcolor{red}{#1}}
\newcommand\blue[1]{\textcolor{blue}{#1}}
\newcommand\green[1]{\textcolor{green}{#1}}
\newcommand\black[1]{\textcolor{black}{#1}}
\newcommand\white[1]{\textcolor{white}{#1}}
\newcommand\cyan[1]{\textcolor{cyan}{#1}}
\newcommand\magenta[1]{\textcolor{magenta}{#1}}
\newcommand\yellow[1]{\textcolor{yellow}{#1}}
\newcommand\orange[1]{\textcolor{orange}{#1}}
\newcommand\lime[1]{\textcolor{lime}{#1}}
\newcommand\pink[1]{\textcolor{pink}{#1}}
\newcommand\darkgray[1]{\textcolor{darkgray}{#1}}
\newcommand\gray[1]{\textcolor{gray}{#1}}
\newcommand\lightgray[1]{\textcolor{lightgray}{#1}}
\newcommand\brown[1]{\textcolor{brown}{#1}}
\newcommand\olive[1]{\textcolor{olive}{#1}}
\newcommand\purple[1]{\textcolor{purple}{#1}}
\newcommand\teal[1]{\textcolor{teal}{#1}}
\newcommand\violet[1]{\textcolor{violet}{#1}}
\newcommand\hotpink[1]{\textcolor{hotpink}{#1}}
\newcommand\blueviolet[1]{\textcolor{blueviolet}{#1}}
\newcommand\navyblue[1]{\textcolor{navyblue}{#1}}
\newcommand\peach[1]{\textcolor{Peach}{#1}}
\newcommand\orangeRed[1]{\textcolor{OrangeRed}{#1}}
\newcommand\salmon[1]{\textcolor{Salmon}{#1}}
\newcommand\skyblue[1]{\textcolor{SkyBlue}{#1}}
\newcommand\springreen[1]{\textcolor{SpringGreen}{#1}}
\newcommand\aqua[1]{\textcolor{aqua}{#1}}
\newcommand\navy[1]{\textcolor{navy}{#1}}
\newcommand\silver[1]{\textcolor{silver}{#1}}
\newcommand\fuchsia[1]{\textcolor{fuchsia}{#1}}
\newcommand\maroon[1]{\textcolor{maroon}{#1}}
\definecolor{luo}{RGB}{102,204,255}
\definecolor{miku}{RGB}{57,197,187} 
\newcommand\luo[1]{\textcolor{luo}{#1}}
\newcommand\miku[1]{\textcolor{miku}{#1}}</p>
<p>% Typography %
\newcommand\a[1]{\begin{aligned}#1\end{aligned}}
\newcommand\t[1]{\text{#1}}
\newcommand\lb[1]{\left{\begin{aligned} #1 \end{aligned}\right.}
\newcommand\rb[1]{\left.\begin{aligned} #1 \end{aligned}\right}}
\newcommand\env[2]{\begin{#1}#2\end{#1}}</p>
<p>% Misc %
\newcommand\s[1]{{#1}}
\newcommand\qed{\quad\square}
\newcommand\define{\dot{=}}
\newcommand\then{\implies}
\newcommand\rounddown[1]{\lfloor{#1}\rfloor}
\newcommand\roundup[1]{\lceil{#1}\rceil}
\newcommand\graph[4]{#1 = (#2, #3) \quad |#2| = #4}
\newcommand\G{G = (V, E) \quad |V| = n}
\newcommand\so{\therefore}
\newcommand\comment[1]{\quad\text{(#1)}}
\newcommand\note[1]{\quad\text{(#1)}}
\newcommand\bt[1]{\boxed{\text{#1}}}
\newcommand\max[1]{\textbf{ max } {#1} }
\newcommand\min[1]{\textbf{ min } {#1} }
\newcommand\IF{\textbf{ IF }}
\newcommand\if{\textbf{ if }}
\newcommand\IS{\textbf{ IS }}
\newcommand\is{\textbf{ is }}
\newcommand\but{\textbf{ but }}
\newcommand\however{\textbf{ however }}
\newcommand\AND{\textbf{ AND }}
\newcommand\OR{\textbf{ OR }}
\newcommand\NOT{\textbf{ NOT }}
\newcommand\THEN{\textbf{ THEN }}
\newcommand\IN{\textbf{ IN }}
\newcommand\NOTIN{\textbf{ NOT-IN }}
\newcommand\assume{\textbf{ Assuming that: }}
\newcommand\contradictory{\textbf{ Thus lead to contradiction }}
\newcommand\proof{\textbf{Proof: }}
\newcommand\st{\text{ such that }}
\newcommand\hold{\text{ holds }}
\newcommand\lhs{\text{ LHS }}
\newcommand\rhs{\text{ RHS }}
\newcommand\wlg{\text{ Without loss of generality }}
\newcommand\nb{\text{ nota bene }}
\newcommand\analogously{\text{ analogously }}
\newcommand\viceversa{\textbf{ viceversa }}
\newcommand\let{\textbf{ let }}
\newcommand\as{\textbf{ as }}
\newcommand\for{\textbf{ As for }}
\newcommand\select{\textbf{ SELECT }}
\newcommand\m[1]{\mathit{#1}}
\newcommand+[1]{\mathcal{#1}}
\newcommand\warnning[1]{\colorbox{Blue}{\textcolor{Yellow}{#1}}}
\newcommand\error[1]{\colorbox{Black}{\textcolor{White}{#1}}}
$$</p>
<p>{% endraw %}</p>
<h2>Multiple-Knapsack Problem</h2>
<h3>Description</h3>
<p>设有 n 种不同面值的硬币，各硬币的面值存于数组 T［1:n］中。现要用这些面值的硬
币来找钱。可以使用的各种面值的硬币个数存于数组 Coins［1:n］中。
对任意钱数 0≤m≤20001，设计一个用最少硬币找钱 m 的方法。</p>
<h3>Input</h3>
<p>由文件 input.txt 提供输入数据，文件的第一行中只有 1 个整数给出n 的值,第 2 行起每
行 2 个数，分别是 T[j]和 Coins[j]。最后 1 行是要找的钱数 m。</p>
<h3>Output</h3>
<p>程序运行结束时，将计算出的最少硬币数输出到文件 output.txt 中。问题无解时输出-1。</p>
<h3>Sample</h3>
<p><strong>输入文件示例</strong></p>
<p>input.txt</p>
<p>3
1 3
2 3
5 3
18</p>
<p><strong>输出文件示例</strong></p>
<p>output.txt</p>
<p>5</p>
<h3>Analysis</h3>
<h4>Analyse the Dimensions &amp; Establish the Recursive Equation</h4>
<pre><code class="lang-mermaid">classDiagram
class Knapsack {
 +capacity
}

class Item {
 +value
 +weight
 +amount
}
</code></pre>
<p>首先，分析出题目中的 <code>对象 (Object)</code> 所涉及到的 <code>属性 (Attribute)</code>  有哪些。</p>
<p>我们可以得到：</p>
<ul>
<li><p>与<code>物品 (硬币)</code>有关的属性有<code>面值 (value)</code>和<code>数量 (amount)</code>。</p>
<blockquote><p>实际上，<code>物品</code>还有一个属性为 <code>重量 (weight)</code>。</p>
<p>由于 <code>优化目标</code>为 <code>所需的最少硬币的数量</code>，所以可以将 <code>所有物品的重量</code>均视为 <code>单位重量</code>，</p>
<p>然后 <code>忽略</code> 掉这个属性。</p>
</blockquote>
</li>
<li><p>与<code>背包 (需要凑的零钱)</code>有关的属性有<code>容量 (capacity)</code></p>
</li>
</ul>
<p>所以，我们可以得到3个 <code>数据维度 (Dimension)</code>：<code>硬币的面值</code>，<code>硬币的数量</code>，<code>需要凑的零钱</code>，</p>
<blockquote><p><code>硬币的数量</code> 应该算 <code>2个维度</code>，加起来总共 <code>4个维度</code></p>
</blockquote>
<p>并且，我们可以定义<code>递推关系的值</code>为<code>所需的最少硬币数</code>。</p>
<blockquote><p>这是因为 <code>所需的最少硬币数</code>是 <code>题目所需求的解</code>。</p>
<blockquote><p>一般直接将 <code>递推关系的值</code> 定义为 <code>题目所需要求解的值</code>，然后进行 <code>划分子问题</code>，</p>
<p>这样等到 <code>递推方程的值</code>计算完成，我们就可以 <code>直接</code>得到 <code>问题的解</code>。</p>
</blockquote>
</blockquote>
<hr/>
<p>现在，我们不妨考虑一下，在<code>最终凑齐零钱</code>之前发生了什么？</p>
<p>在<code>最后一步 (The Final Step)</code>  ，我们会将<code>某种面值的硬币</code>放入<code>k枚</code>，然后满足<code>目标容量</code>。</p>
<blockquote><p>n.b. 这里如果认为：<code>最后一步</code> 会将 <code>某种面值的硬币</code> 放入<code>1枚</code> 也可以。</p>
<p>但实际上，<code>某种面值的硬币</code> 可以 <code>一次性</code> 地放入 <code>多枚</code>，并且效果 <code>等价于</code></p>
<p><code>分多次在不同步</code> 放入 <code>该种硬币1枚</code></p>
</blockquote>
<p>因此，我们可以立即得出下面的<code>递推方程</code>。
$$
\boxed{\t{Just take the final step into consideration}} \
dp[capacity][type][amount] = 
\lb{
&amp; dp[capacity \r{- (k * values[type])}][type-1][amount \r{+ k}] + \g{k},&amp;(\t{use coins}) \
&amp; dp[capacity][type-1][amount],&amp;(\t{don't use coins})
}
$$</p>
<hr/>
<h4>Compress the Recursive Equation</h4>
<p>到此，我们已经得到了<code>递推方程</code>，但该方程是<code>4维</code>的，<code>时间复杂度</code> 可能会较大。</p>
<blockquote><p>后面我们会对比 <code>4维解法</code> 和 <code>2维解法</code> 的 <code>性能差异</code>。</p>
<p>当 <code>问题规模</code> 变得 <code>稍微大一些</code> 的时候， <code>4维解法</code> 的 <code>时间复杂度</code> 将无法在 <code>可接受的时间</code> 内完成求解。</p>
</blockquote>
<p>接下来我们可以考虑，能否<code>压缩 (Compress)</code> <code>某些维度</code>来达到<code>降维优化</code>的效果。</p>
<blockquote><p>实际上，该 <code>递推方程</code>的 <code>数量 (amount)</code>维度存有 <code>冗余的信息</code>。</p>
</blockquote>
<hr/>
<p>关于<code>每种硬币的数量限制</code>，不妨考虑：</p>
<p>如果<code>每种硬币</code>都是<code>无限的</code>，那么我们很确信，<code>capacity较大的问题的最优解</code>由<code>capacity较小的问题的最优解</code>来<code>组成</code>。</p>
<blockquote><p>因为<code>每种硬币</code>是 <code>无限的</code>，我们只需要简单地把<code>capacity较小的问题的找零方案</code>进行<code>组合</code>即可。</p>
</blockquote>
<p>但是，如果<code>每种硬币都是有限的</code>，如何知道<code>capacity较大的问题的最优解</code>是否可以 <code>直接</code> 由<code>capacity较小的问题的最优解</code>组合得到，而且 <code>不违反每种硬币的数量限制</code>？</p>
<p>换句话说：如果我们需要<code>凑齐500元</code>，而<code>凑齐500元的最优解</code>由<code>凑齐200元的最优解</code>和<code>凑齐300元的最优解</code>来<code>组合</code>得到。假设，<code>凑齐200元的最优解</code>和<code>凑齐500元的最优解</code>都用到了<code>5元硬币</code>，则我们如何<code>确保所使用的5元硬币的总量符合数量限制</code>？</p>
<p>这个问题其实依赖于我们的<code>计算顺序</code>，<code>凑齐200元的最优解</code>和<code>凑齐300元的最优解</code>并不是<code>独立地被计算出来的</code>。</p>
<p>我们会在<code>凑齐200元的最优解</code>的 <code>基础上</code> 进行计算<code>凑齐300元的最优解</code>，也就是从<code>capacity较小的问题</code>开始计算。</p>
<p>同时，<code>保证任何时候的凑零钱方式</code>都符合 <code>每种硬币的数量限制</code>。</p>
<p>也就是说，我们是通过<code>在capacity较小的问题</code>的 <code>基础 (Base)</code>之上，<code>动态地</code> 计算 <code>capacity较大的问题的最优解</code>，</p>
<blockquote><p>换句话说，如果我们在 <code>capacity较小的问题</code> 的 <code>基础</code> 之上，求解 <code>capacity较大的问题</code>的 <code>最优解</code>。</p>
<p>那么违反 <code>数量限制的解</code> 本质上就是 <code>非法解</code>，并不是 <code>合法解</code>，更谈不上 <code>最优解</code>！</p>
<p>这使得处理 <code>数量限制</code>的约束非常容易，我们需要做的仅仅是 <code>在子问题的基础之上求解原问题</code>。</p>
<blockquote><p>即要求我们满足 <code>最优子结构 (Optimal Substructure)</code> 性质</p>
</blockquote>
</blockquote>
<hr/>
<p>关于<code>每种硬币的数量限制</code>，还有一个重要的性质，那就是<code>凑硬币的顺序是可交换的</code>。</p>
<p>比如说：</p>
<p>$$
\a{
50 &amp;= 30 + 10 + 10 \
&amp;= 10 + 30 + 10 \
&amp;= 10 + 10 + 30
}
$$
也就是<code>同样面值的固定数量的硬币</code>，按 <code>任意顺序</code> 放入，最终的 <code>效果</code> 是等价的。</p>
<blockquote><p>即 <code>整数的加法</code>是 <code>可交换的</code></p>
</blockquote>
<p>那么，也就是说：如果我们要求<code>凑齐50元硬币的最优解</code>，而我们 <code>拥有一些10元硬币</code>，</p>
<p>则我们无需考虑<code>到底要按照什么顺序放入这些10元硬币</code>，而仅仅需要考虑，<code>到底一次性要放多少枚10元硬币</code>才可以得到<code>凑齐50元硬币的最优解</code>。</p>
<p>因此，我们实际上利用 <code>可交换性</code>可以<code>压缩</code> 掉 <code>amount维度</code>：</p>
<p>由于对于 <code>某种硬币</code>来说， <code>分多步放入共k枚</code>和 <code>在1步就一次性放入k枚</code>的 <code>效果</code>是 <code>等价的</code>，</p>
<p>那么我们不妨就可以 <code>依次考虑每种类型的硬币</code>，并 <code>确定一次性要放多少枚该种硬币</code>。</p>
<p>在已知<code>正在考虑的硬币类型</code>和 <code>当前需要凑齐的金额</code>时，我们可以很容易地得出 <code>当前类型的硬币的数量</code>的 <code>上下界</code>，</p>
<p>然后依次考虑 <code>k的所有可能取值</code>，找出 <code>原问题的最优解</code>。</p>
<blockquote><p>如果没有这样压缩，则我们要为<code>amount维度</code>的每种可能的来源方式做考虑：</p>
<p>如果没有 <code>可交换性</code>的话，我们就需要为 <code>硬币数量的所有可能来源</code>做考虑。</p>
<p>如 5枚 = 0+5 = 1 + 4 = 2 + 3 = 3 + 2 = 4 + 1 = 5 + 0</p>
</blockquote>
<hr/>
<p>因而，我们可以得到 <code>压缩后的递推方程</code>。
$$
\boxed{\t{Just take the final step into consideration}} \
dp[capacity][type] = \lb{
&amp;dp[capacity \r{- (k * values[type])}][type-1]\g{+ k},&amp;(\t{use coins of the current type}) \
&amp;dp[capacity][type-1],&amp;(\t{don't use coins of the current type})
}
$$</p>
<blockquote><p>n.b. 当我们<code>集中起来一次性考虑每种面额要放多少枚硬币</code>时，我们将<code>非常容易地</code>实现<code>对每种面值的硬币的数量的限制</code>（只需要通过简单地取定<code>当前面值的硬币</code>的<code>循环下限</code>和<code>循环上限</code>即可）</p>
<blockquote><p>同时这也意味着，<code>每种硬币的数量是特定的</code>和<code>每种硬币的数量是无限的</code>这两种问题本质上是相同的。</p>
</blockquote>
</blockquote>
<h3>Solution</h3>
<h4>Iterative Method</h4>
<h5>Diagram</h5>
<pre><code class="lang-yaml">Expected  Input: [3, 2 3, 3 3, 6 1, 12]
Expected Output: [3]
</code></pre>
<table>
<thead><tr>
<th style="text-align:center">item\capacity</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1061109567</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">xxxxxxxxxx -----------------------------------------------------Current Case: MODE1.in &amp; MODE1.outExpected  Input: [10, Omit the remaining 10 line(s)...]Expected Output: [1, 5]Your     Output: [1, 5]Time Cost: 0.045200 ms (45200 ns)Accepted-----------------------------------------------------Current Case: MODE10.in &amp; MODE10.outExpected  Input: [1234567, Omit the remaining 1234567 line(s)...]Expected Output: [47527, 38]Your     Output: [47527, 38]Time Cost: 104.330000 ms (104330000 ns)Accepted-----------------------------------------------------Current Case: MODE11.in &amp; MODE11.outExpected  Input: [10, Omit the remaining 10 line(s)...]Expected Output: [1, 6]Your     Output: [1, 6]Time Cost: 0.001100 ms (1100 ns)Accepted-----------------------------------------------------Current Case: MODE12.in &amp; MODE12.outExpected  Input: [10, Omit the remaining 10 line(s)...]Expected Output: [2, 5]Your     Output: [2, 5]Time Cost: 0.001000 ms (1000 ns)Accepted-----------------------------------------------------Current Case: MODE13.in &amp; MODE13.outExpected  Input: [10, Omit the remaining 10 line(s)...]Expected Output: [2, 4]Your     Output: [2, 4]Time Cost: 0.000901 ms (901 ns)Accepted-----------------------------------------------------Current Case: MODE14.in &amp; MODE14.outExpected  Input: [10, Omit the remaining 10 line(s)...]Expected Output: [2, 4]Your     Output: [2, 4]Time Cost: 0.001200 ms (1200 ns)Accepted-----------------------------------------------------Current Case: MODE15.in &amp; MODE15.outExpected  Input: [10, Omit the remaining 9 line(s)...]Expected Output: [3, 4]Your     Output: [3, 4]Time Cost: 0.001101 ms (1101 ns)Accepted-----------------------------------------------------Current Case: MODE2.in &amp; MODE2.outExpected  Input: [50, Omit the remaining 50 line(s)...]Expected Output: [3, 8]Your     Output: [3, 8]Time Cost: 0.002099 ms (2099 ns)Accepted-----------------------------------------------------Current Case: MODE3.in &amp; MODE3.outExpected  Input: [100, Omit the remaining 100 line(s)...]Expected Output: [28, 9]Your     Output: [28, 9]Time Cost: 0.004400 ms (4400 ns)Accepted-----------------------------------------------------Current Case: MODE4.in &amp; MODE4.outExpected  Input: [500, Omit the remaining 500 line(s)...]Expected Output: [17, 8]Your     Output: [29, 8]Time Cost: 0.029600 ms (29600 ns)Wrong Answer.-----------------------------------------------------Current Case: MODE5.in &amp; MODE5.outExpected  Input: [10000, Omit the remaining 10000 line(s)...]Expected Output: [152, 11]Your     Output: [152, 11]Time Cost: 0.564300 ms (564300 ns)Accepted-----------------------------------------------------Current Case: MODE6.in &amp; MODE6.outExpected  Input: [50000, Omit the remaining 50000 line(s)...]Expected Output: [1507, 11]Your     Output: [1507, 11]Time Cost: 3.741200 ms (3741200 ns)Accepted-----------------------------------------------------Current Case: MODE7.in &amp; MODE7.outExpected  Input: [500000, Omit the remaining 500000 line(s)...]Expected Output: [62872, 23]Your     Output: [62872, 23]Time Cost: 37.026301 ms (37026301 ns)Accepted-----------------------------------------------------Current Case: MODE8.in &amp; MODE8.outExpected  Input: [1000000, Omit the remaining 1000000 line(s)...]Expected Output: [15875, 34]Your     Output: [15875, 34]Time Cost: 71.459100 ms (71459100 ns)Accepted-----------------------------------------------------Current Case: MODE9.in &amp; MODE9.outExpected  Input: [1234567, Omit the remaining 1234567 line(s)...]Expected Output: [44678, 42]Your     Output: [44678, 42]Time Cost: 83.852201 ms (83852201 ns)Accepted-----------------------------------------------------Result Statistics: √ √ √ √ √ √ √ √ √ × √ √ √ √ √ yaml</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<h5>Source</h5>
<pre><code class="lang-java">    public static int solve(int[] values, int[] amounts, int capacity) {
        // define dp array
        int[][] dp = new int[values.length + 1][capacity + 1];

        // init
        for (int i = 0; i &lt;= values.length; i++) {
            dp[i][0] = 0;
        }
        for (int j = 1; j &lt;= capacity; j++) {
            dp[0][j] = 0x3f3f3f3f;
        }

        // only use the first i coins
        for (int i = 1; i &lt;= values.length; i++) {
            int value = values[i - 1];
            // to satisfy j capacity
            for (int j = 1; j &lt;= capacity; j++) {
                // how many coins of this type should be used ?
                for (int k = 0; k &lt;= j / value &amp;&amp; k &lt;= amounts[i - 1]; k++) {
                    dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - k * value] + k);
                }
            }
        }

        int ans = dp[values.length][capacity];
        return ans == 0x3f3f3f3f ? -1 : ans;
    }
</code></pre>
<h5>Benchmark</h5>
<pre><code class="lang-yaml">-----------------------------------------------------
Current Case: COINS0.in &amp; COINS0.out
Expected  Input: [10, 1 0, 2 12, 5 180, 10 0, 20 109, 50 126, 100 192, 200 107, 500 47, 1000 20, 14758]
Expected Output: [21]
Your     Output: [21]
Time Cost: 25.284600 ms (25284600 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS1.in &amp; COINS1.out
Expected  Input: [10, 1 0, 2 12, 5 180, 10 0, 20 109, 50 126, 100 192, 200 107, 500 47, 1000 20, 14758]
Expected Output: [21]
Your     Output: [21]
Time Cost: 16.951400 ms (16951400 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS2.in &amp; COINS2.out
Expected  Input: [10, 1 0, 2 45, 5 0, 10 148, 20 145, 50 136, 100 181, 200 17, 500 172, 1000 152, 16834]
Expected Output: [23]
Your     Output: [23]
Time Cost: 13.734800 ms (13734800 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS3.in &amp; COINS3.out
Expected  Input: [10, 1 0, 2 22, 5 0, 10 27, 20 52, 50 192, 100 164, 200 110, 500 62, 1000 98, 17397]
Expected Output: [-1]
Your     Output: [-1]
Time Cost: 10.814700 ms (10814700 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS4.in &amp; COINS4.out
Expected  Input: [10, 1 0, 2 99, 5 173, 10 11, 20 54, 50 101, 100 6, 200 44, 500 15, 1000 126, 12810]
Expected Output: [16]
Your     Output: [16]
Time Cost: 8.838500 ms (8838500 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS5.in &amp; COINS5.out
Expected  Input: [10, 1 0, 2 133, 5 6, 10 137, 20 196, 50 198, 100 176, 200 0, 500 168, 1000 94, 2253]
Expected Output: [-1]
Your     Output: [-1]
Time Cost: 1.159000 ms (1159000 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS6.in &amp; COINS6.out
Expected  Input: [10, 1 0, 2 0, 5 3, 10 131, 20 24, 50 78, 100 66, 200 84, 500 147, 1000 152, 16423]
Expected Output: [-1]
Your     Output: [-1]
Time Cost: 8.171400 ms (8171400 ns)
Accepted.
-----------------------------------------------------
Result Statistics: √ √ √ √ √ √ √
</code></pre>
<h4>Recursive Method (2-Dimension)</h4>
<h5>Diagram</h5>
<pre><code class="lang-yaml">Expected  Input: [3, 2 3, 3 3, 6 1, 12]
Expected Output: [3]
</code></pre>
<pre><code class="lang-mermaid">graph TD;
root((root)) --#1, 0 * 6--&gt; 47c306e5((12))
47c306e5 --#2, 0 * 3--&gt; 1c2ac852((12))
1c2ac852 --#3, 0 * 2--&gt; a6e0b278((12))
1c2ac852 --#4, 1 * 2--&gt; d03ca462((10))
1c2ac852 --#5, 2 * 2--&gt; 91c93566((8))
1c2ac852 --#6, 3 * 2--&gt; 4180836e((6))
style 4180836e fill: lightgreen,stroke: #333,stroke-width: 4px
47c306e5 --#7, 1 * 3--&gt; 5ecc1041((9))
5ecc1041 --#8, 0 * 2--&gt; b759c285((9))
5ecc1041 --#9, 1 * 2--&gt; 01ecf723((7))
5ecc1041 --#10, 2 * 2--&gt; a3105e86((5))
5ecc1041 --#11, 3 * 2--&gt; 25c25e57((3))
style 25c25e57 fill: lightgreen,stroke: #333,stroke-width: 4px
47c306e5 --#12, 2 * 3--&gt; be869faa((6))
style be869faa fill: lightgreen,stroke: #333,stroke-width: 4px
be869faa --#13, 0 * 2--&gt; 3314f76a((6))
style 3314f76a fill: lightgray,stroke: #333,stroke-width: 4px
be869faa --#14, 1 * 2--&gt; e07a5826((4))
be869faa --#15, 2 * 2--&gt; bdcf5e09((2))
be869faa --#16, 3 * 2--&gt; b6de7abb((0))
style b6de7abb fill: lightgreen,stroke: #333,stroke-width: 4px
47c306e5 --#17, 3 * 3--&gt; 4fd2a78a((3))
style 4fd2a78a fill: lightgreen,stroke: #333,stroke-width: 4px
4fd2a78a --#18, 0 * 2--&gt; 24309338((3))
style 24309338 fill: lightgray,stroke: #333,stroke-width: 4px
4fd2a78a --#19, 1 * 2--&gt; a9927e68((1))
root((root)) --#20, 1 * 6--&gt; 30bd713b((6))
30bd713b --#21, 0 * 3--&gt; 82f6a912((6))
style 82f6a912 fill: lightgray,stroke: #333,stroke-width: 4px
30bd713b --#22, 1 * 3--&gt; a1adc784((3))
style a1adc784 fill: lightgray,stroke: #333,stroke-width: 4px
30bd713b --#23, 2 * 3--&gt; 2bd1ac23((0))
2bd1ac23 --#24, 0 * 2--&gt; 9eccd897((0))
style 9eccd897 fill: lightgray,stroke: #333,stroke-width: 4px
</code></pre>
<h5>Source</h5>
<pre><code class="lang-java">    static int n;
    static int[] values;
    static int[] amounts;
    static int capacity;
    static int[][] dp;
    static boolean[][] visited;
    static int INF = 0x3f3f3f3f;

    public static int f(int firstCoins, int capacity) {

        /* Base Case */
        if (visited[firstCoins][capacity] || firstCoins == 0) return dp[firstCoins][capacity];
        else visited[firstCoins][capacity] = true;

        /* Recursive Case */
        int value = values[firstCoins - 1];
        for (int k = 0; (k &lt;= capacity / value) &amp;&amp; (k &lt;= amounts[firstCoins - 1]); k++) {
            // the following are the same
            // dp[firstCoins][capacity] = Math.min(f(firstCoins - 1, capacity), f(firstCoins - 1, capacity - (k * value)) + k);
            dp[firstCoins][capacity] = Math.min(dp[firstCoins - 1][capacity], f(firstCoins - 1, capacity - (k * value)) + k);
        }

        return dp[firstCoins][capacity];
    }

    public static int solve() {

        // define dp array
        dp = new int[values.length + 1][capacity + 1];
        visited = new boolean[values.length + 1][capacity + 1];

        // init
        for (int i = 0; i &lt;= values.length; i++) {
            for (int j = 0; j &lt;= capacity; j++) {
                dp[i][j] = INF;
            }
        }

        for (int i = 0; i &lt;= values.length; i++) {
            dp[i][0] = 0;
        }
        for (int j = 1; j &lt;= capacity; j++) {
            dp[0][j] = INF;
        }

        // dp
        int ans = f(values.length, capacity);
        return ans == INF ? -1 : ans;
    }

    public static void main(String[] args) {
        for (Scanner scanner : judger) {
            n = scanner.nextInt();
            values = new int[n];
            amounts = new int[n];
            for (int i = 0; i &lt; n; i++) {
                int value = scanner.nextInt();
                int amount = scanner.nextInt();
                values[i] = value;
                amounts[i] = amount;
            }
            capacity = scanner.nextInt();
            judger.manuallyStartTimer();
            System.out.println(solve());
            judger.manuallyStopTimer();
        }
    }
</code></pre>
<h5>Benchmark</h5>
<pre><code class="lang-yaml">-----------------------------------------------------
Current Case: COINS0.in &amp; COINS0.out
Expected  Input: [10, 1 0, 2 12, 5 180, 10 0, 20 109, 50 126, 100 192, 200 107, 500 47, 1000 20, 14758]
Expected Output: [21]
Your     Output: [21]
Time Cost: 8.383200 ms (8383200 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS1.in &amp; COINS1.out
Expected  Input: [10, 1 0, 2 12, 5 180, 10 0, 20 109, 50 126, 100 192, 200 107, 500 47, 1000 20, 14758]
Expected Output: [21]
Your     Output: [21]
Time Cost: 5.690600 ms (5690600 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS2.in &amp; COINS2.out
Expected  Input: [10, 1 0, 2 45, 5 0, 10 148, 20 145, 50 136, 100 181, 200 17, 500 172, 1000 152, 16834]
Expected Output: [23]
Your     Output: [23]
Time Cost: 6.921800 ms (6921800 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS3.in &amp; COINS3.out
Expected  Input: [10, 1 0, 2 22, 5 0, 10 27, 20 52, 50 192, 100 164, 200 110, 500 62, 1000 98, 17397]
Expected Output: [-1]
Your     Output: [-1]
Time Cost: 1.721700 ms (1721700 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS4.in &amp; COINS4.out
Expected  Input: [10, 1 0, 2 99, 5 173, 10 11, 20 54, 50 101, 100 6, 200 44, 500 15, 1000 126, 12810]
Expected Output: [16]
Your     Output: [16]
Time Cost: 4.294700 ms (4294700 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS5.in &amp; COINS5.out
Expected  Input: [10, 1 0, 2 133, 5 6, 10 137, 20 196, 50 198, 100 176, 200 0, 500 168, 1000 94, 2253]
Expected Output: [-1]
Your     Output: [-1]
Time Cost: 1.258100 ms (1258100 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS6.in &amp; COINS6.out
Expected  Input: [10, 1 0, 2 0, 5 3, 10 131, 20 24, 50 78, 100 66, 200 84, 500 147, 1000 152, 16423]
Expected Output: [-1]
Your     Output: [-1]
Time Cost: 2.296300 ms (2296300 ns)
Accepted.
-----------------------------------------------------
Current Case: COINS7.in &amp; COINS7.out
Expected  Input: [3, 1 1, 2 2, 3 3, 11]
Expected Output: [4]
Your     Output: [4]
Time Cost: 0.092600 ms (92600 ns)
Accepted.
-----------------------------------------------------
Result Statistics: √ √ √ √ √ √ √ √
</code></pre>
<h4>Recursive Method (4-Dimension)</h4>
<h5>Diagram</h5>
<pre><code class="lang-yaml">Expected  Input: [3, 2 3, 3 3, 6 1, 12]
Expected Output: [3]
</code></pre>
<pre><code class="lang-mermaid">graph TD;
root((root)) --#36, 0 * 6--&gt; a7411865((12))
a7411865 --#37, 0 * 3--&gt; 45b1eb92((12))
45b1eb92 --#38, 0 * 2--&gt; 23c84bd8((12))
style 23c84bd8 fill: lightgray,stroke: #333,stroke-width: 4px
45b1eb92 --#39, 1 * 2--&gt; 3a989a55((10))
style 3a989a55 fill: lightgray,stroke: #333,stroke-width: 4px
45b1eb92 --#40, 2 * 2--&gt; 01f72111((8))
style 01f72111 fill: lightgray,stroke: #333,stroke-width: 4px
45b1eb92 --#41, 3 * 2--&gt; bf018faf((6))
style bf018faf fill: lightgray,stroke: #333,stroke-width: 4px
a7411865 --#42, 1 * 3--&gt; e48ee7e2((9))
e48ee7e2 --#43, 0 * 2--&gt; 4edc439b((9))
style 4edc439b fill: lightgray,stroke: #333,stroke-width: 4px
e48ee7e2 --#44, 1 * 2--&gt; f92a6278((7))
style f92a6278 fill: lightgray,stroke: #333,stroke-width: 4px
e48ee7e2 --#45, 2 * 2--&gt; 1b25d26a((5))
style 1b25d26a fill: lightgray,stroke: #333,stroke-width: 4px
e48ee7e2 --#46, 3 * 2--&gt; 39611a30((3))
style 39611a30 fill: lightgray,stroke: #333,stroke-width: 4px
a7411865 --#47, 2 * 3--&gt; 0abad9d3((6))
0abad9d3 --#48, 0 * 2--&gt; ba8ca012((6))
style ba8ca012 fill: lightgray,stroke: #333,stroke-width: 4px
0abad9d3 --#49, 1 * 2--&gt; 0475bb15((4))
style 0475bb15 fill: lightgray,stroke: #333,stroke-width: 4px
0abad9d3 --#50, 2 * 2--&gt; ea8374c3((2))
style ea8374c3 fill: lightgray,stroke: #333,stroke-width: 4px
0abad9d3 --#51, 3 * 2--&gt; eeff9ef2((0))
style eeff9ef2 fill: lightgray,stroke: #333,stroke-width: 4px
a7411865 --#52, 3 * 3--&gt; fbb80b24((3))
fbb80b24 --#53, 0 * 2--&gt; a96a30bc((3))
style a96a30bc fill: lightgray,stroke: #333,stroke-width: 4px
fbb80b24 --#54, 1 * 2--&gt; fc4ee4be((1))
style fc4ee4be fill: lightgray,stroke: #333,stroke-width: 4px
root((root)) --#55, 1 * 6--&gt; 8c399954((6))
8c399954 --#56, 0 * 3--&gt; 59fdd542((6))
59fdd542 --#57, 0 * 2--&gt; 49d33747((6))
style 49d33747 fill: lightgray,stroke: #333,stroke-width: 4px
59fdd542 --#58, 1 * 2--&gt; 8d975ef6((4))
style 8d975ef6 fill: lightgray,stroke: #333,stroke-width: 4px
59fdd542 --#59, 2 * 2--&gt; 89d23054((2))
style 89d23054 fill: lightgray,stroke: #333,stroke-width: 4px
59fdd542 --#60, 3 * 2--&gt; 1ec22271((0))
style 1ec22271 fill: lightgray,stroke: #333,stroke-width: 4px
8c399954 --#61, 1 * 3--&gt; 4de3015f((3))
4de3015f --#62, 0 * 2--&gt; 010c58d1((3))
style 010c58d1 fill: lightgray,stroke: #333,stroke-width: 4px
4de3015f --#63, 1 * 2--&gt; 951f5029((1))
style 951f5029 fill: lightgray,stroke: #333,stroke-width: 4px
8c399954 --#64, 2 * 3--&gt; ce3992c9((0))
style ce3992c9 fill: lightgray,stroke: #333,stroke-width: 4px
</code></pre>
<h5>Source</h5>
<pre><code class="lang-java">    static int n;
    static int[] values;
    static int[] amounts;
    static int capacity;
    static int INF = 0x3f3f3f3f;

    public static class Memo {
        private static final ArrayList&lt;Memo&gt; memo = new ArrayList&lt;&gt;();
        public int firstCoins;
        public int capacity;
        public int[] amounts;
        public int value;
        public boolean visited;

        public Memo(int firstCoins, int capacity, int[] amounts, int value, boolean visited) {
            this.firstCoins = firstCoins;
            this.capacity = capacity;
            this.amounts = amounts;
            this.value = value;
            this.visited = visited;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Memo memo = (Memo) o;
            if (firstCoins != memo.firstCoins) return false;
            if (capacity != memo.capacity) return false;
            return Arrays.equals(amounts, memo.amounts);
        }

        public static void resetMemo() {
            memo.clear();
        }

        public static void set(int firstCoins, int capacity, int[] amounts, int value, boolean visited) {
            int index = memo.indexOf(new Memo(firstCoins, capacity, amounts, value, visited));
            if (index == -1) {
                memo.add(new Memo(firstCoins, capacity, amounts, value, visited));
            } else {
                memo.set(index, new Memo(firstCoins, capacity, amounts, value, visited));
            }
        }

        public static Memo MEMO_ZERO = new Memo(0, 0, null, 0, true);
        public static Memo MEMO_INF = new Memo(0, 0, null, INF, true);

        public static Memo get(int firstCoins, int capacity, int[] amounts) {

            /* Special cases */
            if (capacity == 0) return MEMO_ZERO;
            else if (firstCoins == 0) return MEMO_INF;

            /* Normal cases */
            int index = memo.indexOf(new Memo(firstCoins, capacity, amounts, -1, false));
            if (index == -1) {
                Memo temp = new Memo(firstCoins, capacity, amounts, INF, false);
                memo.add(temp);
                return temp;
            } else return memo.get(index);
        }

    }

    public static int f(int firstCoins, int capacity, int[] amounts) {

        /* Base Case */
        if (Memo.get(firstCoins, capacity, amounts).visited) {
            return Memo.get(firstCoins, capacity, amounts).value;
        }

        /* Recursive Case */
        int value = values[firstCoins - 1];
        for (int k = 0; (k &lt;= capacity / value) &amp;&amp; (k &lt;= amounts[firstCoins - 1]); k++) {
            // choice 1
            int do_not_use_current_type_of_coin = Memo.get(firstCoins - 1, capacity, amounts).value;

            // choice 2
            int[] amounts_clone = amounts.clone();
            amounts_clone[firstCoins - 1] -= k;
            int use_current_type_of_coin = f(firstCoins - 1, capacity - (k * value), amounts_clone) + k;

            // optimal choice
            Memo.set(firstCoins, capacity, amounts, Math.min(do_not_use_current_type_of_coin, use_current_type_of_coin), true);
        }

        return Memo.get(firstCoins, capacity, amounts).value;
    }

    public static int solve() {

        // define dp array
        Memo.resetMemo();

        // dp
        int ans = f(values.length, capacity, amounts);
        return ans == INF ? -1 : ans;
    }

    public static void main(String[] args) {
        for (Scanner scanner : judger) {
            n = scanner.nextInt();
            values = new int[n];
            amounts = new int[n];
            for (int i = 0; i &lt; n; i++) {
                int value = scanner.nextInt();
                int amount = scanner.nextInt();
                values[i] = value;
                amounts[i] = amount;
            }
            capacity = scanner.nextInt();
            judger.manuallyStartTimer();
            System.out.println(solve());
            judger.manuallyStopTimer();
        }
    }
</code></pre>
<h5>Benchmark</h5>
<h6>Recursive Method with 4-Dimension</h6>
<pre><code class="lang-yaml">-----------------------------------------------------
Current Case: COINS7.in &amp; COINS7.out
Expected  Input: [3, 1 1, 2 2, 3 3, 11]
Expected Output: [4]
Your     Output: [4]
Time Cost: 1.000600 ms (1000600 ns)
Accepted
-----------------------------------------------------
Current Case: COINS8.in &amp; COINS8.out
Expected  Input: [3, 2 3, 3 3, 6 1, 12]
Expected Output: [3]
Your     Output: [3]
Time Cost: 0.242400 ms (242400 ns)
Accepted
-----------------------------------------------------
Current Case: COINS9.in &amp; COINS9.out
Expected  Input: [9, 1 1, 2 2, 3 3, 4 4, 5 5, 6 6, 7 7, 8 8, 9 9, 60]
Expected Output: [7]
Your     Output: [7]
Time Cost: 17775.069700 ms (17775069700 ns)
Accepted
-----------------------------------------------------
Result Statistics: √ √ √
</code></pre>
<h6>Recursive Method with 2-Dimention</h6>
<pre><code class="lang-yaml">-----------------------------------------------------
Current Case: COINS7.in &amp; COINS7.out
Expected  Input: [3, 1 1, 2 2, 3 3, 11]
Expected Output: [4]
Your     Output: [4]
Time Cost: 8.181900 ms (8181900 ns)
Accepted
-----------------------------------------------------
Current Case: COINS8.in &amp; COINS8.out
Expected  Input: [3, 2 3, 3 3, 6 1, 12]
Expected Output: [3]
Your     Output: [3]
Time Cost: 3.047300 ms (3047300 ns)
Accepted
-----------------------------------------------------
Current Case: COINS9.in &amp; COINS9.out
Expected  Input: [9, 1 1, 2 2, 3 3, 4 4, 5 5, 6 6, 7 7, 8 8, 9 9, 60]
Expected Output: [7]
Your     Output: [7]
Time Cost: 69.721200 ms (69721200 ns)
Accepted
-----------------------------------------------------
Result Statistics: √ √ √
</code></pre>
<h2>Pebble Merging Problem</h2>
<h3>Description</h3>
<p>在一个圆形操场的四周摆放着 n 堆石子。现要将石子有次序地合并成一堆。规定每次只
能选相邻的 2 堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。试设计一
个算法，计算出将 n 堆石子合并成一堆的最小得分和最大得分。</p>
<h3>Input</h3>
<p>由文件 input.txt 提供输入数据。文件的第 1 行是正整数 n，1≤n≤100，表示有 n 堆石子。
第二行有 n 个数，分别表示每堆石子的个数。</p>
<h3>Output</h3>
<p>程序运行结束时，将计算结果输出到文件 output.txt 中。文件的第 1 行中的数是最小得
分；第 2 行中的数是最大得分；。</p>
<h3>Sample</h3>
<p><strong>输入文件示例</strong></p>
<p>input.txt</p>
<p>4</p>
<p>4 4 5 9</p>
<p><strong>输出文件示例</strong></p>
<p>output.txt</p>
<p>43</p>
<p>54</p>
<h3>Analysis</h3>
<p>我们只考虑<code>最小得分</code>，因为 <code>最小得分</code> 和 <code>最大得分</code> 是<code>对称的</code>。</p>
<p>然后，由于<code>每次只能合并相邻的两堆石子</code>，所以我们不妨<code>将所有石子从左到右排成线性的一堆石子</code></p>
<hr/>
<h4>Establish the Recursive Equation</h4>
<p>我们不妨考虑 <code>最终 (End)</code> 会发生什么： <code>所有的n堆石子</code> 被合并为 <code>1堆石子</code>。</p>
<p>而<code>最后一步 (The Final Step)</code>时，我们会将<code>2堆石子</code>合并为<code>1堆石子</code>。</p>
<p>显然，我们需要<code>为此次合并操作</code>付出的代价为<code>左边那一堆石子的重量 + 右边那一堆石子的重量</code></p>
<p>此外，我们还要加上<code>为了获得左边那堆石子的所付出的代价</code>和<code>为了获得右边那堆石子所付出的代价</code></p>
<blockquote><p>注意，这里面已经隐含了<code>递归</code>，这相当于，我们在<code>线性排列的一堆石子里</code>：在<code>第i堆石子</code>和<code>第j堆石子</code>之中，插入了<code>分隔板</code>，使之形成<code>左边那堆石子（第i堆石子~第k堆石子)</code> 和<code>右边那堆石子 (第k+1堆石子~第j堆石子)</code>。</p>
</blockquote>
<p>因而，我们可以写出<code>递推方程</code>
$$
\bt{Just take the final step into considetaion} \
dp[i][j] = \lb {
&amp; \r{dp[i][k]+dp[k+1][j]} \g{+ (sum[j] - sum[i])},&amp;(\t{we find a better plan !}) \
&amp; dp[i][j],&amp;(\t{not better than current plan})
}
$$</p>
<blockquote><p>其中$sum$表示 <code>前缀和</code></p>
</blockquote>
<hr/>
<h4>Determine the order of computation (Iterative Method)</h4>
<p>为了 <code>保证</code>在  <code>求解原问题</code>时，<code>该原问题所需的所有子问题</code> 均 <code>已经求解完毕</code>，则我们需要 <code>确定合适的运算顺序</code>。</p>
<p>首先，我们考虑下<code>合并过程刚开始的时候</code>：i=1,j=n 即表示考虑 从<code>第1堆石子</code>到<code>第n堆石子</code>的最少合并代价，</p>
<p>假设<code>最终这个最优解在第k堆石子处分隔开</code>：</p>
<p>即可得到<code>2个子问题</code>，<code>从第1堆石子到第k堆石子的最少合并代价</code>和<code>从第k+1堆石子到第n堆石子的最少合并代价</code>。</p>
<p>不妨继续考虑<code>从第1堆石子到第k堆石子的最少合并代价</code>，我们会发现这里仍然需要 <code>递归</code> ，直到<code>基本情况</code>。</p>
<p>而<code>基本情况</code>就是<code>只有1堆石子的情况</code>。</p>
<p>所以，通过<code>分析递归过程</code>得出的<code>基本情况</code>，我们<code>反过来</code>从<code>基本情况</code>逐步建立<code>迭代形式的运算顺序</code>：即我们从<code>只有1堆石子的最少合并代价</code>开始计算，然后计算<code>只有2堆石子的最少合并代价</code>，...，计算<code>只有n堆石子的最少合并代价</code>。</p>
<p>于是，我们确定了<code>第一个运算顺序：考虑只有[1, n]堆石子的最少合并代价</code></p>
<p>接下来，我们需要<code>枚举</code> <code>只有len堆石子</code>到底是 <code>哪len堆石子</code> ，由于已经确定了<code>石子的堆数（即区间长度 len，因为所有石子堆是线性排列的）</code>。</p>
<p>则我们只需要确定<code>起始点</code>即可，于是，我们确定了<code>第二个运算顺序：只有指定堆的石子的起始点为[0,n - len]</code></p>
<p>而接下来，我们仅需要对<code>指定长度的石子堆</code>进行<code>确定分割点k</code>即可。</p>
<blockquote><p>而且由于我们前面的运算顺序中，<code>第一个运算顺序</code>为计算<code>石子堆的长度</code>从1~n</p>
<p>因而，我们在<code>第三个运算顺序</code>时<code>确立分割点</code>时，可以<code>保证 更小区间长度的石子堆的最小合并代价</code>是<code>已经计算好的</code></p>
</blockquote>
<hr/>
<p>综上，我们确立好了运算顺序：</p>
<ol>
<li>第一个运算顺序：区间长度（连续的len个石子堆）</li>
<li>第二个运算顺序：区间的起始点（从第i个石子堆开始的连续len个石子堆）</li>
<li>第三个运算顺序：分割点（在这个选定的 <code>石子堆序列</code> 中，选定 <code>分割点</code>，将这个 <code>石子堆序列</code> 分为 <code>左右两个部分</code>）</li>
</ol>
<h4>Simply use memo (Recursive Method)</h4>
<p>在已经得出了 <code>递推方程</code>的情况下，如果不希望 <code>确定运算顺序</code>，则可以直接使用 <code>递归方法</code>。</p>
<p><code>递归方法</code>可以非常自然地 <code>描述</code> <code>递推关系</code>。</p>
<p>在已知 <code>最优子结构</code>的情况下，<code>动态规划 (Dynamic Programming)</code>   和 <code>暴力法 (Brute-Force)</code>最大的区别是：</p>
<p><code>动态规划</code>利用了 <code>重叠子问题 (Overlapping Subproblem)</code>性质。</p>
<p>即 <code>递归形式的动态规划 = 递归形式的暴力法 + 备忘录机制</code></p>
<blockquote><p>如果一开始就打算使用<code>递归形式</code>，那么<code>运算顺序</code>就没有那么重要了，因为我们总可以<code>在需要的时候临时计算</code>，然后<code>利用备忘录机制（这很重要，否则会导致重复地求解相同的子问题）</code>来保存<code>某个子问题的计算结果</code>即可。</p>
<p>但相比于 <code>迭代形式的动态规划</code>会 <code>产生整颗子问题空间树 (无论某些子问题是否真的被用到)</code>， <code>递归形式的动态规划</code>则只会 <code>生成那些确实需要用到的子问题</code>。</p>
<p>但是，一般来说，<code>迭代形式的动态规划</code>却会更加快速。</p>
<blockquote><p><code>编译器</code>对于 <code>迭代算法</code>可以有更多的信息来进行 <code>指令级优化</code>。</p>
<p>同时，<code>迭代形式</code>也可以避免过多的 <code>过程调用的帧栈创建和销毁的代价</code>，以及获得 <code>更优的高速缓存命中率</code></p>
</blockquote>
<p>但通过 <code>递归形式</code>产生的 <code>子问题空间树</code>是 <code>“残缺的”</code>，在只有 <code>少量子问题</code>重复出现的情况下，用 <code>递归形式的动态规划</code>会更加高效。</p>
</blockquote>
<h3>Solution</h3>
<h4>Iterative Method</h4>
<h5>Diagram</h5>
<pre><code class="lang-yaml">Expected  Input: [4, 1 2 3333 2]
Expected Output: [6676, 10010]
</code></pre>
<table>
<thead><tr>
<th style="text-align:center">i\j</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3339</td>
<td style="text-align:center">6676</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3335</td>
<td style="text-align:center">6672</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3335</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">1061109567</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<table>
<thead><tr>
<th style="text-align:center">i\j</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6671</td>
<td style="text-align:center">10010</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3335</td>
<td style="text-align:center">6672</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3335</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<h5>Source</h5>
<pre><code class="lang-java">     public static Judger.Pair&lt;Integer, Integer&gt; solve(int n, int[] sum) {

        int[][] dp = new int[n][n];
        int min, max;

        // Min cost
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (i == j) dp[i][j] = 0;
                else dp[i][j] = 0x3f3f3f3f;
            }
        }

        for (int len = 1; len &lt; n; len++) {
            for (int i = 0; i &lt; (n - len); i++) {
                int j = i + len;
                for (int k = i; k &lt; j; k++) {
                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + (sum[j + 1] - sum[i]));
                }

            }
        }
        min = dp[0][n - 1];

        // Max Cost
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (i == j) dp[i][j] = 0;
                else dp[i][j] = 0;
            }
        }

        for (int len = 1; len &lt; n; len++) {
            for (int i = 0; i &lt; (n - len); i++) {
                int j = i + len;
                for (int k = i; k &lt; j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + (dp[k + 1][j] + sum[j + 1] - sum[i]));
                }

            }
        }
        max = dp[0][n - 1];

        return new Judger.Pair&lt;&gt;(min, max);
    }

    public static void main(String[] args) {

        for (Scanner scanner : judger) {
            int n = scanner.nextInt();
            int[] a = new int[n];
            for (int i = 0; i &lt; n; i++) {
                a[i] = scanner.nextInt();
            }

            // Pre-solve: partial sum
            int[] sum = new int[n + 1];
            sum[0] = 0;
            for (int i = 1; i &lt; sum.length; i++) {
                sum[i] = sum[i - 1] + a[i - 1];
            }

            Judger.Pair&lt;Integer, Integer&gt; answer = solve(n, sum);
            System.out.printf("%d\n%d", answer.getKey(), answer.getValue());
        }
    }
</code></pre>
<h5>Benchmark</h5>
<pre><code class="lang-yaml">-----------------------------------------------------
Current Case: MERGE0.in &amp; MERGE0.out
Expected  Input: [37, 53 49 2 9 9 30 2 35 1 46 39 46 42 33 13 41 35 57 38 59 15 40 18 6 46 30 53 31 34 57 41 20 1 42 59 46 45 ]
Expected Output: [6186, 25130]
Your     Output: [6186, 25130]
Time Cost: 4.828800 ms (4828800 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE1.in &amp; MERGE1.out
Expected  Input: [4, 1 2 3333 2]
Expected Output: [6676, 10010]
Your     Output: [6676, 10010]
Time Cost: 0.929800 ms (929800 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE2.in &amp; MERGE2.out
Expected  Input: [7, 30 35 15 5 10 20 25]
Expected Output: [370, 580]
Your     Output: [370, 580]
Time Cost: 1.354100 ms (1354100 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE3.in &amp; MERGE3.out
Expected  Input: [7, 3 4 5 6 7 8 9]
Expected Output: [116, 187]
Your     Output: [116, 187]
Time Cost: 1.063500 ms (1063500 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE4.in &amp; MERGE4.out
Expected  Input: [30, 3 4 7 11 13 15 18 21 17 14 7 5 8 10 19 16 13 10 7 5 4 3 4 5 6 3 15 3 10 8 ]
Expected Output: [1342, 5318]
Your     Output: [1342, 5318]
Time Cost: 1.857000 ms (1857000 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE5.in &amp; MERGE5.out
Expected  Input: [4, 1 3 15 2 ]
Expected Output: [42, 59]
Your     Output: [42, 59]
Time Cost: 0.901300 ms (901300 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE6.in &amp; MERGE6.out
Expected  Input: [7, 1 7 6 12 3 15 2 ]
Expected Output: [129, 218]
Your     Output: [129, 218]
Time Cost: 1.066700 ms (1066700 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE7.in &amp; MERGE7.out
Expected  Input: [5, 1 1 2 3333 2]
Expected Output: [6680, 13349]
Your     Output: [6680, 13349]
Time Cost: 0.969700 ms (969700 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE8.in &amp; MERGE8.out
Expected  Input: [87, 14 27 48 9 8 14 9 29 25 14 8 30 37 37 4 4 3 6 39 40 19 30 22 37 25 17 41 41 7 5 4 3 10 33 12 28 13 18 42 16 16 33 34 45 16 24 15 38 37 28 36 21 27 30 44 33 6 24 20 6 3 27 33 4 46 42 34 46 14 35 36 25 33 8 12 47 18 7 49 16 3 5 43 28 35 5 33 ]
Expected Output: [12799, 96955]
Your     Output: [12799, 96955]
Time Cost: 6.057900 ms (6057900 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE9.in &amp; MERGE9.out
Expected  Input: [20, 1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11 ]
Expected Output: [864, 2850]
Your     Output: [864, 2850]
Time Cost: 1.526400 ms (1526400 ns)
Accepted.
-----------------------------------------------------
Result Statistics: √ √ √ √ √ √ √ √ √ √
</code></pre>
<h4>Recursive Method</h4>
<h5>Diagram</h5>
<pre><code class="lang-yaml\">Expected  Input: [4, 1 2 3333 2]
Expected Output: [6676, 10010]
</code></pre>
<pre><code class="lang-mermaid">graph TD;
style db2871da fill: gray,stroke: #333,stroke-width: 4px
style 984401db fill: lightgreen,stroke: #333,stroke-width: 4px
style 108f3e6e fill: gray,stroke: #333,stroke-width: 4px
style d053e213 fill: lightgreen,stroke: #333,stroke-width: 4px
style 3a08e73b fill: gray,stroke: #333,stroke-width: 4px
style 905d2093 fill: gray,stroke: #333,stroke-width: 4px
d053e213 --#1L, 3333--&gt; 3a08e73b((2..2&lt;/br&gt;0))
d053e213 --#1R, 2--&gt; 905d2093((3..3&lt;/br&gt;0))
984401db --#2L, 2--&gt; 108f3e6e((1..1&lt;/br&gt;0))
984401db --#2R, 3335--&gt; d053e213((2..3&lt;/br&gt;3335))
style 9a62f0a0 fill: lightgreen,stroke: #333,stroke-width: 4px
style d33c7169 fill: gray,stroke: #333,stroke-width: 4px
style 64212337 fill: gray,stroke: #333,stroke-width: 4px
9a62f0a0 --#3L, 2--&gt; d33c7169((1..1&lt;/br&gt;0))
9a62f0a0 --#3R, 3333--&gt; 64212337((2..2&lt;/br&gt;0))
style c78fd6db fill: gray,stroke: #333,stroke-width: 4px
984401db --#4L, 3335--&gt; 9a62f0a0((1..2&lt;/br&gt;3335))
984401db --#4R, 2--&gt; c78fd6db((3..3&lt;/br&gt;0))
root((root)) --#5L, 1--&gt; db2871da((0..0&lt;/br&gt;0))
root((root)) --#5R, 3337--&gt; 984401db((1..3&lt;/br&gt;6672))
style 4361b325 fill: lightgreen,stroke: #333,stroke-width: 4px
style 1f5338ec fill: gray,stroke: #333,stroke-width: 4px
style c9c46067 fill: gray,stroke: #333,stroke-width: 4px
4361b325 --#6L, 1--&gt; 1f5338ec((0..0&lt;/br&gt;0))
4361b325 --#6R, 2--&gt; c9c46067((1..1&lt;/br&gt;0))
style 6b63e09f fill: lightgray,stroke: #333,stroke-width: 4px
root((root)) --#7L, 3--&gt; 4361b325((0..1&lt;/br&gt;3))
root((root)) --#7R, 3335--&gt; 6b63e09f((2..3&lt;/br&gt;3335))
style 4bd4d793 fill: lightgreen,stroke: #333,stroke-width: 4px
style 2c2b9065 fill: gray,stroke: #333,stroke-width: 4px
style 20a281ee fill: lightgray,stroke: #333,stroke-width: 4px
4bd4d793 --#8L, 1--&gt; 2c2b9065((0..0&lt;/br&gt;0))
4bd4d793 --#8R, 3335--&gt; 20a281ee((1..2&lt;/br&gt;3335))
style 42941b97 fill: lightgray,stroke: #333,stroke-width: 4px
style 7de997a1 fill: gray,stroke: #333,stroke-width: 4px
4bd4d793 --#9L, 3--&gt; 42941b97((0..1&lt;/br&gt;3))
4bd4d793 --#9R, 3333--&gt; 7de997a1((2..2&lt;/br&gt;0))
style 5565dbef fill: gray,stroke: #333,stroke-width: 4px
root((root)) --#10L, 3336--&gt; 4bd4d793((0..2&lt;/br&gt;3339))
root((root)) --#10R, 2--&gt; 5565dbef((3..3&lt;/br&gt;0))
style root fill: lightgreen,stroke: #333,stroke-width: 4px
root((0..3&lt;/br&gt;6676))
</code></pre>
<pre><code class="lang-mermaid">graph TD;
style c39dfc51 fill: gray,stroke: #333,stroke-width: 4px
style 4b5075a2 fill: lightgreen,stroke: #333,stroke-width: 4px
style 9a8edd98 fill: gray,stroke: #333,stroke-width: 4px
style 77669c62 fill: lightgreen,stroke: #333,stroke-width: 4px
style 3525cd7d fill: gray,stroke: #333,stroke-width: 4px
style 27e0a4da fill: gray,stroke: #333,stroke-width: 4px
77669c62 --#11L, 3333--&gt; 3525cd7d((2..2&lt;/br&gt;0))
77669c62 --#11R, 2--&gt; 27e0a4da((3..3&lt;/br&gt;0))
4b5075a2 --#12L, 2--&gt; 9a8edd98((1..1&lt;/br&gt;0))
4b5075a2 --#12R, 3335--&gt; 77669c62((2..3&lt;/br&gt;3335))
style cad53082 fill: lightgreen,stroke: #333,stroke-width: 4px
style 5dec4f10 fill: gray,stroke: #333,stroke-width: 4px
style 57160f17 fill: gray,stroke: #333,stroke-width: 4px
cad53082 --#13L, 2--&gt; 5dec4f10((1..1&lt;/br&gt;0))
cad53082 --#13R, 3333--&gt; 57160f17((2..2&lt;/br&gt;0))
style 43d989e7 fill: gray,stroke: #333,stroke-width: 4px
4b5075a2 --#14L, 3335--&gt; cad53082((1..2&lt;/br&gt;3335))
4b5075a2 --#14R, 2--&gt; 43d989e7((3..3&lt;/br&gt;0))
root((root)) --#15L, 1--&gt; c39dfc51((0..0&lt;/br&gt;0))
root((root)) --#15R, 3337--&gt; 4b5075a2((1..3&lt;/br&gt;6672))
style 59f09ba9 fill: lightgreen,stroke: #333,stroke-width: 4px
style ce2df958 fill: gray,stroke: #333,stroke-width: 4px
style 3b1bc123 fill: gray,stroke: #333,stroke-width: 4px
59f09ba9 --#16L, 1--&gt; ce2df958((0..0&lt;/br&gt;0))
59f09ba9 --#16R, 2--&gt; 3b1bc123((1..1&lt;/br&gt;0))
style 468ac0d5 fill: lightgray,stroke: #333,stroke-width: 4px
root((root)) --#17L, 3--&gt; 59f09ba9((0..1&lt;/br&gt;3))
root((root)) --#17R, 3335--&gt; 468ac0d5((2..3&lt;/br&gt;3335))
style 41c67309 fill: lightgreen,stroke: #333,stroke-width: 4px
style 62aca470 fill: gray,stroke: #333,stroke-width: 4px
style b51c743b fill: lightgray,stroke: #333,stroke-width: 4px
41c67309 --#18L, 1--&gt; 62aca470((0..0&lt;/br&gt;0))
41c67309 --#18R, 3335--&gt; b51c743b((1..2&lt;/br&gt;3335))
style 675fda1c fill: lightgray,stroke: #333,stroke-width: 4px
style 7631db1b fill: gray,stroke: #333,stroke-width: 4px
41c67309 --#19L, 3--&gt; 675fda1c((0..1&lt;/br&gt;3))
41c67309 --#19R, 3333--&gt; 7631db1b((2..2&lt;/br&gt;0))
style c18be7c1 fill: gray,stroke: #333,stroke-width: 4px
root((root)) --#20L, 3336--&gt; 41c67309((0..2&lt;/br&gt;6671))
root((root)) --#20R, 2--&gt; c18be7c1((3..3&lt;/br&gt;0))
root((0..3&lt;/br&gt;10010))
style root fill: lightgreen,stroke: #333,stroke-width: 4px
</code></pre>
<h5>Source</h5>
<pre><code class="lang-cpp">    static int n;
    static int[] sum;
    static int[][] dp;
    static int INF = 0x3f3f3f3f;

    public static int m(int i, int j) {

        /* Base Case */
        if (dp[i][j] != INF) {
            return dp[i][j];
        }

        /* Recursive Case */
        for (int k = i; k &lt; j; k++) {
            // it's also correct: dp[i][j] = Math.min(m(i, j), m(i, k) + m(k + 1, j) + (sum[j + 1] - sum[i]));
            dp[i][j] = Math.min(dp[i][j], m(i, k) + m(k + 1, j) + (sum[j + 1] - sum[i]));
        }
        return dp[i][j];
    }

    public static int M(int i, int j) {

        /* Base Case */
        if (dp[i][j] != -INF) {
            return dp[i][j];
        }

        /* Recursive Case */
        for (int k = i; k &lt; j; k++) {
            dp[i][j] = Math.max(dp[i][j], M(i, k) + M(k + 1, j) + (sum[j + 1] - sum[i]));
        }
        return dp[i][j];
    }

    public static Judger.Pair&lt;Integer, Integer&gt; solve() {

        dp = new int[n][n];
        int min, max;

        /* Min */
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                dp[i][j] = INF;
            }
        }
        for (int i = 0; i &lt; n; i++) {
            dp[i][i] = 0;
        }
        min = m(0, n - 1);

        /* Max */
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                dp[i][j] = -INF;
            }
        }
        for (int i = 0; i &lt; n; i++) {
            dp[i][i] = 0;
        }
        max = M(0, n - 1);

        return new Judger.Pair&lt;&gt;(min, max);
    }

    public static void main(String[] args) {

        for (Scanner scanner : judger) {
            n = scanner.nextInt();
            int[] a = new int[n];
            for (int i = 0; i &lt; n; i++) {
                a[i] = scanner.nextInt();
            }

            // Pre-solve: partial sum
            sum = new int[n + 1];
            sum[0] = 0;
            for (int i = 1; i &lt; sum.length; i++) {
                sum[i] = sum[i - 1] + a[i - 1];
            }

            Judger.Pair&lt;Integer, Integer&gt; answer = solve();
            System.out.printf("%d\n%d", answer.getKey(), answer.getValue());
        }
    }
</code></pre>
<h5>Benchmark</h5>
<pre><code class="lang-yaml">-----------------------------------------------------
Current Case: MERGE0.in &amp; MERGE0.out
Expected  Input: [37, 53 49 2 9 9 30 2 35 1 46 39 46 42 33 13 41 35 57 38 59 15 40 18 6 46 30 53 31 34 57 41 20 1 42 59 46 45 ]
Expected Output: [6186, 25130]
Your     Output: [6186, 25130]
Time Cost: 4.601200 ms (4601200 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE1.in &amp; MERGE1.out
Expected  Input: [4, 1 2 3333 2]
Expected Output: [6676, 10010]
Your     Output: [6676, 10010]
Time Cost: 0.888000 ms (888000 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE2.in &amp; MERGE2.out
Expected  Input: [7, 30 35 15 5 10 20 25]
Expected Output: [370, 580]
Your     Output: [370, 580]
Time Cost: 1.097400 ms (1097400 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE3.in &amp; MERGE3.out
Expected  Input: [7, 3 4 5 6 7 8 9]
Expected Output: [116, 187]
Your     Output: [116, 187]
Time Cost: 1.463500 ms (1463500 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE4.in &amp; MERGE4.out
Expected  Input: [30, 3 4 7 11 13 15 18 21 17 14 7 5 8 10 19 16 13 10 7 5 4 3 4 5 6 3 15 3 10 8 ]
Expected Output: [1342, 5318]
Your     Output: [1342, 5318]
Time Cost: 1.491700 ms (1491700 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE5.in &amp; MERGE5.out
Expected  Input: [4, 1 3 15 2 ]
Expected Output: [42, 59]
Your     Output: [42, 59]
Time Cost: 0.847000 ms (847000 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE6.in &amp; MERGE6.out
Expected  Input: [7, 1 7 6 12 3 15 2 ]
Expected Output: [129, 218]
Your     Output: [129, 218]
Time Cost: 0.783500 ms (783500 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE7.in &amp; MERGE7.out
Expected  Input: [5, 1 1 2 3333 2]
Expected Output: [6680, 13349]
Your     Output: [6680, 13349]
Time Cost: 0.795700 ms (795700 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE8.in &amp; MERGE8.out
Expected  Input: [87, 14 27 48 9 8 14 9 29 25 14 8 30 37 37 4 4 3 6 39 40 19 30 22 37 25 17 41 41 7 5 4 3 10 33 12 28 13 18 42 16 16 33 34 45 16 24 15 38 37 28 36 21 27 30 44 33 6 24 20 6 3 27 33 4 46 42 34 46 14 35 36 25 33 8 12 47 18 7 49 16 3 5 43 28 35 5 33 ]
Expected Output: [12799, 96955]
Your     Output: [12799, 96955]
Time Cost: 3.839300 ms (3839300 ns)
Accepted.
-----------------------------------------------------
Current Case: MERGE9.in &amp; MERGE9.out
Expected  Input: [20, 1 2 3 4 5 6 7 8 9 10 20 19 18 17 16 15 14 13 12 11 ]
Expected Output: [864, 2850]
Your     Output: [864, 2850]
Time Cost: 1.105300 ms (1105300 ns)
Accepted.
-----------------------------------------------------
Result Statistics: √ √ √ √ √ √ √ √ √ √
</code></pre>
