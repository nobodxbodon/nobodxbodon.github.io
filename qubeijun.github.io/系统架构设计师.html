<h2><a href="https://github.com/qubeijun/qubeijun.github.io/blob/master/source/_posts/gwy/系统架构设计师.md">仓库源文</a>，<a href="https://qubeijun.github.io/posts/21885">站点原文</a></h2>
<p><strong>一、计算机基础</strong></p>
<p><strong>自然连接</strong></p>
<p><strong>属性列相同只显示一次</strong></p>
<p><strong>属性列相同的行相同的记录</strong></p>
<table>
<thead><tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">A</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">a</td>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">d</td>
<td style="text-align:center">d</td>
<td style="text-align:center">f</td>
<td style="text-align:center">g</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
<td style="text-align:center">e</td>
<td style="text-align:center">b</td>
<td style="text-align:center">d</td>
<td style="text-align:center">g</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">f</td>
<td style="text-align:center">g</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>{% asset_img jiagou1.png %}{% asset_img jiagou59.png %}</p>
<ul>
<li><strong>AI芯片的技术架构GPU、FPGA、ASIC、TPU</strong></li>
<li><strong>POP3，邮件接收协议，缺省端口110</strong></li>
<li><strong>SMTP，邮件发送协议，缺省端口25</strong></li>
<li><strong>HTTP，超文本传输协议，缺省端口80</strong></li>
<li><strong>IMAP，交互式邮件存取协议，缺省端口143</strong></li>
</ul>
<p>{% asset_img jiagou2.png %}{% asset_img jiagou60.png %}{% asset_img jiagou61.png %}</p>
<p><strong>1、先找出从未在右边出现过的属性，必然是候选键之一。</strong></p>
<p><strong>2、以该属性位基础，根据依赖集依次扩展，看能否遍历所有属性，将无法遍历的加入候选键中。</strong></p>
<p>{% asset_img jiagou3.png %}</p>
<p><strong>操作系统</strong></p>
<ul>
<li><strong>PV操作</strong></li>
<li><strong>Passeren阻塞  Vrijgeven唤醒</strong></li>
<li><strong>头只有V无P</strong></li>
<li><strong>尾只有P无V</strong></li>
<li><strong>选AC</strong></li>
</ul>
<p>{% asset_img jiagou4.png %}</p>
<p>{% asset_img jiagou5.png %}</p>
<p>{% asset_img jiagou6.png %}</p>
<p>{% asset_img jiagou7.png %}</p>
<p><strong>文件管理</strong></p>
<p>{% asset_img jiagou8.png %}</p>
<p><strong>一级间接索引，保存一个索引表，代表5个地址项，对应5个物理块</strong></p>
<p><strong>二级间接索引，保存5个索引表，每个索引表代表5个物理块</strong></p>
<p>{% asset_img jiagou9.png %}</p>
<p><strong>最大长度：6 <em> 4 + 1024 </em> 4 + 1024 <em> 1024 </em> 4 = 4198424</strong></p>
<p><strong>一级间接索引是一个磁盘索引块4k，每个地址项大小4字节，所以一共4*1024B/4B=1024块地址项</strong></p>
<p><strong>直接索引：对应逻辑块号0-5</strong></p>
<p><strong>一级间接索引：6-1029</strong></p>
<p><strong>二级间接索引：1030-</strong></p>
<p><strong>计算机网络</strong></p>
<p>{% asset_img jiagou10.png %}</p>
<p>{% asset_img jiagou11.png %}</p>
<p>{% asset_img jiagou12.png %}</p>
<p><strong>二、信息系统基础</strong></p>
<p><strong>三、信息安全</strong></p>
<p><strong>四、软件工程</strong></p>
<p><strong>五、系统分析</strong></p>
<p>{% asset_img jiagou13.png %}</p>
<p><strong>六、系统设计</strong></p>
<p><strong>七、数据库</strong></p>
<p>{% asset_img jiagou14.png %}</p>
<p>{% asset_img jiagou15.png %}</p>
<p>{% asset_img jiagou16.png %}</p>
<p>{% asset_img jiagou17.png %}</p>
<p>{% asset_img jiagou18.png %}</p>
<p>{% asset_img jiagou19.png %}</p>
<p><strong>八、系统架构设计</strong></p>
<p><strong>九、软件可靠性设计</strong></p>
<p>4/5/6/7/8  案例题</p>
<p><strong>十、大数据架构设计</strong></p>
<p><strong>十一、未来信息技术</strong></p>
<p><strong>十二、运筹学</strong></p>
<p><strong>十三、知识产权</strong></p>
<p><strong>十四、案例分析</strong></p>
<p>架构设计方向</p>
<p>{% asset_img jiagou20.png %}</p>
<p>{% asset_img jiagou21.png %}</p>
<p>{% asset_img jiagou22.png %}</p>
<p>a需求、b安全性、c可用性、d需求、e可用性、f性能、g可修改、h安全性、i可修改、j性能、k需求、l需求</p>
<p>{% asset_img jiagou23.png %}</p>
<p>{% asset_img jiagou24.png %}</p>
<p>{% asset_img jiagou25.png %}</p>
<p>{% asset_img jiagou26.png %}</p>
<p>{% asset_img jiagou27.png %}</p>
<p>{% asset_img jiagou28.png %}</p>
<p>{% asset_img jiagou29.png %}</p>
<p>{% asset_img jiagou30.png %}</p>
<p>{% asset_img jiagou31.png %}</p>
<p>{% asset_img jiagou32.png %}</p>
<p>{% asset_img jiagou33.png %}</p>
<p>{% asset_img jiagou34.png %}</p>
<p>{% asset_img jiagou35.png %}</p>
<p>{% asset_img jiagou36.png %}</p>
<p>{% asset_img jiagou37.png %}</p>
<p>{% asset_img jiagou38.png %}</p>
<p>{% asset_img jiagou39.png %}</p>
<p>{% asset_img jiagou40.png %}</p>
<p>{% asset_img jiagou41.png %}</p>
<p>{% asset_img jiagou42.png %}</p>
<p>{% asset_img jiagou43.png %}</p>
<p>{% asset_img jiagou44.png %}</p>
<p>{% asset_img jiagou45.png %}</p>
<p>{% asset_img jiagou46.png %}</p>
<p>{% asset_img jiagou47.png %}</p>
<p>{% asset_img jiagou48.png %}</p>
<p>{% asset_img jiagou49.png %}</p>
<p>{% asset_img jiagou50.png %}</p>
<p>{% asset_img jiagou51.png %}</p>
<p>{% asset_img jiagou52.png %}</p>
<p>{% asset_img jiagou53.png %}</p>
<p>{% asset_img jiagou54.png %}</p>
<p><strong>论文</strong></p>
<p>{% asset_img jiagou55.png %}</p>
<p><strong>质量属性</strong></p>
<p>性能、安全性、可修改性，可用性</p>
<p><strong>质量特性</strong></p>
<p>敏感点：为了实现某种特定的质量属性，一个或多个构件所具有的特性。</p>
<p>权衡点：指影响多个质量特性，并对多个质量特性来说都是敏感点的质量特性。</p>
<p>风险：不以标准术语出现。某些做法有一些隐患可能导致一些问题。</p>
<p>非风险：某些做法是可行的，可接受的。</p>
<p><strong>Redis</strong></p>
<p>string、hash、set、zset、list</p>
<p>为了保证数据的一致性，读写数据的基本操作步骤为：</p>
<p>读数据</p>
<p>1、根据key读缓存；</p>
<p>2、读取成功则直接返回；</p>
<p>3、若key不在缓存中，根据key读数据库；</p>
<p>4、读取成功后，写缓存；</p>
<p>5、成功返回。</p>
<p>写数据</p>
<p>1、根据key值写数据库；</p>
<p>2、成功后更新缓存key值；</p>
<p>3、成功返回。</p>
<p>过期策略</p>
<table>
<thead><tr>
<th>策略</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>定时删除</td>
<td>在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</td>
<td>保证内存被尽快释放</td>
<td>1、若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，会延误业务的执行&lt;br/&gt;2、定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</td>
</tr>
<tr>
<td>惰性删除</td>
<td>key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</td>
<td>删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，对CPU时间的占用比较少。</td>
<td>若大量的key在超出超时时间后，很久一段时间内，都没有被请求过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</td>
</tr>
<tr>
<td>定期删除</td>
<td>每隔一段时间执行一次删除过期key操作</td>
<td>1、通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用（避免"定时删除"的缺点）&lt;br/&gt;2、定期删除过期key（避免"惰性删除"的缺点）</td>
<td>1、在内存使用方面，不如"定时删除"&lt;br/&gt;2、在CPU时间方面，不如"惰性删除"</td>
</tr>
</tbody>
</table>
<p>内存淘汰机制
| 机制 | 描述 |
| --- | --- |
| volatile-lru&lt;br/&gt;最近最少使用 | 从已设置过期时间的key中，移出最近最少使用的key进行淘汰 |
| volatile-lfu&lt;br/&gt;最不经常使用 | 从已设置过期时间的key中选择最不经常使用的进行淘汰。 |
| volatile-random&lt;br/&gt;随机淘汰算法 | 从已设置过期时间的key中随机选择key淘汰。 |
| volatile-ttl&lt;br/&gt;生存时间淘汰 | 从已设置过期时间的key中，移出将要过期的key。 |
| allkeys-lru | 从所有key中选择最近最少使用的进行淘汰 |
| allkeys-lfu | 从所有key中选择最不经常使用的进行淘汰。 |
| allkeys-random | 从所有key中随机选择key进行淘汰 |</p>
<p>数据持久化</p>
<table>
<thead><tr>
<th></th>
<th>RDB内存快照（RedisDataBase）</th>
<th>AOF日志（Append Only  Flie）</th>
</tr>
</thead>
<tbody>
<tr>
<td>说明</td>
<td>把当前内存中的数据集快照写入磁盘（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</td>
<td>通过持续不断地保存Redis服务器所执行的更新命令来记录数据库状态，类似mysql的binlog。恢复数据时需要从头开始回放更新命令。</td>
</tr>
<tr>
<td>磁盘刷新频率</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>文件大小</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>数据恢复效率</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>数据安全</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
<p>Redis缓存异常问题</p>
<p>1、缓存穿透</p>
<p>{% asset_img jiagou56.png %}{% asset_img jiagou62.png %}</p>
<p>2、缓存雪崩</p>
<p>{% asset_img jiagou57.png %}{% asset_img jiagou63.png %}</p>
<p>3、缓存击穿</p>
<p>{% asset_img jiagou58.png %}{% asset_img jiagou64.png %}</p>
