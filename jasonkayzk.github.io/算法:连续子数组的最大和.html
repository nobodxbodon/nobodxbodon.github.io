<h2>原文：<a href="https://jasonkayzk.github.io/1996/07/27/%E7%AE%97%E6%B3%95-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">算法:连续子数组的最大和</a></h2>
<hr/>
<h2>title: '算法:连续子数组的最大和'
cover: https://img.paulzzh.com/touhou/random?39
categories: 算法题目
date: 1996-07-27 08:00:00
tags: [算法题目, 数组, 动态规划]
toc: true</h2>
<p>&lt;br/&gt;</p>
<p>&lt;!--more--&gt;</p>
<h2>连续子数组的最大和</h2>
<p><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">连续子数组的最大和</a></p>
<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:</p>
<p>在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？</p>
<p>例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？</p>
<p>(子向量的长度至少是1)</p>
<hr/>
<h3>分析</h3>
<p>简单的动态规划, 其中dp[i]表示从a[0]~a[i]的连续子数组的最大值.</p>
<p>则可知:</p>
<p>dp[0] = a[0];</p>
<p>dp[i] = Math.max(dp[i-1] + a[i], a[i])</p>
<p>而结果等于max(dp[i])</p>
<hr/>
<h3>代码</h3>
<pre><code class="language-java">public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0) return 0;

        int curMax = array[0], len = array.length, res = array[0];

        for (int i = 1; i &lt; len; i++) {
            curMax = Math.max(curMax + array[i], array[i]);
            res = Math.max(res, curMax);
        }
        return res;
    }
}
</code></pre>
