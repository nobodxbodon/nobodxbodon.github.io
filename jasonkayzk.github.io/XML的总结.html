<h2><a href="https://github.com/jasonkayzk/jasonkayzk.github.io/blob/master/source/_posts/XML的总结.md">仓库源文</a>，<a href="https://jasonkayzk.github.io/2019/12/05/XML的总结">站点原文</a></h2>
<hr/>
<p>title: XML的总结
toc: true
date: 2019-12-05 17:22:35
cover: <a href="https://img.paulzzh.com/touhou/random?9">https://img.paulzzh.com/touhou/random?9</a>
categories: 技术杂谈
tags: XML</p>
<h2>description: 想必大家对XML已经很熟悉了吧. 最近复习的时候, 发现XML远没有自己想的那么简单, 所以就抽出一点时间来总结一下XML中一些常识性的或者冷门的知识</h2>
<p>想必大家对XML已经很熟悉了吧. 最近复习的时候, 发现XML远没有自己想的那么简单, 所以就抽出一点时间来总结一下XML中一些常识性的或者冷门的知识</p>
<p>&lt;br/&gt;</p>
&lt;!--more--&gt;

<h2>XML简介</h2>
<p>XML 的设计宗旨是<em>传输数据</em>，而非显示数据, 这也意味着<strong>XML 是不作为的, 仅仅是纯文本</strong></p>
<p>XML 标签没有被预定义, 与HTML不同, 您需要<em>自行定义标签</em></p>
<p>XML 被设计为具有<em>自我描述性</em></p>
<p>XML 是 <em>W3C 的推荐标准</em></p>
<p>&lt;br/&gt;</p>
<h2>XML的用途</h2>
<p><strong>① XML 把数据从代码中分离</strong></p>
<p>通过 XML，数据能够存储在独立的 XML 文件中, 这样你就可以专注于代码编写, 并确保修改底层数据不再需要对代码进行任何的改变</p>
<p><strong>② 简化数据共享</strong></p>
<p>XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法</p>
<p><strong>③ 简化数据传输</strong></p>
<p>可以在不兼容的系统之间轻松地交换数据</p>
<p><strong>④ 简化平台的变更</strong></p>
<p>XML 数据以文本格式存储。这使得 XML 在不损失数据的情况下，更容易扩展或升级到新的操作系统、新应用程序或新的浏览器</p>
<p><strong>⑤ XML 用于创建新的 Internet 语言</strong></p>
<p>很多新的 Internet 语言是通过 XML 创建的：</p>
<p>其中的例子包括：</p>
<ul>
<li>XHTML - 最新的 HTML 版本</li>
<li>WSDL - 用于描述可用的 web service</li>
<li>WAP 和 WML - 用于手持设备的标记语言</li>
<li>RSS - 用于 RSS feed 的语言</li>
<li>RDF 和 OWL - 用于描述资源和本体</li>
<li>SMIL - 用于描述针针对 web 的多媒体</li>
</ul>
<p>&lt;br/&gt;</p>
<h2>树结构</h2>
<p>XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”</p>
<p>XML 使用简单的具有自我描述性的语法：</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don't forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre>
<p>第一行是 XML 声明: 它定义 XML 的版本 (1.0) 和所使用的编码</p>
<blockquote>&lt;BR/&gt;

<p><strong>备注:</strong></p>
<p>&lt;font color="#ff0000"&gt;**XML 文档必须包含*根元素*: 该元素是所有其他元素的父元素**&lt;/font&gt;</p>
<p>&lt;font color="#ff0000"&gt;**所有元素均可拥有子元素**&lt;/font&gt;</p>
<p>XML 文档中的元素形成了一棵文档树, 这棵树从根部开始，并扩展到树的最底端</p>
</blockquote>
<p>&lt;br/&gt;</p>
<h2>XML语法规则</h2>
<p><strong>① XML 文档必须包含根元素</strong></p>
<p><strong>② 所有 XML 元素都须有关闭标签</strong></p>
<p><strong>③ XML 标签对大小写敏感, 标签 <code>&lt;Letter&gt;</code> 与标签<code>&lt;letter&gt;</code> 是不同的</strong></p>
<p><strong>④ XML 的属性值必须加引号:</strong></p>
<pre><code class="lang-xml">&lt;!-- 错误 --&gt;
&lt;note date=08/08/2008&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;/note&gt; 

&lt;!-- 正确 --&gt;
&lt;note date="08/08/2008"&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;/note&gt;
</code></pre>
<p><strong>⑤ 在 XML 中，空格会被保留</strong></p>
<p><strong>⑥ XML 以 LF 存储换行</strong></p>
<blockquote><p>&lt;br/&gt;</p>
<p><strong>备注:</strong></p>
<p>在 <strong>Windows 应用程序中，换行通常以一对字符来存储：回车符 (CR) 和换行符 (LF)</strong>, 这对字符与打字机设置新行的动作有相似之处</p>
<p>在 <strong>Unix(Linux) 应用程序中，新行以 LF 字符存储</strong></p>
<p>而 <strong>Macintosh 应用程序使用 CR 来存储新行</strong></p>
</blockquote>
<p>&lt;br/&gt;</p>
<h2>XML元素</h2>
<p><em>XML 元素</em>指的是从（且包括）开始标签直到（且包括）结束标签的部分</p>
<p>元素可包含其他元素、文本或者两者的混合物, 元素也可以拥有属性</p>
<p>例:</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;bookstore&gt;
    &lt;book category="CHILDREN"&gt;
        &lt;title&gt;Harry Potter&lt;/title&gt;
        &lt;author&gt;J K. Rowling&lt;/author&gt;
        &lt;year&gt;2005&lt;/year&gt;
        &lt;price&gt;29.99&lt;/price&gt;
    &lt;/book&gt;
    &lt;book category="WEB"&gt;
        &lt;title&gt;Learning XML&lt;/title&gt;
        &lt;author&gt;Erik T. Ray&lt;/author&gt;
        &lt;year&gt;2003&lt;/year&gt;
        &lt;price&gt;39.95&lt;/price&gt;
    &lt;/book&gt;
&lt;/bookstore&gt;
</code></pre>
<p>在上例中:</p>
<p><code>&lt;bookstore&gt;</code> 和 <code>&lt;book&gt;</code> 都拥有<em>元素内容</em>，因为它们包含了其他元素</p>
<p><code>&lt;author&gt;</code>只有<em>文本内容</em>，因为它仅包含文本</p>
<p><code>&lt;book&gt;</code> 元素拥有<em>属性</em> (category="CHILDREN")</p>
<p>&lt;br/&gt;</p>
<p><strong>命名规则</strong></p>
<p>XML 元素必须遵循以下命名规则：</p>
<ul>
<li>名称可以含字母、数字以及其他的字符</li>
<li>名称不能以数字或者标点符号开始 </li>
<li>名称不能以字符 “xml”（或者 XML、Xml）开始 </li>
<li>名称不能包含空格 </li>
</ul>
<p>&lt;br/&gt;</p>
<h2>XML 属性</h2>
<p><strong>XML 元素可以在开始标签中包含属性，属性 (Attribute) 提供关于元素的额外（附加）信息</strong></p>
<p><strong>属性通常提供不属于数据组成部分的信息</strong></p>
<p>在下面的例子中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要：</p>
<pre><code class="lang-xml">&lt;file type="gif"&gt;computer.gif&lt;/file&gt;
</code></pre>
<blockquote><p>&lt;br/&gt;</p>
<p><strong>注意: </strong></p>
<p><strong>① XML 属性必须加引号</strong></p>
<p><strong>② 如果属性值本身包含双引号，那么有必要使用单引号包围它(或使用实体引用转义)</strong></p>
</blockquote>
<p>&lt;br/&gt;</p>
<p>因使用属性而引起的一些问题：</p>
<ul>
<li>属性无法包含多重的值（元素可以）</li>
<li>属性无法描述树结构（元素可以）</li>
<li>属性不易扩展（为未来的变化）</li>
<li>属性难以阅读和维护</li>
</ul>
<p>请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息</p>
<blockquote><p>&lt;br/&gt;</p>
<p><strong>总结: 元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素</strong></p>
</blockquote>
<p>&lt;br/&gt;</p>
<h2>XML验证</h2>
<p><strong>① 使用DTD验证</strong></p>
<p>合法的 XML 文档是“形式良好”的 XML 文档，同样遵守文档类型定义 (DTD) 的语法规则：</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE note SYSTEM "Note.dtd"&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don't forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre>
<p>在上例中，DOCTYPE 声明是对外部 DTD 文件的引用</p>
<p>下面的段落展示了这个文件的内容:</p>
<pre><code class="lang-dtd">&lt;!DOCTYPE note [
  &lt;!ELEMENT note (to,from,heading,body)&gt;
  &lt;!ELEMENT to      (#PCDATA)&gt;
  &lt;!ELEMENT from    (#PCDATA)&gt;
  &lt;!ELEMENT heading (#PCDATA)&gt;
  &lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
</code></pre>
<p>DTD 的作用是定义 XML 文档的结构, 它使用一系列合法的元素来定义文档结构</p>
<blockquote><p>&lt;br/&gt;</p>
<p><strong>扩展:</strong></p>
<p><strong>也可以直接在xml文件中声明dtd</strong>, 如:</p>
<pre><code class="lang-xml-dtd">&lt;?xml version="1.0" ?&gt; 
&lt;!DOCTYPE note [
 &lt;!ELEMENT note (to,from,heading,body)&gt;
 &lt;!ELEMENT to      (#PCDATA)&gt;
 &lt;!ELEMENT from    (#PCDATA)&gt;
 &lt;!ELEMENT heading (#PCDATA)&gt;
 &lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt; 
&lt;from&gt;John&lt;/Ffrom&gt; 
&lt;heading&gt;Reminder&lt;/heading&gt; 
&lt;body&gt;Dont forget the meeting!&lt;/body&gt; 
&lt;/note&gt;
</code></pre>
</blockquote>
<p>&lt;br/&gt;</p>
<p><strong>② 使用XML Schema验证</strong></p>
<p>W3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema:</p>
<pre><code class="lang-xml-dtd">&lt;xs:element name="note"&gt;
&lt;xs:complexType&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name="to"      type="xs:string"/&gt;
    &lt;xs:element name="from"    type="xs:string"/&gt;
    &lt;xs:element name="heading" type="xs:string"/&gt;
    &lt;xs:element name="body"    type="xs:string"/&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
<blockquote><p>&lt;br/&gt;</p>
<p><strong>扩展: XML 错误会终止您的程序</strong></p>
<p>&lt;font color="#ff0000"&gt;**XML 文档中的错误会终止你的 XML 程序!**&lt;/font&gt;</p>
<p>W3C 的 XML 规范声明：<strong>如果 XML 文档存在错误，那么程序就不应当继续处理这个文档。理由是，XML 软件应当轻巧，快速，具有良好的兼容性</strong></p>
<p>如果使用 HTML，创建包含大量错误的文档是有可能的（比如你忘记了结束标签）, 其中一个主要的原因是 HTML 浏览器相当臃肿，兼容性也很差，并且它们有自己的方式来确定当发现错误时文档应该显示为什么样子</p>
</blockquote>
<p>&lt;br/&gt;</p>
<h2>查看 XML 文件</h2>
<p>在所有现代浏览器中，均能够查看原始的 XML 文件, 但不要指望 XML 文件会直接显示为 HTML 页面</p>
<p>并且<strong>如果浏览器打开了某个有错误的 XML 文件，那么它会报告这个错误</strong></p>
<blockquote><p>&lt;br/&gt;</p>
<p><strong>为什么 XML 会这样显示？</strong></p>
<p>XML 文档不会携带有关如何显示数据的信息</p>
<p>由于 XML 标签由 XML 文档的作者“发明”，浏览器无法确定像 <code>&lt;table&gt;</code> 这样一个标签究竟描述一个 HTML 表格还是一个餐桌</p>
<p>在没有任何有关如何显示数据的信息的情况下，大多数的浏览器都会仅仅把 XML 文档显示为源代码</p>
</blockquote>
<p>&lt;br/&gt;</p>
<h2>XML 命名空间（XML Namespaces）</h2>
<p>XML 命名空间提供避免元素命名冲突的方法</p>
<p>在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突</p>
<p>例如, 这个 XML 文档携带着某个表格中的信息：</p>
<pre><code class="lang-xml">&lt;table&gt;
   &lt;tr&gt;
   &lt;td&gt;Apples&lt;/td&gt;
   &lt;td&gt;Bananas&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>另一个XML 文档携带有关桌子的信息（一件家具）：</p>
<pre><code class="lang-xml">&lt;table&gt;
   &lt;name&gt;African Coffee Table&lt;/name&gt;
   &lt;width&gt;80&lt;/width&gt;
   &lt;length&gt;120&lt;/length&gt;
&lt;/table&gt;
</code></pre>
<p>假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的<code>&lt;table&gt;</code> 元素，就会发生命名冲突. 此时XML 解析器无法确定如何处理这类冲突</p>
<p>&lt;br/&gt;</p>
<p><strong>① 使用前缀来避免命名冲突</strong></p>
<pre><code class="lang-xml">&lt;!-- 此文档带有某个表格中的信息 --&gt;
&lt;h:table&gt;
   &lt;h:tr&gt;
   &lt;h:td&gt;Apples&lt;/h:td&gt;
   &lt;h:td&gt;Bananas&lt;/h:td&gt;
   &lt;/h:tr&gt;
&lt;/h:table&gt;

&lt;!-- 此 XML 文档携带着有关一件家具的信息 --&gt;
&lt;f:table&gt;
   &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;
   &lt;f:width&gt;80&lt;/f:width&gt;
   &lt;f:length&gt;120&lt;/f:length&gt;
&lt;/f:table&gt;
</code></pre>
<p>通过使用前缀，我们创建了两种不同类型的 <code>&lt;table&gt;</code> 元素</p>
<p>&lt;br/&gt;</p>
<p><strong>② 使用命名空间（Namespaces）</strong></p>
<pre><code class="lang-xml">&lt;!-- 此文档带有某个表格中的信息 --&gt;
&lt;h:table xmlns:h="http://www.w3.org/TR/html4/"&gt;
   &lt;h:tr&gt;
   &lt;h:td&gt;Apples&lt;/h:td&gt;
   &lt;h:td&gt;Bananas&lt;/h:td&gt;
   &lt;/h:tr&gt;
&lt;/h:table&gt;

&lt;!-- 此 XML 文档携带着有关一件家具的信息 --&gt;
&lt;f:table xmlns:f="http://www.w3school.com.cn/furniture"&gt;
   &lt;f:name&gt;African Coffee Table&lt;/f:name&gt;
   &lt;f:width&gt;80&lt;/f:width&gt;
   &lt;f:length&gt;120&lt;/f:length&gt;
&lt;/f:table&gt;
</code></pre>
<p>与仅仅使用前缀不同，我们为<code>&lt;table&gt;</code> 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称(类似于Java中的包名)</p>
<p>&lt;br/&gt;</p>
<p><strong>XML Namespace (xmlns) 属性</strong></p>
<p>XML 命名空间属性被放置于元素的开始标签之中，并使用以下的语法：</p>
<pre><code class="lang-xml">xmlns:namespace-prefix="namespaceURI"
</code></pre>
<p><strong>当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联</strong></p>
<blockquote><p>&lt;br/&gt;</p>
<p><strong>注释：用于标示命名空间的地址不会被解析器用于查找信息, 其惟一的作用是赋予命名空间一个惟一的名称</strong></p>
<p>不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息</p>
</blockquote>
<p>&lt;br/&gt;</p>
<p><strong>默认的命名空间（Default Namespaces）</strong></p>
<p>&lt;font color="#ff0000"&gt;为元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作&lt;/font&gt;</p>
<p>使用下面的语法：</p>
<pre><code class="lang-xml">xmlns="namespaceURI"
</code></pre>
<p>&lt;br/&gt;</p>
<h2>XML CDATA</h2>
<p>&lt;font color="#ff0000"&gt;**所有 XML 文档中的文本均会被解析器解析, 只有 CDATA 区段（CDATA section）中的文本会被解析器忽略**&lt;/font&gt;</p>
<h3>PCDATA</h3>
<p>PCDATA 指的是<em>被解析的字符数据</em>（Parsed Character Data）</p>
<p>XML 解析器通常会解析 XML 文档中所有的文本</p>
<p><strong>当某个 XML 元素被解析时，其标签之间的文本也会被解析：</strong></p>
<pre><code>&lt;message&gt;此文本也会被解析&lt;/message&gt;
</code></pre>
<p>解析器之所以这么做是因为 XML 元素可包含其他元素，就像这个例子中，其中的 <code>&lt;name&gt;</code> 元素包含着另外的两个元素(first 和 last)：</p>
<pre><code>&lt;name&gt;&lt;first&gt;Bill&lt;/first&gt;&lt;last&gt;Gates&lt;/last&gt;&lt;/name&gt;
</code></pre>
<p>而解析器会把它分解为像这样的子元素：</p>
<pre><code>&lt;name&gt;
   &lt;first&gt;Bill&lt;/first&gt;
   &lt;last&gt;Gates&lt;/last&gt;
&lt;/name&gt;
</code></pre>
<p>&lt;br/&gt;</p>
<h3>CDATA</h3>
<p>术语 CDATA 指的是<strong>不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）</strong></p>
<p>在 <strong>XML 元素中，"&lt;" 和 "&amp;" 是非法的</strong></p>
<p>&lt;font color="#ff0000"&gt;**"&lt;" 会产生错误，因为解析器会把该字符解释为新元素的开始**&lt;/font&gt;</p>
<p>&lt;font color="#ff0000"&gt;**"&amp;" 也会产生错误，因为解析器会把该字符解释为字符实体的开始**&lt;/font&gt;</p>
<p>某些文本，比如 JavaScript 代码，包含大量 "&lt;" 或 "&amp;" 字符, 为了避免错误，可以将脚本代码定义为 CDATA</p>
<p>CDATA 部分中的所有内容都会被解析器忽略</p>
<p>CDATA 部分由<code>&lt;![CDATA[</code>开始，由 <code>]]&gt;</code> 结束：</p>
<pre><code class="lang-xml">&lt;script&gt;
&lt;![CDATA[
function matchwo(a,b) {
    if (a &lt; b &amp;&amp; a &lt; 0) then {
      return 1;
     }
    else {
      return 0;
    }
}
]]&gt;
&lt;/script&gt;
</code></pre>
<p>在上面的例子中，解析器会忽略 CDATA 部分中的所有内容</p>
<blockquote><p>&lt;br/&gt;</p>
<p><strong>关于 CDATA 部分的注释:</strong></p>
<ul>
<li><p><strong>CDATA 部分不能包含字符串 "]]&gt;", 也不允许嵌套的 CDATA 部分</strong></p>
</li>
<li><p><strong>标记 CDATA 部分结尾的 "]]&gt;" 不能包含空格或折行</strong></p>
</li>
</ul>
</blockquote>
<p>&lt;br/&gt;</p>
