<h2><a href="https://github.com/jasonkayzk/jasonkayzk.github.io/blob/master/source/_posts/算法-包含min函数的栈.md">仓库源文</a>，<a href="https://jasonkayzk.github.io/1996/07/27/算法-包含min函数的栈">站点原文</a></h2>
<hr/>
<p>title: '算法:包含min函数的栈'
cover: <a href="https://img.paulzzh.com/touhou/random?29">https://img.paulzzh.com/touhou/random?29</a>
categories: 算法题目
toc: true
date: 1996-07-27 08:00:00</p>
<h2>tags: [算法题目, 栈]</h2>
<p>&lt;br/&gt;</p>
&lt;!--more--&gt;

<h2>包含min函数的栈</h2>
<p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">包含min函数的栈</a></p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<p>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p>
<hr/>
<h3>分析</h3>
<p>设定两个栈stack和minStack</p>
<ul>
<li>入栈: 如果当前minStack为空或者入栈元素小于等于栈顶元素则入minStack; 而stack无论何时都会入栈</li>
<li>出栈: 如果当前出栈元素为minStack.peak, 则minStack出栈; 而stack无论何时都会出栈;</li>
</ul>
<p>由于以上两点, 保证了minStack.peak即为当前栈中的min</p>
<hr/>
<h3>代码</h3>
<pre><code class="lang-java">import java.util.Stack;

public class Solution {

    private static Stack&lt;Integer&gt; stack;

    private static Stack&lt;Integer&gt; minStack;

    static {
        stack = new Stack&lt;&gt;();
        minStack = new Stack&lt;&gt;();
    }

    public void push(int node) {
        stack.push(node);
        if (minStack.isEmpty() || node &lt;= minStack.peek()) {
            minStack.push(node);
        }
    }

    public void pop() {
        if (stack.peek() == minStack.peek()) {
            minStack.pop();
        }
        stack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int min() {
        return minStack.peek();
    }
}
</code></pre>
