<h2><a href="https://github.com/jasonkayzk/jasonkayzk.github.io/blob/master/source/_posts/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.md">仓库源文</a>，<a href="https://jasonkayzk.github.io/1996/07/27/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">站点原文</a></h2>
<hr/>
<h2>title: '算法:字符串的排列'
cover: https://img.paulzzh.com/touhou/random?36
categories: 算法题目
date: 1996-07-27 08:00:00
tags: [算法题目, 字符串, 回溯法]
toc: true</h2>
<p>&lt;br/&gt;</p>
<p>&lt;!--more--&gt;</p>
<h2>字符串的排列</h2>
<p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">字符串的排列</a></p>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。</p>
<p>例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<hr/>
<h3>分析</h3>
<p>本质上是求组成字符串的字符能组成的全排列;</p>
<p>使用回溯法:</p>
<p>通过交换字符串对应的位置进行字符串构建, 而[start, len - 1]是还未使用的字符</p>
<p>最后的结果放在TreeMap中, 保证结果是按字典顺序排列的;</p>
<hr/>
<h3>代码</h3>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.TreeSet;
public class Solution {
    public ArrayList&lt;String&gt; Permutation(String str) {
        TreeSet&lt;String&gt; res = new TreeSet&lt;&gt;();
        if (str == null || str.length() == 0) return new ArrayList&lt;&gt;();
        helper(str.toCharArray(), 0, res);
        return new ArrayList&lt;&gt;(res);
    }

    private void helper(char[] arr, int start, TreeSet&lt;String&gt; res) {
        if (start == arr.length - 1) {
            res.add(new String(arr));
            return;
        }

        for (int i= start; i &lt; arr.length; ++i) {
            swap(arr, start, i);
            helper(arr, start + 1, res);
            swap(arr, start, i);
        }
    }

    private void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
</code></pre>
