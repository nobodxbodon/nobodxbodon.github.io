<h2><a href="https://github.com/jasonkayzk/jasonkayzk.github.io/blob/master/source/_posts/mini-redis项目-3-连接层.md">仓库源文</a>，<a href="https://jasonkayzk.github.io/2022/12/06/mini-redis项目-3-连接层">站点原文</a></h2>
<p>上一篇文章 <a href="https://jasonkayzk.github.io/2022/12/05/mini-redis项目-2-存储层/">《mini-redis项目-2-存储层》</a> 中讲解了mini-redis数据存储层的实现，这一篇在这个基础之上，讲解连接层的实现；</p>
<p>连接层负责建立服务端和客户端之间的连接，通过tokio框架我们可以异步的处理连接；</p>
<p>源代码：</p>
<ul>
<li><a href="https://github.com/JasonkayZK/mini-redis">https://github.com/JasonkayZK/mini-redis</a></li>
</ul>
<p>系列文章：</p>
<ul>
<li><a href="https://jasonkayzk.github.io/2022/12/05/mini-redis项目-1-简介/">《mini-redis项目-1-简介》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/05/mini-redis项目-2-存储层/">《mini-redis项目-2-存储层》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/05/mini-redis项目-3-连接层/">《mini-redis项目-3-连接层》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/06/mini-redis项目-4-服务端/">《mini-redis项目-4-服务端》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/07/mini-redis项目-5-客户端/">《mini-redis项目-5-客户端》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/07/mini-redis项目-6-测试与示例/">《mini-redis项目-6-测试与示例》</a></li>
</ul>
<p>&lt;br/&gt;</p>
&lt;!--more--&gt;

<h1><strong>mini-redis项目-3-连接层</strong></h1>
<p>连接层主要是屏蔽客户端与服务端之间的底层通信协议，并处理两端之间连接的建立、断开等；</p>
<h2><strong>Redis序列化通信协议</strong></h2>
<h3><strong>RESP简介</strong></h3>
<p>和其他的通信协议类似，客户端和服务端之间也需要定义一个通信协议规则才能进行通信；</p>
<p>Redis 中的通信协议被称为：RESP，即：Redis serialization protocol (RESP)</p>
<p>官方文档如下：</p>
<ul>
<li><a href="https://redis.io/docs/reference/protocol-spec/">https://redis.io/docs/reference/protocol-spec/</a></li>
</ul>
<p>这个通信协议的优势：</p>
<ul>
<li>Simple to implement.</li>
<li>Fast to parse.</li>
<li>Human readable.</li>
</ul>
<p>RESP 可以序列化不同的数据类型，如整数，字符串和数组；同时，错误也有特定类型；</p>
<p>请求从客户端发送到服务器时，命令被解析为带有的参数字符串数组（下文中的Frame），服务端使用特定的数据类型回复；</p>
<p>同时，<strong>RESP 中使用前缀来标记数据类型以及长度</strong>（prefixed-length）；</p>
<p>&lt;br/&gt;</p>
<h3><strong>RESP基本内容</strong></h3>
<p>RESP 是一个串行化协议（serialization protocol），支持以下几种数据类型：</p>
<ul>
<li>Simple Strings；</li>
<li>Errors；</li>
<li>Integers；</li>
<li>Bulk Strings；</li>
<li>Arrays；</li>
</ul>
<p>同时 RESP 使用的是请求-响应模型（request-response protocol）：</p>
<ul>
<li>客户端将命令作为 Array of Bulk Strings 发送到Redis服务器；</li>
<li>服务器获取命令，根据不同的类型进行回复；</li>
</ul>
<p>在 RESP 中，不同的数据类型是由他首个字节决定：</p>
<ul>
<li>For <strong>Simple Strings</strong>：the first byte of the reply is "+"；</li>
<li>For <strong>Errors</strong>：the first byte of the reply is "-"；</li>
<li>For <strong>Integers</strong>：the first byte of the reply is ":"；</li>
<li>For <strong>Bulk Strings</strong>：the first byte of the reply is "$"；</li>
<li>For <strong>Arrays</strong>：the first byte of the reply is "<code>*</code>"；</li>
</ul>
<p>对于 Null 值，可以使用 Bulk Strings 或者 Array 的特殊值来实现；</p>
<p>在 RESP 中，不同消息之间总是以 <code>"\r\n"</code> 结尾（different parts of the protocol are always terminated with "\r\n" (CRLF)）；</p>
<p>最后，官方文档提供了不同数据类型的例子：</p>
<pre><code class="lang-bash"># Simple Strings
"+OK\r\n"

# Errors
"-ERR unknown command 'helloworld'\r\n"

# Integers
":1000\r\n"

# Bulk Strings
"$5\r\nhello\r\n" =&gt; "hello"
"$0\r\n\r\n" =&gt; ""
"$-1\r\n" =&gt; Null(Null Bulk String)

# Arrays
"*0\r\n" =&gt; []
"*2\r\n$5\r\nhello\r\n$5\r\nworld\r\n" =&gt; ["hello","world"]
"*3\r\n:1\r\n:2\r\n:3\r\n" =&gt; [1,2,3]
"*5\r\n:1\r\n:2\r\n:3\r\n:4\r\n$5\r\nhello\r\n" =&gt; [1,2,3,4,"hello"]
"*-1\r\n" =&gt; Null(Null Array)

# Nested arrays
*2\r\n
*3\r\n
:1\r\n
:2\r\n
:3\r\n
*2\r\n
+Hello\r\n
-World\r\n =&gt; [[1,2,3],["Hello", Err("World")]]

# Null elements in Arrays
*3\r\n
$5\r\n
hello\r\n
$-1\r\n
$5\r\n
world\r\n =&gt; ["hello",nil,"world"]
</code></pre>
<p>官方文档还列出了不同数据类型的一些实现细节，你在阅读下面一部分时，建议先阅读官方文档；</p>
<ul>
<li><a href="https://redis.io/docs/reference/protocol-spec/">https://redis.io/docs/reference/protocol-spec/</a></li>
</ul>
<p>否则对于一些实现可能会一脸懵比；</p>
<p>&lt;br/&gt;</p>
<h3><strong>向服务端发送命令</strong></h3>
<p>前面介绍了 RESP 各个数据类型的定义，那么客户端和服务端到底是如何交互的呢？</p>
<p>也就是说，客户端要如何发送命令到服务端，并且服务端进行响应的呢？</p>
<p>下面来看一个客户端发送 <strong><code>LLEN mylist</code></strong>（获取 mylist 长度） 的例子：</p>
<pre><code class="lang-bash">Client: "*2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n"

Server: :48293\r\n
</code></pre>
<p>客户端首先将 <code>LLEN mylist</code> 包装后，发送 <code>"*2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n"</code> 到服务端；</p>
<p>服务端处理后返回 <code>:48293\r\n</code> 给客户端；</p>
<p>客户端收到结果并解析后，得到结果 <code>48293</code>；</p>
<p>&lt;br/&gt;</p>
<h2><strong>mini-redis连接层实现</strong></h2>
<p>mini-redis 中的连接层主要分为三个部分：</p>
<ul>
<li><strong>消息块 Frame：对应于上文所说的一整条使用 <code>\r\n</code> 分隔的序列化的命令，但是经过了格式化和拆分；</strong></li>
<li><strong>消息解析 Parse：将 Frame 消息解析为对应类型的命令；</strong></li>
<li><strong>连接管理 Connection：管理连接，发送并接收相应的消息；</strong></li>
</ul>
<p>代码结构如下：</p>
<pre><code class="lang-bash">$ tree ./src/connection 
./src/connection
├── connect.rs
├── frame.rs
├── mod.rs
└── parse.rs
</code></pre>
<p>下面我们一个一个来看；</p>
<p>&lt;br/&gt;</p>
<h3><strong>消息块Frame</strong></h3>
<p>前文说了一个 Frame 对应于一整条使用 <code>\r\n</code> 分隔的序列化的命令，我们将这条命令封装到了 Frame 中；</p>
<p>而由于在 Redis 中，命令的类型是固定的，那么使用 Rust 中强大的枚举类型来定义再合适不过！</p>
<p>实现如下：</p>
<p>src/connection/frame.rs</p>
<pre><code class="lang-rust">#[derive(Clone, Debug)]
pub enum Frame {
    Simple(String),
    Error(String),
    Integer(u64),
    Bulk(Bytes),
    Null,
    Array(Vec&lt;Frame&gt;),
}

impl PartialEq&lt;&amp;str&gt; for Frame {
    fn eq(&amp;self, other: &amp;&amp;str) -&gt; bool {
        match self {
            Frame::Simple(s) =&gt; s.eq(other),
            Frame::Bulk(s) =&gt; s.eq(other),
            _ =&gt; false,
        }
    }
}

impl fmt::Display for Frame {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        use std::str;

        match self {
            Frame::Simple(response) =&gt; response.fmt(fmt),
            Frame::Error(msg) =&gt; write!(fmt, "error: {}", msg),
            Frame::Integer(num) =&gt; num.fmt(fmt),
            Frame::Bulk(msg) =&gt; match str::from_utf8(msg) {
                Ok(string) =&gt; string.fmt(fmt),
                Err(_) =&gt; write!(fmt, "{:?}", msg),
            },
            Frame::Null =&gt; "(nil)".fmt(fmt),
            Frame::Array(parts) =&gt; {
                for (i, part) in parts.iter().enumerate() {
                    if i &gt; 0 {
                        write!(fmt, " ")?;
                        part.fmt(fmt)?;
                    }
                }

                Ok(())
            }
        }
    }
}

impl Frame {
    pub(crate) fn array() -&gt; Frame {
        Frame::Array(vec![])
    }

    pub(crate) fn push_bulk(&amp;mut self, bytes: Bytes) -&gt; Result&lt;(), MiniRedisParseError&gt; {
        match self {
            Frame::Array(vec) =&gt; {
                vec.push(Frame::Bulk(bytes));
                Ok(())
            }
            _ =&gt; Err(MiniRedisParseError::ParseArrayFrame),
        }
    }

    pub(crate) fn push_int(&amp;mut self, value: u64) -&gt; Result&lt;(), MiniRedisParseError&gt; {
        match self {
            Frame::Array(vec) =&gt; {
                vec.push(Frame::Integer(value));
                Ok(())
            }
            _ =&gt; Err(MiniRedisParseError::ParseArrayFrame),
        }
    }

    pub fn check(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;(), MiniRedisParseError&gt; {
        match get_u8(src)? {
            b'+' =&gt; {
                get_line(src)?;
                Ok(())
            }
            b'-' =&gt; {
                get_line(src)?;
                Ok(())
            }
            b':' =&gt; {
                let _ = get_decimal(src)?;
                Ok(())
            }
            b'$' =&gt; {
                if b'-' == peek_u8(src)? {
                    skip(src, 4)
                } else {
                    let len: usize = get_decimal(src)?.try_into()?;

                    skip(src, len + 2)
                }
            }
            b'*' =&gt; {
                let len = get_decimal(src)?;

                for _ in 0..len {
                    Frame::check(src)?;
                }

                Ok(())
            }
            actual =&gt; Err(MiniRedisParseError::Parse(format!(
                "protocol error; invalid frame type byte `{}`",
                actual
            ))),
        }
    }

    pub fn parse(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;Frame, MiniRedisParseError&gt; {
        match get_u8(src)? {
            b'+' =&gt; {
                let line = get_line(src)?.to_vec();

                let string = String::from_utf8(line)?;

                Ok(Frame::Simple(string))
            }
            b'-' =&gt; {
                let line = get_line(src)?.to_vec();

                let string = String::from_utf8(line)?;

                Ok(Frame::Error(string))
            }
            b':' =&gt; {
                let len = get_decimal(src)?;
                Ok(Frame::Integer(len))
            }
            b'$' =&gt; {
                if b'-' == peek_u8(src)? {
                    let line = get_line(src)?;

                    if line != b"-1" {
                        return Err(MiniRedisParseError::Parse(
                            "protocol error; invalid frame format".into(),
                        ));
                    }

                    Ok(Frame::Null)
                } else {
                    let len = get_decimal(src)?.try_into()?;
                    let n = len + 2;

                    if src.remaining() &lt; n {
                        return Err(MiniRedisParseError::Incomplete);
                    }

                    let data = Bytes::copy_from_slice(&amp;src.chunk()[..len]);

                    skip(src, n)?;

                    Ok(Frame::Bulk(data))
                }
            }
            b'*' =&gt; {
                let len = get_decimal(src)?.try_into()?;
                let mut out = Vec::with_capacity(len);

                for _ in 0..len {
                    out.push(Frame::parse(src)?);
                }

                Ok(Frame::Array(out))
            }
            _ =&gt; Err(MiniRedisParseError::Unimplemented),
        }
    }
}

fn skip(src: &amp;mut Cursor&lt;&amp;[u8]&gt;, n: usize) -&gt; Result&lt;(), MiniRedisParseError&gt; {
    if src.remaining() &lt; n {
        return Err(MiniRedisParseError::Incomplete);
    }

    src.advance(n);
    Ok(())
}

fn peek_u8(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;u8, MiniRedisParseError&gt; {
    if !src.has_remaining() {
        return Err(MiniRedisParseError::Incomplete);
    }

    Ok(src.chunk()[0])
}

fn get_u8(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;u8, MiniRedisParseError&gt; {
    if !src.has_remaining() {
        return Err(MiniRedisParseError::Incomplete);
    }

    Ok(src.get_u8())
}

fn get_decimal(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;u64, MiniRedisParseError&gt; {
    use atoi::atoi;

    let line = get_line(src)?;

    atoi::&lt;u64&gt;(line).ok_or_else(|| {
        MiniRedisParseError::Parse("protocol error; invalid frame format to get decimal".into())
    })
}

fn get_line&lt;'a&gt;(src: &amp;mut Cursor&lt;&amp;'a [u8]&gt;) -&gt; Result&lt;&amp;'a [u8], MiniRedisParseError&gt; {
    let start = src.position() as usize;
    let end = src.get_ref().len() - 1;

    for i in start..end {
        if src.get_ref()[i] == b'\r' &amp;&amp; src.get_ref()[i + 1] == b'\n' {
            src.set_position((i + 2) as u64);

            return Ok(&amp;src.get_ref()[start..i]);
        }
    }

    Err(MiniRedisParseError::Incomplete)
}
</code></pre>
<p>&lt;br/&gt;</p>
<h4><strong>Frame定义</strong></h4>
<p>和上面 Redis 官方文档相对应，我们定义了 Frame 枚举，并重写了 PartialEq 和 Display Trait；</p>
<pre><code class="lang-rust">#[derive(Clone, Debug)]
pub enum Frame {
    Simple(String),
    Error(String),
    Integer(u64),
    Bulk(Bytes),
    Null,
    Array(Vec&lt;Frame&gt;),
}

impl PartialEq&lt;&amp;str&gt; for Frame {
    fn eq(&amp;self, other: &amp;&amp;str) -&gt; bool {
        match self {
            Frame::Simple(s) =&gt; s.eq(other),
            Frame::Bulk(s) =&gt; s.eq(other),
            _ =&gt; false,
        }
    }
}

impl fmt::Display for Frame {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        use std::str;

        match self {
            Frame::Simple(response) =&gt; response.fmt(fmt),
            Frame::Error(msg) =&gt; write!(fmt, "error: {}", msg),
            Frame::Integer(num) =&gt; num.fmt(fmt),
            Frame::Bulk(msg) =&gt; match str::from_utf8(msg) {
                Ok(string) =&gt; string.fmt(fmt),
                Err(_) =&gt; write!(fmt, "{:?}", msg),
            },
            Frame::Null =&gt; "(nil)".fmt(fmt),
            Frame::Array(parts) =&gt; {
                for (i, part) in parts.iter().enumerate() {
                    if i &gt; 0 {
                        write!(fmt, " ")?;
                        part.fmt(fmt)?;
                    }
                }

                Ok(())
            }
        }
    }
}
</code></pre>
<p><strong>需要注意：的是我们直接使用了 Vector 来存储 Array 类型的命令；</strong></p>
<p>其他部分实现非常简单，这里不再解释了；</p>
<p>下面来具体看 Frame 的实现部分；</p>
<p>&lt;br/&gt;</p>
<h4><strong>Frame实现</strong></h4>
<p>我们在 Frame 中定义了下面几个方法：</p>
<ul>
<li>array：返回一个空的 Array 类型的 Frame，大多用于服务端响应时自行填充返回值时使用，配合下面的各种push方法；</li>
<li>push_bulk：向 Frame 对象中填充 Bulk 类型的值；</li>
<li>push_int：向 Frame 对象中填充 Int 类型的值；</li>
<li>check：校验当前字节数组中的值是否合法，主要用在服务端、客户端接受到请求和响应后进行消息校验；</li>
<li>parse：将当前字节数组中的值解析为 Frame；</li>
</ul>
<p>实现如下：</p>
<pre><code class="lang-rust">impl Frame {
    /// Returns an empty array
    pub(crate) fn array() -&gt; Frame {
        Frame::Array(vec![])
    }

    /// Push a "bulk" frame into the array. `self` must be an Array frame.
    pub(crate) fn push_bulk(&amp;mut self, bytes: Bytes) -&gt; Result&lt;(), MiniRedisParseError&gt; {
        match self {
            Frame::Array(vec) =&gt; {
                vec.push(Frame::Bulk(bytes));
                Ok(())
            }
            _ =&gt; Err(MiniRedisParseError::ParseArrayFrame),
        }
    }

    /// Push an "integer" frame into the array. `self` must be an Array frame.
    pub(crate) fn push_int(&amp;mut self, value: u64) -&gt; Result&lt;(), MiniRedisParseError&gt; {
        match self {
            Frame::Array(vec) =&gt; {
                vec.push(Frame::Integer(value));
                Ok(())
            }
            _ =&gt; Err(MiniRedisParseError::ParseArrayFrame),
        }
    }

    /// Checks if an entire message can be decoded from `src`
    pub fn check(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;(), MiniRedisParseError&gt; {
        match get_u8(src)? {
            b'+' =&gt; {
                get_line(src)?;
                Ok(())
            }
            b'-' =&gt; {
                get_line(src)?;
                Ok(())
            }
            b':' =&gt; {
                let _ = get_decimal(src)?;
                Ok(())
            }
            b'$' =&gt; {
                if b'-' == peek_u8(src)? {
                    // Skip '-1\r\n'
                    skip(src, 4)
                } else {
                    // Read the bulk string
                    let len: usize = get_decimal(src)?.try_into()?;

                    // skip that number of bytes + 2 (\r\n).
                    skip(src, len + 2)
                }
            }
            b'*' =&gt; {
                let len = get_decimal(src)?;

                for _ in 0..len {
                    Frame::check(src)?;
                }

                Ok(())
            }
            actual =&gt; Err(MiniRedisParseError::Parse(format!(
                "protocol error; invalid frame type byte `{}`",
                actual
            ))),
        }
    }

    pub fn parse(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;Frame, MiniRedisParseError&gt; {
        match get_u8(src)? {
            b'+' =&gt; {
                // Read the line and convert it to `Vec&lt;u8&gt;`
                let line = get_line(src)?.to_vec();

                // Convert the line to a String
                let string = String::from_utf8(line)?;

                Ok(Frame::Simple(string))
            }
            b'-' =&gt; {
                // Read the line and convert it to `Vec&lt;u8&gt;`
                let line = get_line(src)?.to_vec();

                // Convert the line to a String
                let string = String::from_utf8(line)?;

                Ok(Frame::Error(string))
            }
            b':' =&gt; {
                let len = get_decimal(src)?;
                Ok(Frame::Integer(len))
            }
            b'$' =&gt; {
                if b'-' == peek_u8(src)? {
                    let line = get_line(src)?;

                    if line != b"-1" {
                        return Err(MiniRedisParseError::Parse(
                            "protocol error; invalid frame format".into(),
                        ));
                    }

                    Ok(Frame::Null)
                } else {
                    // Read the bulk string
                    let len = get_decimal(src)?.try_into()?;
                    let n = len + 2;

                    if src.remaining() &lt; n {
                        return Err(MiniRedisParseError::Incomplete);
                    }

                    let data = Bytes::copy_from_slice(&amp;src.chunk()[..len]);

                    // skip that number of bytes + 2 (\r\n).
                    skip(src, n)?;

                    Ok(Frame::Bulk(data))
                }
            }
            b'*' =&gt; {
                let len = get_decimal(src)?.try_into()?;
                let mut out = Vec::with_capacity(len);

                for _ in 0..len {
                    out.push(Frame::parse(src)?);
                }

                Ok(Frame::Array(out))
            }
            _ =&gt; Err(MiniRedisParseError::Unimplemented),
        }
    }
}
</code></pre>
<p>写入 Frame 的方法：</p>
<ul>
<li>array 方法：实现非常简单，就是返回一个空的 Array 类型的 Frame，并初始化一个空的 vector；</li>
<li>push_bulk 方法：如果当前 Frame 对象是 Array 类型，则将 bytes 加入数组中，否则报错；</li>
<li>push_int 方法：和上面类似，如果当前 Frame 对象是 Array 类型，则将 u64 加入数组中；</li>
</ul>
<p>重点来看<strong>解析 Frame 的方法：check 和 parse；</strong></p>
<p>他们将接收到的字节，根据前文中的 RESP 规则解析为对应类型的 Frame；</p>
<p>两者的实现及其类似，这里主要解析 check 方法，parse 方法只是在 check 逻辑的基础之上将 Frame 封装后返回；</p>
<p>首先来看几个辅助函数：</p>
<pre><code class="lang-rust">fn skip(src: &amp;mut Cursor&lt;&amp;[u8]&gt;, n: usize) -&gt; Result&lt;(), MiniRedisParseError&gt; {
    if src.remaining() &lt; n {
        return Err(MiniRedisParseError::Incomplete);
    }

    src.advance(n);
    Ok(())
}

fn peek_u8(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;u8, MiniRedisParseError&gt; {
    if !src.has_remaining() {
        return Err(MiniRedisParseError::Incomplete);
    }

    Ok(src.chunk()[0])
}

fn get_u8(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;u8, MiniRedisParseError&gt; {
    if !src.has_remaining() {
        return Err(MiniRedisParseError::Incomplete);
    }

    Ok(src.get_u8())
}

/// Read a new-line terminated decimal
fn get_decimal(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;u64, MiniRedisParseError&gt; {
    use atoi::atoi;

    let line = get_line(src)?;

    atoi::&lt;u64&gt;(line).ok_or_else(|| {
        MiniRedisParseError::Parse("protocol error; invalid frame format to get decimal".into())
    })
}

/// Find a line in a frame
fn get_line&lt;'a&gt;(src: &amp;mut Cursor&lt;&amp;'a [u8]&gt;) -&gt; Result&lt;&amp;'a [u8], MiniRedisParseError&gt; {
    // Scan the bytes directly
    let start = src.position() as usize;
    // Scan to the second to last byte
    let end = src.get_ref().len() - 1;

    for i in start..end {
        if src.get_ref()[i] == b'\r' &amp;&amp; src.get_ref()[i + 1] == b'\n' {
            // We found a line, update the position to be *after* the \n
            src.set_position((i + 2) as u64);

            // Return the line
            return Ok(&amp;src.get_ref()[start..i]);
        }
    }

    Err(MiniRedisParseError::Incomplete)
}
</code></pre>
<p>上面定义了几个辅助函数：</p>
<ul>
<li><strong><code>skip(src: &amp;mut Cursor&lt;&amp;[u8]&gt;, n: usize)</code>：将当前 Cursor 前移 n 个字节；</strong><ul>
<li>前面说到了在 RESP 中会通过 prefixed-length 来指定数据的字节长度，这里就可以直接将这个数据跳过，继续解析下一个数据；</li>
<li>当然，如果后面已经没有 n 个字节，说明数据不完整，此时无法解析，返回 <code>MiniRedisParseError::Incomplete</code> 类型的错误，说明消息不完整；</li>
</ul>
</li>
<li><strong><code>peek_u8(src: &amp;mut Cursor&lt;&amp;[u8]&gt;)</code>：查看下一个字节对应字符；</strong><ul>
<li>peek_u8 主要是在不移动指针的前提下获取下一个字节，可以用来判断，例如：Array 中的下一个数据类型、是否为空的 Bulk（<code>-</code> 开头）等；</li>
</ul>
</li>
<li><strong><code>get_u8(src: &amp;mut Cursor&lt;&amp;[u8]&gt;)</code>：直接获取下一个字节，用于直接判断某个命令的数据类型；</strong></li>
<li><strong><code>get_line&lt;'a&gt;(src: &amp;mut Cursor&lt;&amp;'a [u8]&gt;)</code>：获取以 <code>\r\n</code> 结尾的一整行数据；</strong><ul>
<li>前文提到了每个独立的命令都是以 <code>\r\n</code> 结尾；</li>
</ul>
</li>
<li><strong><code>get_decimal(src: &amp;mut Cursor&lt;&amp;[u8]&gt;)</code>：获取一整行整型类型，主要用在简化整型数据解析的场景；</strong></li>
</ul>
<p>下面来看具体的 check 方法的实现：</p>
<pre><code class="lang-rust">pub fn check(src: &amp;mut Cursor&lt;&amp;[u8]&gt;) -&gt; Result&lt;(), MiniRedisParseError&gt; {
  match get_u8(src)? {
    b'+' =&gt; {
      get_line(src)?;
      Ok(())
    }
    b'-' =&gt; {
      get_line(src)?;
      Ok(())
    }
    b':' =&gt; {
      let _ = get_decimal(src)?;
      Ok(())
    }
    b'$' =&gt; {
      if b'-' == peek_u8(src)? {
        // Skip '-1\r\n'
        skip(src, 4)
      } else {
        // Read the bulk string
        let len: usize = get_decimal(src)?.try_into()?;

        // skip that number of bytes + 2 (\r\n).
        skip(src, len + 2)
      }
    }
    b'*' =&gt; {
      let len = get_decimal(src)?;

      for _ in 0..len {
        Frame::check(src)?;
      }

      Ok(())
    }
    actual =&gt; Err(MiniRedisParseError::Parse(format!(
      "protocol error; invalid frame type byte `{}`",
      actual
    ))),
  }
}
</code></pre>
<p>逻辑如下：</p>
<ul>
<li><strong><code>+</code> 或者 <code>-</code> 开头（简单字符串、错误信息）：只要是一行数据（<code>\r\n</code> 结尾）即可；</strong></li>
<li><strong><code>:</code> 开头（整数类型）：不光要是一行数据，还要能被解析为整数；</strong></li>
<li><strong><code>$</code> 开头（Bulk String）：</strong><ul>
<li><strong>如果 <code>-</code> 开头，说明是空字符串（<code>$-1\r\n</code>）；</strong></li>
<li><strong>否则，先通过 get_decimal 取出字符串长度、再跳过 <code>对应长度 + 2(\r\n)</code> 个字节，取出 Frame；</strong></li>
</ul>
</li>
<li><strong><code>*</code> 开头（Array）：先取出数组的长度 len，再递归的调用 check 来校验每一个元素；</strong></li>
<li><strong>否则是不支持的数据类型，直接报错；</strong></li>
</ul>
<p>parse 方法的逻辑和 check 基本上是一致的，这里不再赘述；</p>
<p>&lt;font color="#f00"&gt;**需要注意的是：check 方法会移动 Cursor 指针到 `\r\n` 之后，这是为了后面在调用 parse 方法时可以直接获取到一整条 Frame 的长度；**&lt;/font&gt;</p>
<p>另外还有一个问题：<strong>为什么将解析分为了 check、parse 两个功能相似的方法？</strong></p>
<p>这是因为：</p>
<ul>
<li>&lt;font color="#f00"&gt;**首先，在一整条命令尚未完全接收到的时候，我们会可能会进行多次解析，而 check 的效率是高于 parse 的；**&lt;/font&gt;</li>
<li>&lt;font color="#f00"&gt;**另外，在没有完全确定我们收到了一个完整的 Frame 之前如果直接强行的 parse 会分配内存，而先调用 check 方法是不需要内存分配的；**&lt;/font&gt;</li>
</ul>
<p>&lt;br/&gt;</p>
<h3><strong>消息解析Parse</strong></h3>
<p>Parse 是对 Frame 的一个包装，将例如：<code>set foo 123</code> 一整个 Frame 包装为一个类似于 cursor 的结构；这样，Parse 中的第一个元素即 redis 中的命令；</p>
<p>这在遍历 Frame 中的 Array 等结构时非常有用！</p>
<p>Parse 定义如下：</p>
<p>src/connection/parse.rs</p>
<pre><code class="lang-rust">/// Utility for parsing a command
///
/// Commands are represented as array frames. Each entry in the frame is a
/// "token". A `Parse` is initialized with the array frame and provides a
/// cursor-like API. Each command struct includes a `parse_frame` method that
/// uses a `Parse` to extract its fields.
#[derive(Debug)]
pub(crate) struct Parse {
    /// Array frame iterator.
    parts: vec::IntoIter&lt;Frame&gt;,
}
</code></pre>
<p>对应实现的方法：</p>
<p>src/connection/parse.rs</p>
<pre><code class="lang-rust">impl Parse {
    /// Create a new `Parse` to parse the contents of `frame`.
    /// Returns `Err` if `frame` is not an array frame.
    pub(crate) fn new(frame: Frame) -&gt; Result&lt;Parse, MiniRedisParseError&gt; {
        let array = match frame {
            Frame::Array(array) =&gt; array,
            frame =&gt; {
                return Err(MiniRedisParseError::Parse(format!(
                    "protocol error; expected array, got {:?}",
                    frame
                )))
            }
        };

        Ok(Parse {
            parts: array.into_iter(),
        })
    }

    /// Return the next entry. Array frames are arrays of frames, so the next
    /// entry is a frame.
    fn next(&amp;mut self) -&gt; Result&lt;Frame, MiniRedisParseError&gt; {
        self.parts.next().ok_or(MiniRedisParseError::EndOfStream)
    }

    /// Return the next entry as a string.
    /// If the next entry cannot be represented as a String, then an error is returned.
    pub(crate) fn next_string(&amp;mut self) -&gt; Result&lt;String, MiniRedisParseError&gt; {
        match self.next()? {
            // Both `Simple` and `Bulk` representation may be strings. Strings
            // are parsed to UTF-8.
            //
            // While errors are stored as strings, they are considered separate
            // types.
            Frame::Simple(s) =&gt; Ok(s),
            Frame::Bulk(data) =&gt; std::str::from_utf8(&amp;data[..])
                .map(|s| s.to_string())
                .map_err(|_| MiniRedisParseError::Parse("protocol error; invalid string".into())),
            frame =&gt; Err(MiniRedisParseError::Parse(format!(
                "protocol error; expected simple frame or bulk frame, got {:?}",
                frame
            ))),
        }
    }

    /// Return the next entry as raw bytes.
    /// If the next entry cannot be represented as raw bytes, an error is
    /// returned.
    pub(crate) fn next_bytes(&amp;mut self) -&gt; Result&lt;Bytes, MiniRedisParseError&gt; {
        match self.next()? {
            // Both `Simple` and `Bulk` representation may be raw bytes.
            //
            // Although errors are stored as strings and could be represented as
            // raw bytes, they are considered separate types.
            Frame::Simple(s) =&gt; Ok(Bytes::from(s.into_bytes())),
            Frame::Bulk(data) =&gt; Ok(data),
            frame =&gt; Err(MiniRedisParseError::Parse(format!(
                "protocol error; expected simple frame or bulk frame, got {:?}",
                frame
            ))),
        }
    }

    /// Return the next entry as an integer.
    ///
    /// This includes `Simple`, `Bulk`, and `Integer` frame types. `Simple` and
    /// `Bulk` frame types are parsed.
    ///
    /// If the next entry cannot be represented as an integer, then an error is
    /// returned.
    pub(crate) fn next_int(&amp;mut self) -&gt; Result&lt;u64, MiniRedisParseError&gt; {
        use atoi::atoi;

        match self.next()? {
            // An integer frame type is already stored as an integer.
            Frame::Integer(v) =&gt; Ok(v),
            // Simple and bulk frames must be parsed as integers. If the parsing
            // fails, an error is returned.
            Frame::Simple(data) =&gt; atoi::&lt;u64&gt;(data.as_bytes())
                .ok_or_else(|| MiniRedisParseError::Parse("protocol error; invalid number".into())),
            Frame::Bulk(data) =&gt; atoi::&lt;u64&gt;(&amp;data)
                .ok_or_else(|| MiniRedisParseError::Parse("protocol error; invalid number".into())),
            frame =&gt; Err(MiniRedisParseError::Parse(format!(
                "protocol error; expected int frame but got {:?}",
                frame
            ))),
        }
    }

    /// Ensure there are no more entries in the array
    pub(crate) fn finish(&amp;mut self) -&gt; Result&lt;(), MiniRedisParseError&gt; {
        if self.parts.next().is_none() {
            Ok(())
        } else {
            Err(MiniRedisParseError::Parse(
                "protocol error; expected end of frame, but there was more".into(),
            ))
        }
    }
}
</code></pre>
<p>解析如下：</p>
<ul>
<li><strong>new 方法：</strong>创建了一个 IntoIter 类型的迭代器，类似于流数据，一旦获取到了下一个 Frame，则交出所有权！</li>
<li><strong>next、next_string、next_bytes、next_int 方法：</strong>提供了直接获取下一个 Frame 的方法，如果类型不匹配则直接报错，避免了自己再去判断数据类型，简化了使用；</li>
<li><strong>finish 方法：</strong>当命令解析完成后调用该方法，确保 Frame 用完，保证 Frame 格式的正确性；</li>
</ul>
<p>Parse 模块主要是给 Command 模块提供一个更高层次上的命令抽象，方便使用；</p>
<p>&lt;br/&gt;</p>
<h3><strong>连接管理Connection</strong></h3>
<h4><strong>Connection定义</strong></h4>
<p>最后来看连接管理 Connection，他负责在 Client 和 Server 之间建立一个 TCP 连接，并负责写入或读取低层次的 Frame 数据；</p>
<p>Connection 的定义如下：</p>
<p>src/connection/connect.rs</p>
<pre><code class="lang-rust">/// Send and receive `Frame` values from a remote peer.
///
/// When implementing networking protocols, a message on that protocol is
/// often composed of several smaller messages known as frames. The purpose of
/// `Connection` is to read and write frames on the underlying `TcpStream`.
///
/// To read frames, the `Connection` uses an internal buffer, which is filled
/// up until there are enough bytes to create a full frame. Once this happens,
/// the `Connection` creates the frame and returns it to the caller.
///
/// When sending frames, the frame is first encoded into the write buffer.
/// The contents of the write buffer are then written to the socket.
#[derive(Debug)]
pub struct Connection {
    /// The `TcpStream`. It is decorated with a `BufWriter`, which provides write
    /// level buffering. The `BufWriter` implementation provided by Tokio is
    /// sufficient for our needs.
    stream: BufWriter&lt;TcpStream&gt;,

    // The buffer for reading frames.
    buffer: BytesMut,
}
</code></pre>
<p>Connection 包含了：</p>
<ul>
<li><strong>stream：</strong><code>BufWriter&lt;TcpStream&gt;</code> 类型；&lt;font color="#f00"&gt;**stream 被 BufWriter 包装，这样我们在写入数据的时候，可以先分块写入（类似于Java中的StringBuilder），最后再调用 flush 一次发送，避免多次调用内核函数，提高效率；**&lt;/font&gt;</li>
<li><strong>buffer：</strong>连接读取数据时的缓冲；&lt;font color="#f00"&gt;**注意到我们使用的是 tokio 框架，因此将数据读取到 buffer 是一个异步操作；**&lt;/font&gt;</li>
</ul>
<p>在 Connection 中定义并暴露了下面两个方法：</p>
<ul>
<li><code>new</code>：构造函数；</li>
<li><code>read_frame</code>：从 buffer 中读取并解析数据为 Frame；</li>
<li><code>write_frame</code>：向 TCP 流中写入一个完整的 Frame 数据；</li>
</ul>
<p>下面来看实现：</p>
<pre><code class="lang-rust">impl Connection {
    pub fn new(socket: TcpStream) -&gt; Connection {
        Connection {
            stream: BufWriter::new(socket),
            buffer: BytesMut::with_capacity(4 * 1024),
        }
    }

    pub async fn read_frame(&amp;mut self) -&gt; Result&lt;Option&lt;Frame&gt;, MiniRedisConnectionError&gt; {
        loop {
            if let Some(frame) = self.parse_frame()? {
                return Ok(Some(frame));
            }

            if 0 == self.stream.read_buf(&amp;mut self.buffer).await? {
                return if self.buffer.is_empty() {
                    Ok(None)
                } else {
                    Err(MiniRedisConnectionError::Disconnect)
                };
            }
        }
    }

    fn parse_frame(&amp;mut self) -&gt; Result&lt;Option&lt;Frame&gt;, MiniRedisConnectionError&gt; {
        let mut buf = Cursor::new(&amp;self.buffer[..]);

        match Frame::check(&amp;mut buf) {
            Ok(_) =&gt; {
                let len = buf.position() as usize;

                buf.set_position(0);

                let frame = Frame::parse(&amp;mut buf)?;

                self.buffer.advance(len);
                Ok(Some(frame))
            }
            Err(MiniRedisParseError::Incomplete) =&gt; Ok(None),
            Err(e) =&gt; Err(e.into()),
        }
    }

    pub async fn write_frame(&amp;mut self, frame: &amp;Frame) -&gt; Result&lt;(), MiniRedisConnectionError&gt; {
        match frame {
            Frame::Array(val) =&gt; {
                self.stream.write_u8(b'*').await?;

                self.write_decimal(val.len() as u64).await?;

                for entry in val {
                    self.write_value(entry).await?;
                }
            }
            _ =&gt; self.write_value(frame).await?,
        }

        self.stream.flush().await.map_err(|e| e.into())
    }

    async fn write_value(&amp;mut self, frame: &amp;Frame) -&gt; Result&lt;(), MiniRedisConnectionError&gt; {
        match frame {
            Frame::Simple(val) =&gt; {
                self.stream.write_u8(b'+').await?;
                self.stream.write_all(val.as_bytes()).await?;
                self.stream.write_all(b"\r\n").await?;
            }
            Frame::Error(val) =&gt; {
                self.stream.write_u8(b'-').await?;
                self.stream.write_all(val.as_bytes()).await?;
                self.stream.write_all(b"\r\n").await?;
            }
            Frame::Integer(val) =&gt; {
                self.stream.write_u8(b':').await?;
                self.write_decimal(*val).await?;
            }
            Frame::Null =&gt; {
                self.stream.write_all(b"$-1\r\n").await?;
            }
            Frame::Bulk(val) =&gt; {
                let len = val.len();

                self.stream.write_u8(b'$').await?;
                self.write_decimal(len as u64).await?;
                self.stream.write_all(val).await?;
                self.stream.write_all(b"\r\n").await?;
            }
            Frame::Array(_val) =&gt; {
                warn!("unreachable code: recursive write_value: {:?}", _val);
                return Err(MiniRedisParseError::Unimplemented.into());
            }
        }

        Ok(())
    }

    async fn write_decimal(&amp;mut self, val: u64) -&gt; Result&lt;(), MiniRedisConnectionError&gt; {
        use std::io::Write;

        let mut buf = [0u8; 20];
        let mut buf = Cursor::new(&amp;mut buf[..]);

        write!(&amp;mut buf, "{}", val)?;

        let pos = buf.position() as usize;
        self.stream.write_all(&amp;buf.get_ref()[..pos]).await?;
        self.stream.write_all(b"\r\n").await?;

        Ok(())
    }
}
</code></pre>
<p>new 方法的实现非常简单，对于读取 Buffer 而言开辟了一个 4Kb 的 buffer 空间（对于 prototype 来说是合适的），这里不再赘述，下面重点来看异步数据读写的实现；</p>
<p>&lt;br/&gt;</p>
<h4><strong>读取数据：read_frame</strong></h4>
<p>读取数据 read_frame：</p>
<pre><code class="lang-rust">use tokio::io::{AsyncReadExt};
pub async fn read_frame(&amp;mut self) -&gt; Result&lt;Option&lt;Frame&gt;, MiniRedisConnectionError&gt; {
  loop {
    // Attempt to parse a frame from the buffered data. If enough data
    // has been buffered, the frame is returned.
    if let Some(frame) = self.parse_frame()? {
      return Ok(Some(frame));
    }

    // There is not enough buffered data to read a frame. Attempt to
    // read more data from the socket.
    //
    // On success, the number of bytes is returned. `0` indicates "end
    // of stream".
    if 0 == self.stream.read_buf(&amp;mut self.buffer).await? {
      // The remote closed the connection. For this to be a clean
      // shutdown, there should be no data in the read buffer. If
      // there is, this means that the peer closed the socket while
      // sending a frame.
      return if self.buffer.is_empty() {
        Ok(None)
      } else {
        Err(MiniRedisConnectionError::Disconnect)
      };
    }
  }
}
</code></pre>
<p>在 read_frame 方法中会循环读取数据，并调用内部的 parse_frame 方法解析当前 buffer 中的数据：</p>
<ul>
<li>如果 parse_frame 方法成功解析了一个 frame，则退出循环并返回这个 Frame；</li>
<li>如果 parse_frame 方法保存则返回错误；</li>
<li>否则继续调用 <code>self.stream.read_buf(&amp;mut self.buffer).await</code> 异步的向 buffer 中读取数据（依赖 tokio 中的 AsyncReadExt Trait），如果 read_buf 返回 0 则说明流已关闭（对面客户端关闭了连接）！</li>
</ul>
<p>当流关闭后：</p>
<ul>
<li>如果 buffer 中无数据，则表示客户端并未发送数据，此时正常退出即可；</li>
<li>如果 buffer 中存在数据，则表示客户端在发送数据的中途关闭了连接，此时要报错：<code>MiniRedisConnectionError::Disconnect</code>；</li>
</ul>
<blockquote><p><strong>上面基本上是使用 tokio stream 的标准结构；</strong></p>
</blockquote>
<p>下面具体来看解析 Frame 部分：</p>
<pre><code class="lang-rust">fn parse_frame(&amp;mut self) -&gt; Result&lt;Option&lt;Frame&gt;, MiniRedisConnectionError&gt; {
  // Cursor is used to track the "current" location in the
  // buffer. Cursor also implements `Buf` from the `bytes` crate
  // which provides a number of helpful utilities for working
  // with bytes.
  let mut buf = Cursor::new(&amp;self.buffer[..]);

  // The first step is to check if enough data has been buffered to parse a single frame.
  // This step is usually much faster than doing a full
  // parse of the frame, and allows us to skip allocating data structures
  // to hold the frame data unless we know the full frame has been received.
  match Frame::check(&amp;mut buf) {
    Ok(_) =&gt; {
      // The `check` function will have advanced the cursor until the
      // end of the frame. Since the cursor had position set to zero
      // before `Frame::check` was called, we obtain the length of the
      // frame by checking the cursor position.
      let len = buf.position() as usize;

      // Reset the position to zero before passing the cursor to
      // `Frame::parse`.
      buf.set_position(0);

      // Parse the frame from the buffer. This allocates the necessary
      // structures to represent the frame and returns the frame value.
      //
      // If the encoded frame representation is invalid, an error is
      // returned. This should terminate the **current** connection
      // but should not impact any other connected client.
      let frame = Frame::parse(&amp;mut buf)?;

      // Discard the parsed data from the read buffer.
      //
      // When `advance` is called on the read buffer, all of the data
      // up to `len` is discarded. The details of how this works is
      // left to `BytesMut`. This is often done by moving an internal
      // cursor, but it may be done by reallocating and copying data.
      self.buffer.advance(len);

      // Return the parsed frame to the caller.
      Ok(Some(frame))
    }
    // There is not enough data present in the read buffer to parse a
    // single frame. We must wait for more data to be received from the
    // socket. Reading from the socket will be done in the statement
    // after this `match`.
    //
    // We do not want to return `Err` from here as this "error" is an
    // expected runtime condition.
    Err(MiniRedisParseError::Incomplete) =&gt; Ok(None),
    // An error was encountered while parsing the frame. The connection
    // is now in an invalid state. Returning `Err` from here will result
    // in the connection being closed.
    Err(e) =&gt; Err(e.into()),
  }
}
</code></pre>
<p>在 parse_frame 内部方法中就用到了我们前文中所述的 <code>Frame::check</code> 方法；</p>
<p>parse_frame 首先将 buffer 转为 Cursor，随后调用 <code>Frame::check</code> 方法对 buffer 中的数据进行校验：</p>
<ul>
<li>如果校验成功：<ul>
<li>获取当前 buf 的长度作为整个 Frame 的长度（<strong>前文提到 check 方法会移动<code>当前 Cursor</code>（每次调用 parse_frame 创建一个新的 Cursor） 的位置到 Frame 末尾</strong>）；</li>
<li>同时将 cursor 恢复后调用 <code>Frame::parse</code> 方法解析 Frame；</li>
<li>最后调用 <code>self.buffer.advance(len)</code> 移动指针并丢弃 buffer 中我们已经解析的数据；</li>
</ul>
</li>
<li>如果校验失败：<ul>
<li>如果是 <code>MiniRedisParseError::Incomplete</code> 类型的错误，则说明 buffer 中的数据还不够组成一个 Frame，此时返回 None；</li>
<li>否则，直接返回错误即可；</li>
</ul>
</li>
</ul>
<p>&lt;font color="#f00"&gt;**这里就体现了我们使用 thiserror 库的优势：我们可以判断具体的错误类型为数据不足，进而继续从 buffer 中读取数据；**&lt;/font&gt;</p>
<p>&lt;br/&gt;</p>
<h4><strong>写入数据：write_frame</strong></h4>
<p>写入 Frame write_frame：</p>
<pre><code class="lang-rust">use tokio::io::{AsyncWriteExt, BufWriter};

/// Write a single `Frame` value to the underlying stream.
///
/// The `Frame` value is written to the socket using the various `write_*`
/// functions provided by `AsyncWrite`. Calling these functions directly on
/// a `TcpStream` is **not** advised, as this will result in a large number of
/// syscalls. However, it is fine to call these functions on a *buffered*
/// write stream. The data will be written to the buffer. Once the buffer is
/// full, it is flushed to the underlying socket.
pub async fn write_frame(&amp;mut self, frame: &amp;Frame) -&gt; Result&lt;(), MiniRedisConnectionError&gt; {
  // Arrays are encoded by encoding each entry. All other frame types are
  // considered literals. For now, mini-redis is not able to encode
  // recursive frame structures. See below for more details.
  match frame {
    Frame::Array(val) =&gt; {
      // Encode the frame type prefix. For an array, it is `*`.
      self.stream.write_u8(b'*').await?;

      // Encode the length of the array.
      self.write_decimal(val.len() as u64).await?;

      // Iterate and encode each entry in the array.
      for entry in val {
        self.write_value(entry).await?;
      }
    }
    // The frame type is a literal. Encode the value directly.
    _ =&gt; self.write_value(frame).await?,
  }

  // Ensure the encoded frame is written to the socket. The calls above
  // are to the buffered stream and writes. Calling `flush` writes the
  // remaining contents of the buffer to the socket.
  self.stream.flush().await.map_err(|e| e.into())
}
</code></pre>
<p>write_frame 异步写入数据的实现逻辑非常简单：</p>
<ul>
<li>如果是 Array 类型的 Frame，则先写入 <code>*len(arr)</code>，然后遍历数组，调用 write_value 内部方法向流中写入数组中的每一个 Frame；</li>
<li>否则，直接调用 write_value 内部方法写入 Frame；</li>
<li>最后，调用 <code>stream.flush()</code> 发送数据即可！</li>
</ul>
<blockquote><p>&lt;font color="#f00"&gt;**由于我们使用 `BufWriter&lt;TcpStream&gt;` 包装了 Stream，因此我们可以多次调用 write_value 向流中写入数据，而只有 buffer 装满，或调用 flush 后才会真正的将数据发送给 socket！**&lt;/font&gt;</p>
</blockquote>
<p>下面来看 write_value 内部方法，他根据 RESP 规则写入具体格式的数据：</p>
<pre><code class="lang-rust">/// Write a frame literal to the stream
async fn write_value(&amp;mut self, frame: &amp;Frame) -&gt; Result&lt;(), MiniRedisConnectionError&gt; {
  match frame {
    Frame::Simple(val) =&gt; {
      self.stream.write_u8(b'+').await?;
      self.stream.write_all(val.as_bytes()).await?;
      self.stream.write_all(b"\r\n").await?;
    }
    Frame::Error(val) =&gt; {
      self.stream.write_u8(b'-').await?;
      self.stream.write_all(val.as_bytes()).await?;
      self.stream.write_all(b"\r\n").await?;
    }
    Frame::Integer(val) =&gt; {
      self.stream.write_u8(b':').await?;
      self.write_decimal(*val).await?;
    }
    Frame::Null =&gt; {
      self.stream.write_all(b"$-1\r\n").await?;
    }
    Frame::Bulk(val) =&gt; {
      let len = val.len();

      self.stream.write_u8(b'$').await?;
      self.write_decimal(len as u64).await?;
      self.stream.write_all(val).await?;
      self.stream.write_all(b"\r\n").await?;
    }
    // Encoding an `Array` from within a value cannot be done using a
    // recursive strategy. In general, async fns do not support
    // recursion. Mini-redis has not needed to encode nested arrays yet,
    // so for now it is skipped.
    Frame::Array(_val) =&gt; {
      warn!("unreachable code: recursive write_value: {:?}", _val);
      return Err(MiniRedisParseError::Unimplemented.into());
    }
  }

  Ok(())
}

/// Write a decimal frame to the stream
async fn write_decimal(&amp;mut self, val: u64) -&gt; Result&lt;(), MiniRedisConnectionError&gt; {
  use std::io::Write;

  // Convert the value to a string
  let mut buf = [0u8; 20];
  let mut buf = Cursor::new(&amp;mut buf[..]);

  write!(&amp;mut buf, "{}", val)?;

  let pos = buf.position() as usize;
  self.stream.write_all(&amp;buf.get_ref()[..pos]).await?;
  self.stream.write_all(b"\r\n").await?;

  Ok(())
}
</code></pre>
<p>实现逻辑基本上跟我们解析字节到 Frame 中的逻辑相反；</p>
<p>然而，write_value 的逻辑更加简单，直接根据 RESP 规则，针对不同类型的数据写入不同格式的数据即可；</p>
<p>&lt;font color="#f00"&gt;**需要注意的是：目前在 rust 中 async 函数不允许直接递归，因此 write_value 还不能处理另外一个 Array 类型的数据；**&lt;/font&gt;</p>
<blockquote><p><strong>实际上这是因为递归的 async 生成的 Future 块的大小是不确定的，而 Rust 又规定在编译器所有类型的内存大小是确定的；</strong></p>
<p><strong>这可以通过 Box 将 Future 移动到堆上解决：</strong></p>
<ul>
<li><p><a href="https://rust-lang.github.io/async-book/07_workarounds/04_recursion.html">https://rust-lang.github.io/async-book/07_workarounds/04_recursion.html</a></p>
<p><strong>另外也有一些库提供了 <code>#[async_recursion]</code> 宏，例如：</strong></p>
</li>
<li><p><a href="https://github.com/dcchut/async-recursion">https://github.com/dcchut/async-recursion</a></p>
</li>
</ul>
</blockquote>
<p>&lt;br/&gt;</p>
<h2><strong>小结</strong></h2>
<p>本文实现了 mini-redis 的连接层，主要包括下面几个部分：</p>
<ul>
<li>消息块 Frame：字节流抽象；</li>
<li>消息解析 Prase：RESP 完整实现；</li>
<li>连接管理 Connection：TCP 连接中的异步读写 Frame 块功能；</li>
</ul>
<p>&lt;br/&gt;</p>
<h1><strong>附录</strong></h1>
<p>源代码：</p>
<ul>
<li><a href="https://github.com/JasonkayZK/mini-redis">https://github.com/JasonkayZK/mini-redis</a></li>
</ul>
<p>系列文章：</p>
<ul>
<li><a href="https://jasonkayzk.github.io/2022/12/05/mini-redis项目-1-简介/">《mini-redis项目-1-简介》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/05/mini-redis项目-2-存储层/">《mini-redis项目-2-存储层》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/05/mini-redis项目-3-连接层/">《mini-redis项目-3-连接层》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/06/mini-redis项目-4-服务端/">《mini-redis项目-4-服务端》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/07/mini-redis项目-5-客户端/">《mini-redis项目-5-客户端》</a></li>
<li><a href="https://jasonkayzk.github.io/2022/12/07/mini-redis项目-6-测试与示例/">《mini-redis项目-6-测试与示例》</a></li>
</ul>
<p>文章参考：</p>
<ul>
<li><a href="https://redis.io/docs/reference/protocol-spec/">https://redis.io/docs/reference/protocol-spec/</a></li>
</ul>
<p>&lt;br/&gt;</p>
