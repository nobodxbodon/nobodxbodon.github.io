<h2><a href="https://github.com/f2h2h1/f2h2h1.github.io/blob/master/article/git的笔记.md">仓库源文</a>，<a href="https://f2h2h1.github.io/article/git的笔记">站点原文</a></h2>
<h1>git的笔记</h1>
<ul>
<li><p>在当前目录创建 git 仓库</p>
<pre><code>git init
</code></pre>
</li>
<li><p>把文件添加到暂存区</p>
<pre><code>git add 文件名
</code></pre>
</li>
<li><p>把暂存区的内容提交到当前分支</p>
<pre><code>git commit -m "这是注释"
</code></pre>
</li>
<li><p>克隆远程仓库</p>
<pre><code>git clone 远程仓库地址
</code></pre>
</li>
<li><p>克隆到指定的目录</p>
<pre><code>git clone 远程仓库地址 目录
</code></pre>
</li>
<li><p>更快的克隆</p>
<pre><code>git clone -b 分支名/标签 --single-branch --no-tags --depth=1  远程仓库地址 目录
--single-branch 仅克隆单一分支
--no-tags 不下载标签
--depth=1 浅层克隆（shallow clone），仅获取最近 1 个提交，而非完整历史
</code></pre>
</li>
<li><p>把远程仓库的修改更新到本地</p>
<pre><code>git pull
</code></pre>
</li>
<li><p>把本地修改推送到远程仓库，master 是远程分支名，这里可以替换成其它分支名</p>
<pre><code>git push origin master
</code></pre>
</li>
<li><p>新建 git 分支</p>
<pre><code>git branch 分支名
</code></pre>
</li>
<li><p>切换到分支</p>
<pre><code>git checkout 分支名
git switch 分支名
</code></pre>
</li>
<li><p>查看本地分支</p>
<pre><code>git branch
</code></pre>
</li>
<li><p>查看所有分支</p>
<pre><code>git branch -a
</code></pre>
</li>
<li><p>运行git命令时，遇到end符号且不能退出时，可以尝试按下键盘的q键</p>
</li>
<li><p>git 在 merge（合并）或 pull（拉取） 之前要提交所有修改</p>
</li>
<li><p>git 删除本地分支</p>
<pre><code>git branch -D 分支名
</code></pre>
</li>
<li><p>合并本地分支，把 某个分支 合并到当前分支</p>
<pre><code>git merge 分支名
</code></pre>
</li>
<li><p>合并远程分支，把 某个分支 合并到当前分支</p>
<pre><code>git merge 远程仓库名/分支名
</code></pre>
</li>
<li><p>查看git日志</p>
<pre><code>git log
</code></pre>
</li>
<li><p>更复杂的 log
```
只显示最近的两条记录
git log -2</p>
</li>
</ul>
<p>git fetch; git log --author="username@163.com"  --full-history --pretty="%h %S %ce %ci %s" --date-order --decorate=full --skip=0 --after="2023-12-31" --branches --tags --remotes
git fetch; git log --author="username@163.com"  --full-history --pretty="%h %S %ce %ci %s" --date-order --decorate=full --skip=0 --after="$(date -d "$(date +%Y%m01) last day" +%Y-%m-%d)" --branches --tags --remotes</p>
<pre><code>
- 新增远程仓库
</code></pre>
<p>git remote add 远程仓库名 远程仓库地址
例子
git remote add test3 ssh://username@127.0.0.1//alidata/www/.git</p>
<pre><code>
- 推送到不是 origin 的远程仓库
</code></pre>
<p>git push 远程仓库名</p>
<pre><code>
- 拉取不是 origin 的远程仓库
</code></pre>
<p>git pull 远程仓库名</p>
<pre><code>
- 查看远程仓库信息
</code></pre>
<p>git remote -v</p>
<pre><code>
- 远程仓重命名
</code></pre>
<p>git remote rename 旧名字 新名字</p>
<pre><code>
- 删除远程藏
</code></pre>
<p>git remote rm 仓库名</p>
<pre><code>
- 显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。
</code></pre>
<p>git status</p>
<pre><code>
- vscode git 的使用
</code></pre>
<p>更改-&gt;暂存的更改（add）-&gt;提交（commit）（提交暂存文件）-&gt;推送（push）</p>
<pre><code>
- git fetch 和 git pull 的区别
</code></pre>
<pre><code>1. git fetch：相当于是从远程获取最新版本到本地，不会自动合并。
git fetch origin master
git log -p master..origin/master
git merge origin/master
</code></pre>
<p>以上命令的含义：
首先从远程的origin的master主分支下载最新的版本到origin/master分支上然后比较本地的master分支和origin/master分支的差别最后进行合并
上述过程其实可以用以下更清晰的方式来进行：
    $ git fetch origin master:tmp
    $ git diff tmp 
    $ git merge tmp</p>
<pre><code>2. git pull：相当于是从远程获取最新版本并merge到本地 
git pull origin master
上述命令其实相当于git fetch 和 git merge在实际使用中，git fetch更安全一些，
因为在merge前，我们可以查看更新情况，然后再决定是否合并。
</code></pre>
<pre><code>
- 设置 gpg 用户id
</code></pre>
<p>git config user.signingkey [用户ID]</p>
<pre><code>
- 签名标签
</code></pre>
<p>git tag -s tagname -m 'msg'</p>
<pre><code>
- 验证标签的签名
</code></pre>
<p>git tag -v tagname</p>
<pre><code>
- 如果标签是经过签名的 git show ，能看到 GPG 签名附属在后面：
</code></pre>
<p>git show tagname</p>
<pre><code>
- 签名提交
</code></pre>
<p>git commit -S -m 'msg'</p>
<pre><code>
- 验证提交的签名
</code></pre>
<p>git verify-commit commitid</p>
<pre><code>
- 显示提交日志的签名
</code></pre>
<p>git log --show-signature -10</p>
<pre><code>
- 把上一次提交的内容退回到 暂存区
</code></pre>
<p>git reset --soft HEAD~1</p>
<pre><code>
- 追加修改
</code></pre>
<p>git commit --amend</p>
<pre><code>
- 追加修改后再推送，这是强制推送
</code></pre>
<p>git push -f</p>
<pre><code>
- 把所有文件从暂存区中移除，文件的修改不会有变化
</code></pre>
<p>git reset -q HEAD -- .</p>
<pre><code>
- 撤销工作区的所有的修改，不会影响暂存区
</code></pre>
<p>git checkout -- .</p>
<pre><code>
- 清理未追踪的文件
</code></pre>
<p>git clean -fd</p>
<pre><code>
- 回退到最新提交状态，会清空暂存区，重置工作区中已追踪的文件
</code></pre>
<p>git reset --hard</p>
<pre><code>
- 贮藏
</code></pre>
<p>git stash
git stash push
git stash pop
git stash apply
git stash list
git stash show
git stash drop
git stash clear</p>
<pre><code>
- 配置
    - 配置文件是 ini 格式
    - 范围
        - local 当前仓库 默认值
</code></pre>
<pre><code>        .git/config
        ```
    - global 当前用户
        ```
        ~/.gitconfig
        ```
    - system 系统
        ```
        /etc/.gitconfig
        ```
- 常用的配置项
    ```
    [core]
        repositoryformatversion = 0 仓库版本，用于未来能够兼容git版本，决定怎么处理git命令和文件的
        filemode = false 忽略文件权限的比较
        bare = false 不是裸仓
        logallrefupdates = true 启用引用日志，如果是裸仓则测试false
        symlinks = false 不使用软链接
        ignorecase = false 提交文件时区分大小写
        autocrlf = false 提交 和 检出 时都不修改换行符， true 是修改， input 是提交时修改，检出时不修改
        safecrlf = false 拒绝 提交有混合换行符的文件， true 是提交有混合换行符的文件， wram 允许 提交有混合换行符的文件 但会又警告
        在 windows 环境下，这两项 autocrlf safecrlf 最好搞个 system配置
    [user] 设置用户信息，这里的用户信息主要用在 commit ，多数情况下都建议设为 global配置
            name = username
            email = useremail
    [http] 设置代理
        proxy = http://127.0.0.1:6080
    [remote "origin"] 通常每个远程仓库都会有一个 section
    [branch "master"] 通常每个分支都会有一个 section
    ```
- 常用的命令
    ```
    查看某项配置，默认是 --local ，加上 --global --system 可以修改范围
    git config 配置项（section.key）
    git config user.name

    设置某项配置
    git config 配置项（section.key） 值
    git config user.name "username"

    查看git全部的配置项
    git config --list

    查看git local的配置项, --global --system 也是一样的
    git config --list --local

    克隆时指定一些设置
    git clone -c core.symlinks=true &lt;URL&gt;
    ```
</code></pre>
<ul>
<li><p>钩子 hook</p>
<ul>
<li><p>客户端 hook</p>
<pre><code>  在 .git/hooks 文件夹下新建脚本文件
  用 bash 写的，即使是 windows 环境下也是用 bash
  脚本文件名就是 hooks 名称，例如
  脚本文件名是 pre-commit ，就是 commit 之前运行的hook
  脚本文件名是 post-commit ，就是 commit 之后运行的hook
  脚本文件名是 pre-push ，就是 push 之后运行的hook

  参考文档
  https://git-scm.com/docs/githooks
</code></pre>
</li>
<li>服务端 hook</li>
</ul>
</li>
</ul>
<p>pre-commit</p>
<pre><code class="lang-bash">#!/bin/bash

# 获取暂存区中修改的文件列表
echo "获取暂存区文件..."
changed_files=$(git diff --cached --name-only)

# 检查是否有文件被修改
if [ -z "$changed_files" ]; then
    echo "没有暂存的文件"
    exit 0
fi

# 将文件列表按换行符分割成数组
IFS=$'\n' read -d '' -ra files &lt;&lt;&lt; "$changed_files"

# 创建一个数组来存储符合条件的文件
php_files=()

# 筛选出以 .php 和 .phtml 结尾的文件
echo "筛选 PHP 相关文件..."
for file in "${files[@]}"; do
    # 检查文件是否以 .php 或 .phtml 结尾
    if [[ "$file" == *.php ]] || [[ "$file" == *.phtml ]]; then
        # 检查文件是否存在（避免已删除的文件）
        if [ -f "$file" ]; then
            php_files+=("$file")
        fi
    fi
done

# 检查是否有符合条件的文件
if [ ${#php_files[@]} -eq 0 ]; then
    echo "没有找到 .php 或 .phtml 文件需要检测"
    exit 0
fi

# 显示要检测的文件
echo "检测以下文件："
for file in "${php_files[@]}"; do
    echo "  - $file"
done

# 使用 phpcs 对筛选出的文件进行格式检测
echo "开始代码格式检测..."

# phpcs_result=0
# for file in "${php_files[@]}"; do
#     echo "检测文件: $file"
#     # vendor/bin/phpcs --standard=Magento2 --warning-severity=3 "$file"
#     vendor/bin/phpstan analyse --no-progress --no-ansi -l 4 "$file"
#     if [ $? -ne 0 ]; then
#         phpcs_result=1
#     fi
#     echo "------------------------"
# done
# if [ $phpcs_result -eq 0 ]; then
#     echo "所有文件格式检测通过"
# else
#     echo "发现代码格式问题，请修复后重新提交"
#     exit 1
# fi

vendor/bin/phpstan analyse --no-progress --no-ansi -l 4 "${php_files[@]}"
if [ $? -eq 0 ]; then
    echo "所有文件格式检测通过"
    exit 0
else
    echo "发现代码格式问题，请修复后重新提交"
    exit 1
fi
</code></pre>
