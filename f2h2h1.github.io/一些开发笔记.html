<h2><a href="https://github.com/f2h2h1/f2h2h1.github.io/blob/master/article/一些开发笔记.md">仓库源文</a>，<a href="https://f2h2h1.github.io/article/一些开发笔记">站点原文</a></h2>
<h1>一些开发笔记</h1>
<h2>在 VSCode 里调试 JAVA</h2>
<ol>
<li>安装 JDK</li>
<li>把 JDK 添加进环境变量</li>
<li>安装 VSCode 的 JAVA extension pack 拓展</li>
<li>使用 VSCode 打开文件夹</li>
<li>新增一个 debug 的类型 JAVA ，点击右下角的添加配置，选择 JAVA Lanuch Program</li>
<li>写一份测试的代码，并在 mian 函数加个断点</li>
<li>然后在终端里运行编译命令和运行命令，如果编译命令不复杂，可以配合 code runner 拓展，直接点击右上角的运行图标，或设置一个任务</li>
</ol>
<h2>在 VSCode 里调试 Python</h2>
<ol>
<li>安装 Python</li>
<li>把 Python 的安装目录和安装目录下的 script 添加进环境变量里</li>
<li>在 VSCode 安装 Python 拓展（ microsoft 出品的）</li>
<li>新增一个 debug 的类型 Python ，点击右下角的添加配置，选择 Python: Terminal (integrated)</li>
<li>写一份测试的代码，并加个断点</li>
<li>然后在终端里运行，可以配合 code runner 插件，直接点击右上角的运行图标，或设置一个任务</li>
</ol>
<h2>在 Windows10 里修改 administrator 帐号的帐号名的三种方式</h2>
<ol>
<li><p>通过管理里的系统工具修改</p>
<pre><code>选中桌面中的计算机图标，右键，点击管理
系统工具
 本地用户和组
     用户
         选中Administrator，然后重命名
重启电脑
</code></pre>
</li>
<li><p>通过策略租修改</p>
<pre><code>win+r 打开运行
输入 gpedit.msc 打开策略组
计算机配置
 windows设置
     安全设置
         本地策略
             安全选项
                 拉到最下面
                 双击这个选选项 重命名系统管理员帐户
重启电脑
</code></pre>
</li>
<li><p>通过 netplwiz (Network Places Wizard) 网上邻居向导 修改</p>
<pre><code>win+r 打开运行
输入 netplwiz
选中Administrator，然后双击，然后修改
重启电脑
</code></pre>
</li>
</ol>
<h2>Windows10 无密码远程连接</h2>
<ol>
<li>允许任何远程着桌面的连接</li>
<li>修改 Windows 的安全策略，允许远程桌面连接使用空密码<pre><code>win+r 打开运行
输入 gpedit.msc 打开策略组
计算机配置
 windows 设置
     安全设置
         本地策略
             安全选项
                 拉到最下面
                 禁用 使用空密码的本地账户只允许控制台登录
</code></pre>
</li>
</ol>
<ul>
<li><p>电脑提示“账户名与安全标识间无任何映射完成”
一般是修改玩用户名后没有重启导致的。</p>
</li>
<li><p>因为公司的电脑不能设密码，同时我又想远程桌面公司的电脑，考虑到安全问题，不能用默认用户名裸奔，所以修改用户名和设置无密码的远程桌面</p>
</li>
</ul>
<h2>ss 的使用</h2>
<p>需要一个在 wall 以外的服务器</p>
<p>ss 的各个版本
<a href="https://github.com/shadowsocks/shadowsocks/wiki/Feature-Comparison-across-Different-Versions">https://github.com/shadowsocks/shadowsocks/wiki/Feature-Comparison-across-Different-Versions</a></p>
<h3>python</h3>
<ol>
<li>下载 python</li>
<li>安装 python</li>
<li>把 python 添加到环境变量</li>
<li>刷新环境变量</li>
<li>下载 ss<pre><code class="lang-shell"> python -m pip install shadowsocks
 # 如果上面那句下载失败，可以尝试用这句安装
 python -m pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
 # 如果上面那句还是下载失败，可以尝试先把 master.zip 文件下载到本地，再安装
</code></pre>
</li>
<li>在服务器的策略组放行相应的端口</li>
<li>在防火墙放行相应的端口</li>
<li>运行以下命令<pre><code class="lang-shell"> ssserver -p 61813 -k windows@163.qq -m aes-256-cfb
     -p 是端口号
     -k 是密码
     -m 是加密方式
 上面那条命令需要在 服务器的策略组 和 防火墙 放行 61813 端口
</code></pre>
</li>
<li>下载客户端</li>
<li>正确填写 ip 端口 密码</li>
<li>一些加密的算法会依赖这个库 libsodium ，最好把这个库也装上<pre><code> https://download.libsodium.org/libsodium/releases/
</code></pre>
</li>
<li>更新 ss<pre><code> python -m pip install --upgrade shadowsocks
 # 如果上面那句更新失败，可以尝试这样更新，先卸载再重新安装，卸载前记得先备份当前的版本
 python -m pip show shadowsocks
 python -m pip uninstall shadowsocks
 python -m pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
</code></pre>
</li>
<li>失效时，可以尝试，更改端口，更改密码，更改加密方式，换一个ip</li>
<li>参考<pre><code class="lang-plaintext"> https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E
</code></pre>
</li>
</ol>
<h3>libev</h3>
<ul>
<li>安装<ul>
<li>debian<pre><code>  apt update
  apt install shadowsocks-libev
</code></pre>
</li>
</ul>
</li>
<li>作为服务端运行<pre><code>  ss-server -s 0.0.0.0 -p 61813 -k windows@163.qq -m aes-256-cfb
  或者
  ss-server -c config.json
  {
      "server": "0.0.0.0",
      "server_port": 61813,
      "password": "windows@163.qq",
      "method": "aes-256-gcm"
  }
</code></pre>
  对应的文档 <a href="https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-server.asciidoc">https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-server.asciidoc</a></li>
<li>作为客户端运行<pre><code>  ss-local -s host -p 61813 -k windows@163.qq -m aes-256-cfb -l 1080
  或者
  ss-local -c config.json
  {
      "server": "host",
      "server_port": 61813,
      "local_address": "0.0.0.0",
      "local_port": 1080,
      "password": "windows@163.qq",
      "timeout": 600,
      "method": "aes-256-gcm"
  }
</code></pre>
  对应的文档 <a href="https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-local.asciidoc">https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-local.asciidoc</a></li>
</ul>
&lt;!--

用于定时启动的脚本
```
# ssserver-startup.ps1
$host.UI.RawUI.WindowTitle="ssserver"
ssserver -p 61304 -k windows@163.qq -m chacha20-ietf-poly1305
```

用于定时重启的脚本
```
# ssserver-restart.ps1
Get-Process | Where-Object {$_.MainWindowTitle -eq "ssserver"} ;
Get-Process | Where-Object {$_.MainWindowTitle -eq "ssserver" -and $_.Name -eq "powershell"} | Stop-Process ;
Get-Process | Where-Object {$_.MainWindowTitle -eq "ssserver" -and $_.Name -eq "python"} | Stop-Process ;
Get-Process | Where-Object {$_.MainWindowTitle -eq "ssserver"} | Stop-Process ;
powershell -File "C:\Users\Administrator\Desktop\ssserver-startup.ps1" ;
```

用于新建计划任务的命令
```
Register-ScheduledTask -TaskName "ssserver-restart" -Trigger (New-ScheduledTaskTrigger -Daily -At 2am) -Action (New-ScheduledTaskAction -Execute "powershell" -Argument " -File `"C:\Users\Administrator\Desktop\ssserver-restart.ps1`" ");
```

--&gt;

<h2>VS 和 VC 库 的对应关系</h2>
<table>
<thead><tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Visual Studio 6.0</td>
<td>VC6</td>
</tr>
<tr>
<td>Visual Studio .NET 2002</td>
<td>VC7.0</td>
</tr>
<tr>
<td>Visual Studio .NET 2003</td>
<td>VC7.1</td>
</tr>
<tr>
<td>Visual Studio 2005</td>
<td>VC8</td>
</tr>
<tr>
<td>Visual Studio 2008</td>
<td>VC9</td>
</tr>
<tr>
<td>Visual Studio 2010</td>
<td>VC10</td>
</tr>
<tr>
<td>Visual Studio 2012</td>
<td>VC11</td>
</tr>
<tr>
<td>Visual Studio 2013</td>
<td>VC12</td>
</tr>
<tr>
<td>Visual Studio 2015</td>
<td>VC14</td>
</tr>
<tr>
<td>Visual Studio 2017</td>
<td>VC15</td>
</tr>
<tr>
<td>Visual Studio 2019</td>
<td>VS16</td>
</tr>
<tr>
<td>Visual Studio 2022</td>
<td>VS17</td>
</tr>
</tbody>
</table>
<ul>
<li>Visual C++ 6.0 是 Visual Studio 6.0 的一部分，但可以独立安装，类似于 word 和  office 之间的关系</li>
<li>从 VC10 开始才有 64位</li>
<li>vc 库的下载地址 <a href="https://docs.microsoft.com/zh-CN/cpp/windows/latest-supported-vc-redist">https://docs.microsoft.com/zh-CN/cpp/windows/latest-supported-vc-redist</a></li>
</ul>
<h2>php 版本和 VC 库的对应关系</h2>
<table>
<thead><tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>5.2</td>
<td>vc6</td>
</tr>
<tr>
<td>5.3</td>
<td>vc9</td>
</tr>
<tr>
<td>5.4</td>
<td>vc9</td>
</tr>
<tr>
<td>5.5</td>
<td>vc11</td>
</tr>
<tr>
<td>5.6</td>
<td>vc11</td>
</tr>
<tr>
<td>7.0</td>
<td>vc14</td>
</tr>
<tr>
<td>7.1</td>
<td>vc14</td>
</tr>
<tr>
<td>7.2</td>
<td>vc15</td>
</tr>
<tr>
<td>7.3</td>
<td>vc15</td>
</tr>
<tr>
<td>7.4</td>
<td>vc15</td>
</tr>
<tr>
<td>8.0</td>
<td>vs16</td>
</tr>
<tr>
<td>8.1</td>
<td>vs16</td>
</tr>
</tbody>
</table>
<ul>
<li>其实下载下来的压缩包名有写着对应的 vc 库，系统位数， ts 和 nts</li>
</ul>
<h2>Windows 安全地删除U盘</h2>
<p>U盘 弹出失败的原因是进程占用了 U盘 ，只要占用 U盘 的进程都不在占用 U盘 或 都结束了， U盘 就可以安全地弹出了。</p>
<p>所以，让 U盘 安全地弹出的关键是找到占用 U盘 的进程。</p>
<p>当占用 U盘 的进程结束后，有时立即弹出 U盘 还是会失败的，这时再等待五六秒，再试一次弹出 U盘 就可以了。</p>
<p>可以安全退出 U盘 时也不要马上拔 U盘 ，最好等个五六秒再拔 U盘 。</p>
<p>这是各种方法的总结</p>
<ol>
<li>最简单的，在系统托盘右键，弹出，或在此电脑的界面，选中 U盘，右键，弹出</li>
<li>关掉所有文件夹再试一次弹出 U盘</li>
<li>explorer.exe 重启，再试一次弹出 U盘</li>
<li>注销当前的登录，再次登录，再试一次弹出 U盘</li>
<li>通过任务管理器找到占用 U盘 的进程<ol>
<li>打开任务管理器</li>
<li>切换到性能页面</li>
<li>打开资源监视器</li>
<li>切换到 cpu 页面</li>
<li>在 关联的句柄 栏目的搜索框内输入你的 U盘 盘符（如G:\）</li>
<li>即可看到当前占用 U盘 的进程</li>
</ol>
</li>
<li>关闭 U盘 的写入缓存<ol>
<li>控制面板</li>
<li>管理工具</li>
<li>计算机管理</li>
<li>设备管理</li>
<li>磁盘驱动</li>
<li>选择当前的 U盘</li>
<li>右键 属性 策略</li>
<li>关闭写缓存</li>
<li>关闭写缓存可能会造成 U盘 数据的丢失，关闭了写缓存后，要确保 U盘 里的文件已经保存好再弹出 U盘</li>
</ol>
</li>
<li>在磁盘管理里使 U盘 脱机<ol>
<li>控制面板</li>
<li>管理工具</li>
<li>磁盘管理</li>
<li>选择当前的 U盘</li>
<li>右键 脱机</li>
<li>U盘 脱机后下次插入要重新挂载，脱机之后可以马上联机，再安全弹出，这样 U盘 下次插入时就不用联机了</li>
<li>脱机会直接关掉所有的文件句柄，要确保 U盘 里的文件已经保存好再脱机</li>
<li>脱机选项不可选，可能是有虚拟内存分配到 U盘 ，这时取消在 U盘 上的虚拟内存即可<ul>
<li>进入电脑属性-&gt;高级系统设置-&gt;高级-&gt;性能设置-&gt;高级-&gt;更改，关闭自动管理分页文件大小，取消在该磁盘上设置的虚拟内存</li>
</ul>
</li>
<li>有时脱机还会失败，这时就继续参考下面的步骤</li>
</ol>
</li>
<li>通过 日志 查找占用 U盘 的进程<ol>
<li>打开事件查看器</li>
<li>windows日志</li>
<li>系统</li>
<li>找到最近的一条 来源 Kernel-PnP 的记录</li>
<li>记录的常规里有占用 U盘 的 进程id 的</li>
<li>再通过任务管理器的 pid 找到对应的进程</li>
<li>有时，即使找到占用 U盘 的进程，但却无法结束进程，或 进程是系统的核心进程<ul>
<li>这时可以尝试以这样的关键词（进程名 或 进程id + Kernel-PnP ）在网上搜索解决的方法</li>
</ul>
</li>
</ol>
</li>
<li>如果是 Windows Defender 占用 U盘 可以试试这样操作<ol>
<li>打开 Windows Defender 安全中心</li>
<li>病毒和威胁防护</li>
<li>病毒和威胁防护 设置</li>
<li>将在使用的 U盘 盘符添加为排除项</li>
</ol>
</li>
<li>最后的方法，关机，关机后就肯定可以安全地拔 U盘</li>
</ol>
<p>笔者通常在直接弹出 U盘 失败后，会多试几次，然后通过 日志 找到对应的进程，然后通过 任务管理器 结束对应的进程，如果结束进程失败，还是会再次在网上搜索解决方法。
脱机 和 关闭写缓存都有一点副作用；
关闭文件夹，重启 explorer.exe ，注销，关机，这类都有点麻烦。</p>
<h2>windows 下的 linux 环境</h2>
<ul>
<li>Git for Windows</li>
<li>mingw</li>
<li>mingw-w64</li>
<li>TDM-GCC</li>
<li>Cygwin</li>
<li>MSYS</li>
<li>MSYS2</li>
<li>gnuwin</li>
<li>windows10 子系统<ul>
<li>wsl1</li>
<li>wsl2</li>
</ul>
</li>
<li>虚拟机<ul>
<li>VMware</li>
<li>VirtualBox</li>
<li>Hyper-V</li>
<li>qemu</li>
</ul>
</li>
</ul>
<p>其实就三种套路</p>
<ul>
<li>子系统</li>
<li>虚拟机</li>
<li>运行在 win32 上的兼容层</li>
</ul>
<p>wsl1 和 wsl1 之前的 sfu/sua 是子系统， wsl2 其实算是虚拟机，其它的都是运行在 win32 上的兼容层。
nt 内核其实是有三个子系统 win32 ，os/2 和 posix ，只是除了 win32 其它两个都没有什么存在感。</p>
<p>所谓的 linux 环境，除了需要 bash 之外，还需要各种 linux 的工具，还需要处理管道，还需要处理文件名和路径的问题。
还有各种 linux api 的问题（但不写需要编译的代码，只使用环境中的工具，其实这个问题可以忽略的）。</p>
<h2>下载 AcFun 视频</h2>
<h3>0. 需求</h3>
<ol>
<li>一部安卓手机</li>
<li>AcFun 安卓版客户端</li>
<li>ffmpeg</li>
</ol>
<h3>1. 使用手机客户端缓存视频</h3>
<h3>2. 在手机的文件管理器里找到缓存文件</h3>
<ol>
<li>用文件管理器打开手机的根目录</li>
<li>找到 acfun 文件夹</li>
<li>点进这个目录里 acfun→core→local</li>
<li>然后点进一个以数字名命的文件夹</li>
<li>这个文件夹里就是缓存的视频，文件名都没有后缀，可以通过创建时间大致判断出哪个是最新缓存的视频</li>
</ol>
<h3>3. 在电脑里下载 ffmpeg</h3>
<ol>
<li>打开 ffmepg 的下载网址，并选择系统对应的版本下载<pre><code class="lang-plaintext">http://www.ffmpeg.org/download.html
</code></pre>
</li>
<li>把下载后的文件解压</li>
<li>解压后的文件里会有个一个名为 ffmpeg 的文件，这个就是 ffmpeg 的主程序，可以用来转换视频格式</li>
</ol>
<h3>4. 把缓存的视频文件复制进电脑，并使用 ffmpeg 转换为 MP4 格式</h3>
<ol>
<li>把缓存文件从手机复制进 ffempeg 的解压目录</li>
<li>cd 进 ffempeg 的解压目录</li>
<li>运行以下命令，转换格式后的文件名必须带有 MP4 的后缀<pre><code class="lang-bat">ffmpeg -i "缓存视频文件的文件名" "转换格式后的文件名"
</code></pre>
</li>
</ol>
<h2>在Windows下配置Tomcat服务器</h2>
<h3>0. 目标</h3>
<ul>
<li>在 Windows 下配置 Tomcat 服务器</li>
<li>Windows 10 (x64)</li>
<li>Tomcat 9</li>
<li>JAVA 8</li>
</ul>
<h3>1. 下载 JAVA</h3>
<pre><code class="lang-plaintext">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
</code></pre>
<p>选择，Windows 64 位</p>
<h3>2. 安装 JAVA</h3>
<p>打开下载的 exe 文件，一路点 next 直到安装完毕</p>
<h3>3. 配置 JAVA 环境变量</h3>
<ol>
<li><p>新建一个环境变量 JAVA_HOME ，值为 JDK 的安装目录，例子</p>
<pre><code class="lang-plaintext">C:\Program Files\Java\jdk1.8.0_161
</code></pre>
</li>
<li><p>把以下值加入到环境变量 Path</p>
<pre><code class="lang-plaintext">%JAVA_HOME%\bin
%JAVA_HOME%\jre\bin
%JAVA_HOME%\lib
</code></pre>
</li>
</ol>
<h3>3. 下载 Tomcat</h3>
<pre><code class="lang-plaintext">https://tomcat.apache.org/download-90.cgi
</code></pre>
<p>选择，core，Windows 64 位</p>
<h3>4. 配置 Tomcat</h3>
<ol>
<li>解压下载的文件</li>
<li>把解压后的文件夹复制到 C 盘的根目录下（这里可以是任意目录）</li>
<li>把 Tomcat 目录下的 bin 文件夹的路劲加入的环境变量</li>
<li>把网站程序复制进 Tomcat 的 webapps 文件夹</li>
<li>启动 Tomcat ，启动 Tomcat 的脚本在 bin\startup.bat</li>
</ol>
<h2>DOS 的启动过程</h2>
<ul>
<li>从启动盘中读取这两个系统文件<ul>
<li>IO.SYS</li>
<li>MSDOS.SYS</li>
</ul>
</li>
<li>启动盘的根目录下寻找并执行这三个文件<ul>
<li>CONFIG.SYS</li>
<li>COMMAND.COM</li>
<li>AUTOEXEC.BAT</li>
</ul>
</li>
<li>IO.SYS、MSDOS.SYS 和 COMMAND.COM 是系统的核心</li>
<li>CONFIG.SYS 用来配置系统运行环境</li>
<li>AUTOEXEC.BAT 用来自动执行一些批处理命令</li>
<li>IO.SYS、MSDOS.SYS 和 COMMAND.COM 其中一个缺失了，系统会无法启动</li>
<li>CONFIG.SYS 或 AUTOEXEC.BAT 缺失了，系统依然能启动，但一些软件或驱动可能无法正常运行</li>
</ul>
<h2>安装 PHP7 的 GUI 扩展</h2>
<h3>1 下载拓展</h3>
<ul>
<li><a href="https://pecl.php.net/package/ui">https://pecl.php.net/package/ui</a></li>
<li>按照本地的 PHP 版本下载对应的拓展文件</li>
</ul>
<h3>2 安装拓展</h3>
<ol>
<li>把下载下来的压缩包解压</li>
<li>把 php_ui.dll 复制到 PHP 的 ext 目录下</li>
<li>把 libui.dll 和 pthreadVC2.dll 放到 PHP 的根目录下</li>
</ol>
<h3>3 运行 demo</h3>
<ul>
<li>解压的压缩包里有四个 demo</li>
<li>gallery.php histogram.php snake.php starfield.php</li>
<li>可以使用命令行运行</li>
<li>例如 php snake.php</li>
<li>如果是 windows 系统，可以使用 php-win 运行，这样就没有黑框了</li>
</ul>
<h3>注意</h3>
<p>如果出现这种错误</p>
<blockquote><p>无法启动此程序，因为计算机中丢失 libui.dll，尝试重新安装该程序以解决此问题。</p>
</blockquote>
<p>这个提示出现说明你没有放入 libui 和 pthreadVC2 文件到 php 的根目录下</p>
<h2>linux 实现后台不间断运行</h2>
<ul>
<li>supervisor<ul>
<li>supervisor 是守护进程</li>
<li>supervisor 会根据配置运行对应的 start/stop/restart/reload 命令</li>
<li>supervisor 是子进程的父进程，子进程退出时，父进程能收到相关的信号 SIGCHLD ， supervisor 收到信号后就能执行相应的操作，例如重启进程</li>
<li>supervisor 不能监控守护进程是因为守护进程的父进程 id 不是 supervisor 的进程id，所以当守护进程退出时 supervisor 无法收到 SIGCHLD 信号</li>
</ul>
</li>
<li>screen/tmux 这类终端复用的软件<ul>
<li>tmux 分成两部分 server 和 client ，其中 server 是守护进程</li>
<li>通过 ssh 连接到服务器后 ssh server 会 fork 一个 shell ，远程终端就是显示这个 shell 的输入和输出</li>
<li>ssh 的 shell 能通过 tmux 的 clinet 让 tmux 的 server 再新建一个 shell</li>
<li>这个新建的 shell 的父进程是 tmux 的 server ，所以当前终端关闭不会关闭这个 shell ，从而达到了类似于后台运行的效果</li>
<li>大致的示意图<pre><code>  remote terminal &lt;----&gt; ssh server &lt;----&gt; shell &lt;----&gt; tmux client &lt;----&gt; tmux server &lt;----&gt; shell
</code></pre>
</li>
</ul>
</li>
<li>把代码改写成支持以 守护进程 的形式运行<ol>
<li>步骤<ol>
<li>fork子进程，父进程退出（必须）</li>
<li>子进程创建新会话（必须，setsid()）</li>
<li>改变当前工作目录 chdir（非必须，建议做 chdir("/var");）</li>
<li>重设子进程掩码（非必须 umask(0)）</li>
<li>关闭文件描述符（非必须）<pre><code> close(STDIN_FILENO);
 close(STDOUT_FILENO);
 close(STDERR_FILENO);
 // 另一种关闭文件描述符的方法，但 getdtablesize() 来自 unistd.h
 // for(i = 0; i &lt; getdtablesize(); i++) 
 // {
 //     close(i);
 // }
</code></pre>
</li>
<li>执行核心工作（必须）</li>
</ol>
</li>
<li>C 的例子<ul>
<li>新建源码文件 <code>vi deamon.c</code></li>
<li>代码<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
int main(int argc, char *argv[])
{
  pid_t pid = fork();
  if (pid &gt; 0) {
      exit(0); // 1.父进程退出
  } else if (pid == 0) {
      // 2.变为会话组长，脱离了控制终端 setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离
      setsid();
      // 3.改变进程的工作目录
      chdir("/var");
      // 4. 重置文件掩码
      umask(0);
      // 5. 关闭文件描述符
      close(STDIN_FILENO);
      close(STDOUT_FILENO);
      close(STDERR_FILENO);
      // 6. 执行核心操作
      // 每三秒一条记录到日志文件里，执行100次
      int fd = open("/var/temp-deamon-log.txt", O_CREAT | O_WRONLY | O_APPEND, 0664);
      int i;
      for (i = 0; i &lt; 100; i++) {
          sleep(3);
          time_t curtime;
          time(&amp;curtime);
          char* pt = ctime(&amp;curtime);
          write(fd, pt, strlen(pt) + 1);
      }
      close(fd);
  }
  return EXIT_SUCCESS;
}
</code></pre>
</li>
<li>编译运行命令<pre><code class="lang-shell">gcc deamon.c &amp;&amp; \
./a.out &amp;&amp; \
sleep 30 &amp;&amp; \
cat -n /var/temp-deamon-log.txt &amp;&amp; \
kill `ps -elf | grep a.out | awk '{print $4}'` &amp;&amp; \
rm /var/temp-deamon-log.txt
</code></pre>
</li>
</ul>
</li>
<li>这种是 sysvinit 体系下的 守护进程 ，虽然 systemd 也兼容，但 systemd 似乎会有不一样的更高效的实现。</li>
</ol>
</li>
<li>nohup 配合 &amp;<ul>
<li>nohup 的作用，nohup 英文全称 no hang up（不挂起）<ul>
<li>将 stdin 重定向到 /dev/null</li>
<li>将 stdout 和 stderr 重定向到 nohup.out 或者用户通过参数指定的文件</li>
<li>屏蔽掉 SIGHUP 信号，因为 SIGHUP 被屏蔽了，所以会话关闭后程序能继续运行</li>
<li>调用 exec 启动指定的命令</li>
</ul>
</li>
<li><code>&gt;&gt; out.log</code> 把输出追加到 <code>out.log</code> 文件里</li>
<li><code>2&gt;&amp;1</code> 把 stderr 重定向到 stdout</li>
<li>&amp; 的作用是把程序放到后台运行，但不会改变 stdin stdout stderr</li>
<li>例子 <code>nohup php queue.php &gt;&gt; out.log 2&gt;&amp;1 &amp;</code></li>
</ul>
</li>
<li>systemctl<ol>
<li>创建一个 service<ul>
<li>类型为 service 的 unit</li>
<li>在 <code>/etc/systemd/system</code> 目录新建一个文件 myDaemon.service<pre><code>  [Unit]
  Description=myDaemon service
  [Service]
  # service 的类型
  Type=simple
  # 退出后马上重启
  Restart=always
  # 这里的 bash 路径和脚本路径都必须是绝对路径
  ExecStart=/bin/bash /root/myDaemon.sh
  [Install]
  # 开机启动时的依赖项，大多数情况下都是填这个
  WantedBy=multi-user.target
</code></pre>
</li>
</ul>
</li>
<li>启动 service 并加入到开机启动中<pre><code> # 重新加载 systemctl 配置
 systemctl daemon-reload
 # 启动 myDaemon.service
 systemctl start myDaemon.service
 # myDaemon.service 加入到开机启动中
 systemctl enable myDaemon.service
</code></pre>
</li>
</ol>
</li>
<li>cron <strong>*</strong><ul>
<li>例子 <code>* * * * * php queue.php &gt;&gt; out.log 2&gt;&amp;1</code></li>
</ul>
</li>
<li>docker run 同时加上这两个参数 --restart always 和 -d ，也能达到类似的效果（docker 要设置好开机启动和服务）</li>
</ul>
<h2>gcc 编译流程</h2>
<p>编译的四个步骤</p>
<ol>
<li>预处理 由 .c 文件到 .i 文件。<ul>
<li>对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等</li>
</ul>
</li>
<li>编译 由 .i 文件到 .s 文件。<ul>
<li>将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标程序，得到机器语言的汇编文件</li>
</ul>
</li>
<li>汇编 由 .s 文件到 .o 文件。<ul>
<li>将汇编代码翻译成了机器码，但是还不可以运行</li>
</ul>
</li>
<li>链接 由 .o 文件到可执行文件。<ul>
<li>处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址</li>
</ul>
</li>
</ol>
<p>编译的四个步骤对应的 gcc 命令</p>
<pre><code>gcc -E test.c -o test.i
gcc -S test.i -o test.s
gcc -c test.s -o test.o
gcc test.o -o test
</code></pre>
<p>实际上 gcc 这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预处理器cpp、预编译程序cc1、汇编器as、链接器ld</p>
<pre><code>cpp test.c -o test.i
cc1 test.i -o test.s
as test.s -o test.o
ld test.o -o test
</code></pre>
<ul>
<li>头文件应该是在预处理阶段加上去的</li>
<li>各种库应该是在链接阶段加上去的</li>
</ul>
<h2>GNU 的命令</h2>
<p>GNU 工具链</p>
<ul>
<li>glibc</li>
<li>gcc</li>
<li>gdb</li>
<li>gnu make</li>
<li>gnu bison</li>
<li>autotools GNU构建系统（GNU Build System）又名Autotools<ul>
<li>autoscan</li>
<li>aclocal</li>
<li>autoconf</li>
<li>autoheader</li>
<li>automake</li>
</ul>
</li>
<li>binutils 二进制工具组<ul>
<li>as  汇编</li>
<li>ld 连接</li>
<li>nm 显示目标文件内的符号</li>
<li>ar 静态库归档</li>
<li>objdump 反汇编</li>
<li>readelf elf 结构分析工具</li>
</ul>
</li>
<li>coreutils GNU核心工具组<ul>
<li>fileutils 文件工具<ul>
<li>chgrp chown chmod cp ls mkdir rm touch</li>
</ul>
</li>
<li>textutils 文本工具<ul>
<li>cat head tail wc</li>
</ul>
</li>
<li>shellutils shell 工具<ul>
<li>echo printf nohup pwd sleep</li>
</ul>
</li>
</ul>
</li>
<li>findutils GNU查找工具组<ul>
<li>find</li>
<li>xargs</li>
</ul>
</li>
<li>bash</li>
<li>gzip</li>
<li>gnu grep</li>
<li>gnu awk</li>
<li>gnu sed</li>
<li>grub</li>
<li>...</li>
</ul>
<p>其它</p>
<ul>
<li>flex（快速词法分析产生器，英语：fast lexical analyzer generator）是一种词法分析程序。<ul>
<li>它是lex的开放源代码版本，以BSD许可证发布。</li>
<li>通常与 GNU bison 一同运作，但是它本身不是 GNU 计划的一部分。</li>
</ul>
</li>
<li>pkg-config 是一个在源代码编译时查询已安装的库的使用接口的计算机工具软件。 pkg-config 托管在 freedesktop.org 。 php 编译需要这个<ul>
<li>使用的效果大概像这样<pre><code># 没使用 pkg-config
gcc test.c -o test -I/usr/local/Cellar/opencv3/3.1.0_4/include/opencv -I/usr/local/Cellar/opencv3/3.1.0_4/include
# 使用了 pkg-config
gcc test.c -o test $(pkg-config opencv --cflags)
</code></pre>
</li>
</ul>
</li>
<li>BusyBox 是 GNU Core Utilities 的另一个开源替代，通常用在嵌入式系统里</li>
<li>util-linux, GNU 核心工具组中未包含的一组大约100个基本 Linux 系统实用程序，例如mount，fdisk，more和kill</li>
<li>IEEE Std 1003.1-2008 utilities<ul>
<li>这个列表中的UNIX实用程序由IEEE Std 1003.1-2008定义，是单一UNIX规范（SUS）的一部分。列表中的实用程序可以在UNIX操作系统和绝大多数类UNIX操作系统中找到。</li>
</ul>
</li>
</ul>
&lt;!--
bsdmainutils
net-tools 和 iproute2
inetutils
dnsutils
--&gt;

<p>参考</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/GNU%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%97%E8%A1%A8">https://zh.wikipedia.org/wiki/GNU%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%97%E8%A1%A8</a></li>
<li><a href="https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84">https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84</a></li>
</ul>
<p>感觉 GNU 真的除了内核之外，什么都有了。</p>
<h2>让网站支持 ipv6</h2>
<ol>
<li>拥有一个 ipv6 地址</li>
<li>域名解释 aaaa 记录指向 ipv6 的地址</li>
<li>让网站程序支持 ipv6 地址<ul>
<li>通过网关翻译<ul>
<li>代码里用 ipv4 地址，域名解释 aaaa 记录到 网关，网关把 ipv6 的流量翻译成 ipv4 的流量再传递给网站</li>
<li>代码里用 ipv6 地址，域名解释 a 记录到 网关，网关把 ipv4 的流量翻译成 ipv6 的流量再传递给网站</li>
</ul>
</li>
<li>让 web 服务器同时监听两个地址，代码里和 ip 相关的部分，都改成能兼容 ipv4 和 ipv6</li>
</ul>
</li>
</ol>
<p>用来测试网站对 ipv6 的支持，也可以用来查看 DNSSEC 的支持
<a href="https://ipv6.ustc.edu.cn/onlinechecklog.php">https://ipv6.ustc.edu.cn/onlinechecklog.php</a></p>
<h2>在命令行里格式化 json</h2>
<ol>
<li><p>python 的 json.tool ，好像 python2 和 3 都可以这样用</p>
<pre><code> echo '{ "name": "xiaohong", "age": 18 }' | python -m json.tool
</code></pre>
<ul>
<li>会转义中文，如果想不转义中文</li>
<li>需要修改标准库里的文件，这样不是很好，在 python 的标准库 json 文件夹下有个 tool.py 文件，更改其中调用的 json.dump 函数，传一个ensure_ascii = False 参数即可</li>
</ul>
</li>
<li><p>json_pp ， windwos 的 git bash 和 大多数 linux 发行版都有这个工具</p>
<pre><code> echo '{ "name": "xiaohong", "age": 18 }' | json_pp
</code></pre>
</li>
<li><p>jq ， 虽然大多数 linux 发行版都没有这个工具，但中文互联网环境下有好多文章都推荐这个</p>
<ul>
<li>下载 <a href="https://stedolan.github.io/jq/download/">https://stedolan.github.io/jq/download/</a></li>
<li>文档 <a href="https://stedolan.github.io/jq/manual/">https://stedolan.github.io/jq/manual/</a></li>
</ul>
</li>
<li><p>php 的命令行，标准输入中一定要有数据，不然会一直等待；同样地 python 或 node 也可以实现类似的</p>
<pre><code> echo '{ "name": "xiaohong", "age": 18, "chinese character":"汉字" }' | \
 php -r 'print(json_encode(json_decode(file_get_contents("php://stdin")),JSON_PRETTY_PRINT|JSON_UNESCAPED_UNICODE));';
</code></pre>
</li>
<li><p>PowerShell 的 ConvertFrom-Json 和 ConvertTo-Json ，这两个要组合来使用</p>
<pre><code> echo '{"type":"image","offset":0,"count":20}' | ConvertFrom-Json | ConvertTo-Json
</code></pre>
</li>
</ol>
<p>配合 curl 使用</p>
<pre><code>curl -s -k https://localhost/dev.json | json_pp
curl -s -k https://localhost/dev.json | python -m json.tool
</code></pre>
<ul>
<li>-s 只输出 body</li>
<li>-k 忽略 https</li>
</ul>
<p>配合 PowerShell 的 Invoke-WebRequest 使用</p>
<pre><code>Invoke-WebRequest https://localhost/dev.json -UseBasicParsing -SkipCertificateCheck | Select -ExpandProperty Content | ConvertFrom-Json | ConvertTo-Json
Invoke-WebRequest https://localhost/dev.json -UseBasicParsing -SkipCertificateCheck | Select -ExpandProperty Content | python -m json.tool
</code></pre>
<ul>
<li>-UseBasicParsing 把结果输出到命令行</li>
<li>-SkipCertificateCheck 忽略 https ，这个参数要在 PowerShell6 之后才有效</li>
<li>Select -ExpandProperty Content 选取 body 的输出</li>
</ul>
<p>如果 Invoke-WebRequest 出现了这种错误。</p>
<pre><code>因为 Internet Explorer 引擎不可用，或者 Internet Explorer 的首次启动配置不完整
</code></pre>
<p>可以尝试以下步骤来解决</p>
<ol>
<li>打开 IE 的 internet 选项</li>
<li>点击安全选项卡，选中本地 intranet ，并点击站点按钮</li>
<li>新的窗口中点击高级</li>
<li>添加 about:security_powershell.exe 到输入框，点击添加</li>
<li>把所有 IE 窗口一个个关闭就好了，再次在 powershell 下运行 Invoke-WebRequest</li>
</ol>
<h2>Windows 里的 Java 环境配置</h2>
<ol>
<li>下载并安装 JDK<ul>
<li>这些是免费的 JDK<ul>
<li><a href="https://openjdk.java.net/">https://openjdk.java.net/</a></li>
<li><a href="https://www.microsoft.com/openjdk">https://www.microsoft.com/openjdk</a></li>
<li><a href="https://adoptopenjdk.net/">https://adoptopenjdk.net/</a></li>
<li><a href="https://www.azul.com/downloads/?package=jdk">https://www.azul.com/downloads/?package=jdk</a></li>
<li><a href="https://developers.redhat.com/products/openjdk/download">https://developers.redhat.com/products/openjdk/download</a></li>
</ul>
</li>
<li>这是 oracle 的 JDK<ul>
<li><a href="https://www.oracle.com/java/">https://www.oracle.com/java/</a></li>
</ul>
</li>
<li>如果是 JDK 1.8 以上的版本，笔者比较倾向于用 microsoft 的 openjdk</li>
<li>通常只有 oracleJDK 需要安装，其他的 JDK 都是压缩包，直接解压就好了</li>
</ul>
</li>
<li>把 JDK 加入环境变量<ol>
<li>新建一个新的环境变量 JAVA_HOME ，值是 JDK 的根目录</li>
<li>在 PATH 里加入 %JAVA_HOME%\bin 和 %JAVA_HOME%\lib 和 %JAVA_HOME%\jre\bin （如果没有这个目录就忽略）</li>
<li>如果是 JDK 1.5 及之前的版本还需要一个 CLASSPATH 的环境变量<ul>
<li>CLASSPATH 的值是 .;%Java_Home%\bin;%JAVA_HOME%\lib;%Java_Home%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li>
</ul>
</li>
</ol>
</li>
<li>下载并安装 maven<ul>
<li><a href="https://maven.apache.org/">https://maven.apache.org/</a></li>
</ul>
</li>
<li>把 maven 加入环境变量<ol>
<li>新建一个新的环境变量 MAVEN_HOME ，值是 maven 的根目录</li>
<li>在 PATH 里加入 %MAVEN_HOME%\bin</li>
</ol>
</li>
</ol>
<p>windows10 之前的系统在修改 path 时要注意分号 ;</p>
<p>在 JDK1.5 以后，classpath 并不是必须配置了，在 JDK1.5 之前，是没有办法在当前目录下加载类的（找不到 JDK 目录下 lib 文件夹中的 .jar 文件），所以我们需要通过配置 classpath ，但 JDK1.5 之后， JRE 能自动搜索目录下类文件，并且加载 dt.jar 和 tool.jar 的类。
dt.jar 是关于运行环境的类库，主要是用于 swing 的包，如果不使用可以不配置。
tools.jar 是工具类库。</p>
<p>编译和运行时可以通过参数 -classpath 指定 classpath 的路径，例如这样</p>
<pre><code>javac -encoding UTF-8 -classpath .;./junit4.jar;./org.hamcrest.core_1.3.0.jar AaaTest.java JunitRunner.java
java -Dfile.encoding=UTF-8 -classpath .;./junit4.jar;./org.hamcrest.core_1.3.0.jar JunitRunner
</code></pre>
<h2>无法执行 powershell 脚本</h2>
<p>通常是执行策略的原因导致的。</p>
<p>设置脚本执行策略，通常把 策略 设为 RemoteSigned 就可以了</p>
<pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine
</code></pre>
<p>查看 powershell 脚本执行策略</p>
<pre><code>Get-ExecutionPolicy
Get-ExecutionPolicy -List
</code></pre>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2">https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2</a></p>
<h2>python 的 http 服务和 cgi</h2>
<p>python 一行命令启动 http 服务</p>
<pre><code class="lang-sh"># 最简单的 http 服务
python -m http.server
# 有 cgi 的 http 服务
python -m http.server --cgi
# 有 cgi 的和指定端口号的 http 服务
python -m http.server --cgi 8081
# 有 cgi 的，指定端口号的和指定ip地址的 http 服务
python -m http.server --cgi 8081 --bind 127.0.0.1
# 有 cgi 的，指定端口号的，指定ip地址的和指定站点根目录的 http 服务
python -m http.server --cgi 8081 --bind 127.0.0.1 --directory _book
</code></pre>
<ul>
<li>所有 cgi脚本或程序 都必须有执行权限；在 linux 环境下是 755 ，整个路径都必须是可读可执行的。</li>
<li>默认情况下 cgi脚本或程序 要在这个目录下 /cgi-bin 。</li>
<li>windows 环境下 py 脚本开头那句 #! 是没有效果的，其实在 windows 环境下没有开头那句也没问题的。</li>
<li>windows 环境下只要不是 py 后缀的都会被当成 可执行文件， linux 可以执行其他脚本。</li>
<li>端口号要在 --cgi 参数后面。</li>
<li>无法设置 响应行 和 响应码，响应码都是 200 。 (<del>起码 3.10 还是这样</del>)</li>
</ul>
<p>请求 cgi 脚本的例子</p>
<pre><code>curl 127.0.0.1:8000/cgi-bin/test.py
</code></pre>
<p>cgi 脚本的例子</p>
<pre><code class="lang-python">#!/usr/bin/python3

print ("Content-type:text/html")
print ()                             # 空行，告诉服务器结束头部
print ('&lt;html&gt;')
print ('&lt;head&gt;')
print ('&lt;meta charset="utf-8"&gt;')
print ('&lt;title&gt;Hello Word&lt;/title&gt;')
print ('&lt;/head&gt;')
print ('&lt;body&gt;')
print ('&lt;h2&gt;Hello Word!&lt;/h2&gt;')
print ('&lt;/body&gt;')
print ('&lt;/html&gt;')
</code></pre>
<pre><code class="lang-python">#!/usr/bin/python3

print ("Content-type: application/json")
print ()                             # 空行，告诉服务器结束头部
print ('{"result": "this is a test"}')
</code></pre>
<p>这个例子大致相当于这个命令 <code>python -m http.server 8888</code></p>
<pre><code class="lang-python">from http.server import HTTPServer, SimpleHTTPRequestHandler

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, SimpleHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
</code></pre>
<p>这个例子大致相当于这个命令 <code>python -m http.server --cgi 8888</code></p>
<pre><code class="lang-python">from http.server import HTTPServer, CGIHTTPRequestHandler

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, CGIHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
</code></pre>
<p>不使用命令行的 http 服务例子，这是单线程的</p>
<pre><code class="lang-python">from http.server import HTTPServer, BaseHTTPRequestHandler
import json

class myHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps({'result': 'this is a test'}).encode())

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = HTTPServer(host, myHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
</code></pre>
<p>不使用命令行的 http 服务例子，这是多线程的</p>
<pre><code class="lang-python">from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
import json

class ThreadingHttpServer(ThreadingMixIn, HTTPServer):
    pass

class myHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps({'result': 'this is a test'}).encode())

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = ThreadingHttpServer(host, myHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
</code></pre>
<p>不使用命令行的 http 服务例子，这是多线程的，再加上 cgi 的支持</p>
<pre><code class="lang-python">from http.server import HTTPServer, CGIHTTPRequestHandler
from socketserver import ThreadingMixIn

class ThreadingHttpServer(ThreadingMixIn, HTTPServer):
    pass

if __name__ == '__main__':
    host = ('0.0.0.0', 8888)
    server = ThreadingHttpServer(host, CGIHTTPRequestHandler)
    print('Serving HTTP on {host} port {port} (http://{host}:{port}/) ...'.format(host=host[0], port=host[1]))
    server.serve_forever()
</code></pre>
<p>HTTPServer 和 BaseHTTPRequestHandler 是两个关键的类，一个用于接收 http 请求，一个用于处理请求，其它类基本是派生自这两个类</p>
<pre><code>BaseHTTPRequestHandler -&gt; SimpleHTTPRequestHandler -&gt; CGIHTTPRequestHandler
HTTPServer -&gt; ThreadingHttpServer
</code></pre>
<p>参考文档</p>
<ul>
<li><a href="https://www.runoob.com/python3/python3-cgi-programming.html">https://www.runoob.com/python3/python3-cgi-programming.html</a></li>
<li><a href="https://docs.python.org/zh-cn/3/library/cgi.html">https://docs.python.org/zh-cn/3/library/cgi.html</a></li>
<li><a href="https://docs.python.org/zh-cn/3/library/http.server.html">https://docs.python.org/zh-cn/3/library/http.server.html</a></li>
</ul>
&lt;!--

java 中类似的命令，来自 jdk18 jep408
java -m jdk.httpserver [-b bind address] [-p port] [-d directory] [-h to show help message] [-o none|default|verbose]
```
java -m jdk.httpserver -b 127.0.0.1 -p 80
java -m jdk.httpserver -b 127.0.0.1 -p 80 -d ~/wwwroot
java -m jdk.httpserver -b 127.0.0.1 -p 80 -d ~/wwwroot -o verbose
```

php 中类似的命令
php [options] -S &lt;addr&gt;:&lt;port&gt; [-t docroot] [router]
```
php -S 127.0.0.1:80
php -S 127.0.0.1:80 -t ~/wwwroot
php -S 127.0.0.1:80 -t ~/wwwroot router.php
```

ruby -run -e httpd . -p8000
busybox httpd -f -p 8000

go prel nodejs .net 都有类似的一句话服务，但需要安装相应的包

nc 理论上也可以实现，但一行代码会写得非常长

--&gt;

<h2>debian 一句命令安装 docker</h2>
<p>因为要经常部署和重装系统，所以就整理了这样一句命令，可能会因为 docker 的更新而失效，要注意修命令里的版本号</p>
<p>具体环境</p>
<ul>
<li>debian 11</li>
<li>Docker version 20.10.12, build e91ed57</li>
<li>docker-compose version 1.29.2, build 5becea4c</li>
</ul>
<p>这是文档
<a href="https://docs.docker.com/engine/install/debian/">https://docs.docker.com/engine/install/debian/</a></p>
<pre><code class="lang-bash">sudo apt-get remove -y docker docker-engine docker.io containerd runc ; \
sudo apt-get update &amp;&amp; \
sudo apt-get install -y \
    ca-certificates \
    curl \
    gnupg \
    lsb-release &amp;&amp; \
if [ -e /usr/share/keyrings/docker-archive-keyring.gpg ] ; \
  then rm /usr/share/keyrings/docker-archive-keyring.gpg; \
  else curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ;fi &amp;&amp; \
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null &amp;&amp; \
sudo apt-get update &amp;&amp; \
sudo apt-get install -y docker-ce docker-ce-cli containerd.io &amp;&amp; \
sudo docker run --rm hello-world &amp;&amp; \
sudo curl -L --retry 100 --retry-delay 2 "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose &amp;&amp; \
sudo chmod +x /usr/local/bin/docker-compose &amp;&amp; \
docker-compose --version
</code></pre>
<p>如果 docker-compose 总是下载失败，可以尝试使用这样的脚本下载</p>
<pre><code class="lang-bash">COMMAND="curl -L https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose"
for ((i=0;i&lt;100;i++))
do
    $COMMAND
    if [ $? -eq 0 ]; then
        exit 0;
    fi
done
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
</code></pre>
<h2>生成用于测试的容器的命令</h2>
<p>具体环境</p>
<ul>
<li>debian 11</li>
<li>Docker version 20.10.12, build e91ed57</li>
</ul>
<pre><code>docker pull debian:11

docker run \
    -it \
    --rm \
    -p 443:443 \
    debian:11 /bin/bash

cp /etc/apt/sources.list /etc/apt/sources.list_bak &amp;&amp; \
sed -i 's/deb.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.list &amp;&amp; \
apt update &amp;&amp; \
apt install -y vim &amp;&amp; \
apt install -y curl &amp;&amp; \
apt install -y net-tools &amp;&amp; \
apt install -y netcat &amp;&amp; \
apt install -y procps

apt install -y bsdmainutils
apt install -y python3
apt install -y python3-pip
</code></pre>
<h2>curl 断点续传</h2>
<p>例子</p>
<pre><code>curl -C - -o php-7.3.11.tar.gz https://www.php.net/distributions/php-7.3.11.tar.gz
</code></pre>
<p>解释</p>
<pre><code>-L 允许重定向
-C 开启断点续传
 - 这个表示开始和结束位置，一般就这样就可以了
--retry 100 超时重试 100 次，也可以是断点续传时的重试
--retry-delay 5 每次超时后等待 5 秒再重试
--connect-timeout 5 连接超过 5 秒算超时
    一次连接超时时间。如果出错， 提示形如：curl: (28) connect() timed out!
--max-time 10 单次请求的最大时间
    一次连接过程最大的允许时间。出错提示如：curl: (28) Operation timed out after 2000 milliseconds with 0 bytes received
--max-time 要大于 --connect-timeouts
--retry-max-time 30 整体请求的最大时间
-o 参数将服务器的回应保存成文件
-O 参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。
如果服务器主动返回 失败 例如 reset 这类的，就会直接退出的了，不论有没有设置 --retry
</code></pre>
<p>github 好像不支持断点下载</p>
<h2>在 debian 新建命令的别名</h2>
<ul>
<li>只对当前终端有效<ul>
<li>直接运行这个命令 <code>alias ll="ls -l "</code></li>
</ul>
</li>
<li>终端退出后仍然有效<ul>
<li>在 ./bashrc 里加上一行 <code>alias ll="ls -l "</code></li>
<li>然后运行这个命令 source ~/.bashrc</li>
</ul>
</li>
</ul>
<h2>用于 git pull 和 git push 的脚本</h2>
<p>因为 github 的 pull 和 push 总是超时，所以写了两段脚本用于失败后的自动重试</p>
<pre><code class="lang-bash">#!/bin/bash

# ./git_help.sh pull
# ./git_help.sh push

GIT_COMMAND="git "
case $1 in
    "push"|"pull")
        GIT_COMMAND=$GIT_COMMAND$1
    ;;
    *)
        echo "only input push or pull";
        exit 1;
    ;;
esac

for ((i=0;i&lt;100;i++))
do
    $GIT_COMMAND
    if [ $? -eq 0 ]; then
        exit 0;
    fi
done
</code></pre>
<pre><code class="lang-powershell"># ./git_help.ps1 pull
# ./git_help.ps1 push

param($a)
$GIT_COMMAND = "git "
if ($a -eq "push") {
  $GIT_COMMAND = $GIT_COMMAND + $a
} elseif ($a -eq "pull") {
  $GIT_COMMAND = $GIT_COMMAND + $a
} else {
  echo "only input push or pull"
  exit 1
}

for ($i = 1; $i -lt 100; $i++) {
  echo $i" "$GIT_COMMAND
  PowerShell -command $GIT_COMMAND
  # Invoke-Expression $GIT_COMMAND
  # Invoke-Command -ScriptBlock {Write-Host $GIT_COMMAND}
  # Invoke-Command -ScriptBlock {$GIT_COMMAND}
  if ($? -eq $true) {
    break
  }
}
</code></pre>
<h2>href 和 src</h2>
<p>href 是 Hypertext Reference (超文本引用) 的缩写。
href 目的是为了建立联系，让当前标签能够链接到目标地址。</p>
<p>src 是 source (来源) 的缩写。
指向的内容将会应用到文档中当前标签所在位置。
例如 img 和 script 的 src 属性。</p>
<p>href 和 src 的值通常是 url 但也可以不是 url 。
其中一个例子就是 img 标签的 src 可以直接放 base64 的值。</p>
<p>可以简单但不严谨地理解为 href 不会加载， src 会加载。
这样解释好象很有道理。
但 link 标签是用 href 的。
link 标签能加载 css 和 页面图标 还有 manifest 还有 预加载的 js 。</p>
<h2>URI URL URN</h2>
<p>它们的全称</p>
<ul>
<li>URI: Uniform Resource Identifier (统一资源标识符)</li>
<li>URN: Uniform Resource Name (统一资源名称)</li>
<li>URL: Uniform Resource Locator (统一资源定位符)</li>
<li>URC: Uniform Resource Characteristic (统一资源特征)</li>
</ul>
<p>URL，URN，URC 都属于 URI 。
语法都是</p>
<pre><code>URI = scheme ":" scheme-specific-part
URI = scheme ":" ["//" authority] path ["?" query] ["#" fragment]
authority = [userinfo "@"] host [":" port]
</code></pre>
<p>一些例子</p>
<pre><code>          userinfo       host      port
          ┌──┴───┐ ┌──────┴──────┐ ┌┴┐
  https://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top
  └─┬─┘   └───────────┬──────────────┘└───────┬───────┘ └───────────┬─────────────┘ └┬┘
  scheme          authority                  path                 query           fragment

  ldap://[2001:db8::7]/c=GB?objectClass?one
  └┬─┘   └─────┬─────┘└─┬─┘ └──────┬──────┘
  scheme   authority   path      query

  mailto:John.Doe@example.com
  └─┬──┘ └────┬─────────────┘
  scheme     path

  news:comp.infosystems.www.servers.unix
  └┬─┘ └─────────────┬─────────────────┘
  scheme            path

  tel:+1-816-555-1212
  └┬┘ └──────┬──────┘
  scheme    path

  telnet://192.0.2.16:80/
  └─┬──┘   └─────┬─────┘│
  scheme     authority  path

  urn:oasis:names:specification:docbook:dtd:xml:4.1.2
  └┬┘ └──────────────────────┬──────────────────────┘
  scheme                    path
</code></pre>
<h3>URN</h3>
<p>URN 的作用是描述资源的身份，例如 一个人的名字。 URN 的其中一个应用例子是 图书的 ISBN 号码 。</p>
<p>URN 的语法</p>
<pre><code>urn:NID:NSS
</code></pre>
<p>NID 是 namespace identifier （命名空间标识符） 的缩写。</p>
<p>NSS 是 namespace specific string （命名空间特定字符串） 的缩写。</p>
<p>URN 的 NID 和 NSS 部分相当于 URI 里的 path 部分。</p>
<h3>URL</h3>
<p>URL 的作用是描述资源的访问路径，例如 一个人的住址。</p>
<p>URL 的语法</p>
<pre><code>                    hierarchical part
        ┌───────────────────┴─────────────────────┐
                    authority               path
        ┌───────────────┴───────────────┐┌───┴────┐
  abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1
  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
scheme  user information     host     port                  query         fragment
</code></pre>
<h3>其它</h3>
<p>URC (统一资源特征)，在九十年代的时候， URL URI URC 被期望能组成一个互联网信息架构。
但 URC 一直停留在理论阶段，随之更晚出现的其他技术（例如 资源描述框架）取代了它们。</p>
<p>URI 的 scheme 和 URN 的 NID 都需要在 IANA 注册。</p>
<p>完整的 url 或 urn 会被称为绝对 uri ，
只有一部分的 url 或 urn 会被称为相对 uri 。</p>
<p>还有一个 Data URI 或者叫做 Data URL 。
这是具体的语法，也属于 URI 。</p>
<pre><code>dataurl    := "data:" [ mediatype ] [ ";base64" ] "," data
mediatype  := [ type "/" subtype ] *( ";" parameter )
data       := *urlchar
parameter  := attribute "=" value
</code></pre>
<p>比较好区分的一个特征是，以 urn 开头的 uri 就一定是 urn ，
以 data 开头的 uri 就一定是 data url 。
除此之外的都是 url 。</p>
<p>url 两个斜杆 // 其实是没什么作用的</p>
<ul>
<li>联网创始人蒂姆·伯纳斯-李承认，互联网地址中http:后面的两条斜线并无必要。伯纳斯-李解释说，虽然当时的编程惯例是双斜线，但结果并非真正必要。<ul>
<li><a href="https://www.zhihu.com/question/20035144">https://www.zhihu.com/question/20035144</a></li>
<li><a href="http://news.bbc.co.uk/2/hi/technology/8306631.stm">http://news.bbc.co.uk/2/hi/technology/8306631.stm</a></li>
<li><a href="https://www.cnbeta.com/articles/95565.htm">https://www.cnbeta.com/articles/95565.htm</a></li>
</ul>
</li>
<li>虽然是这样，但 // 开头的 url 可以兼容 http 和 https 的链接</li>
</ul>
<p>为什么文件 URL 以3斜杠开头？</p>
<ul>
<li>file:/// 之所以是三个斜杆，是因为忽略了主机名，更完整的 url 应该是这样的 file://host/</li>
<li>这两句 curl 的命令效果是一样的<pre><code>  curl -i -v file:///C:/Users/example.txt
  curl -i -v file://localhost/C:/Users/example.txt
</code></pre>
</li>
</ul>
&lt;!-- RFC1738 RFC8089 --&gt;

&lt;!--

host name = 主机名
domain name = 域名

FQDN
Fully Qualified Domain Name
完全 合规 域 名

PQDN
Partially Qualified Domain Name
部分 合规 域 名

FQDN = 主机名 + 域名

主机名可以命名为“部分合格的域名”。
因为主机名不提供域名。
我们只有知道或自动将域名添加到主机名时才能使用主机名。
例如，如果我们在同一个域中，则可以使用PQDN进行通信和规范。

域名的一种，能指定其在域名系统 (DNS) 树状图下的一个确实位置

主机名
一些语境下是指 FQDN
一些语境下是指 FQDN 中 最左边 或 查询过程中最后的一部分

域名
一些语境下是指 FQDN
一些语境下是指 FQDN 中除去 主机名 的部分

FQDN 中 最左边 或 查询过程中最后的一部分 有时也会被称为 服务名


主机名就机器本身的名字，域名是用来解析到IP的


--&gt;

<h3>参考</h3>
<ul>
<li>uri <a href="https://datatracker.ietf.org/doc/html/rfc3986">https://datatracker.ietf.org/doc/html/rfc3986</a></li>
<li>uri url run 之间的关系 <a href="https://datatracker.ietf.org/doc/html/rfc3305">https://datatracker.ietf.org/doc/html/rfc3305</a></li>
<li>data url <a href="https://datatracker.ietf.org/doc/html/rfc2397">https://datatracker.ietf.org/doc/html/rfc2397</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_URI_schemes">https://en.wikipedia.org/wiki/List_of_URI_schemes</a></li>
</ul>
<h2>linux 系统的启动流程</h2>
&lt;!--
1. 通电
1. 运行主板 ROM 里面的 BIOS
1. BIOS 加电自检 (POST, Power-On Self-Test) ，就是检查硬件
1. BIOS 根据指定的顺序，读取 MBR 中的引导程序（bootloader）
1. 启动 MBR 中的 GRUB （ linux 通常用 GRUB 作为引导程序）
1. GRUB 把 linux 内核加载到内存并把控制交给内核
1. 内核内存中自解压之后就将控制权交给 init 进程
    - init 进程 通常是 systemd 或 init（SysV init）
    - 大多数 linux 发行版选择了 systemd

大致是
    bios 内核引导 init getty login shell
--&gt;

<ol>
<li>通电</li>
<li>加电自检 (POST, Power-On Self-Test)</li>
<li>硬件初始化<ul>
<li>legacy BIOS<ul>
<li>MBR</li>
</ul>
</li>
<li>UEFI<ul>
<li>GPT</li>
</ul>
</li>
</ul>
</li>
<li>执行引导程序 (bootloader)<ul>
<li>LILO (LInux LOader)</li>
<li>SYSLINUX</li>
<li>GRUB (GNU Grand Unified Bootloader)</li>
</ul>
</li>
<li>加载和启动 linux 内核镜像<ul>
<li>initrd</li>
<li>initramfs</li>
</ul>
</li>
<li>执行 init<ul>
<li>init (SystemV init)</li>
<li>UpStart</li>
<li>systemd (system deamon)</li>
</ul>
</li>
<li>执行守护进程</li>
</ol>
<p>现在主流的启动过程是</p>
<pre><code>MBR -&gt; GRUB -&gt; initramfs -&gt; systemd
</code></pre>
<p>简单但又不严谨地理解， init 是第一个运行在用户态的进程。
这里描述的 init 可能是 SystemV init 也可能是 UpStart 也可能是 systemd 。</p>
<p>笔者认为作为一个写上层应用的程序员，了解到 加载和启动 linux 内核镜像 这一层就已经足够深入的了。</p>
<h2>获取本机公网 IP 的几个方法</h2>
<pre><code class="lang-bash"># 获取本机公网 IP 
curl ifconfig.me
curl icanhazip.com
curl ipinfo.io/ip
curl ipecho.net/plain
curl www.trackip.net/i
curl ip.sb
curl whatismyip.akamai.com
curl ifconfig.co
curl ident.me
curl inet-ip.info
curl 'https://api.ipify.org?format=json' #ipv4
curl 'https://api64.ipify.org?format=json' #ipv6
# 获取本机公网 IP ，这几个有返回位置信息
curl myip.ipip.net
curl ip.cn
curl cip.cc
curl ip-api.com
curl ip-api.com/json
# 查询某个ip的信息
curl http://ip-api.com/json/58.62.220.66
</code></pre>
<h2>在命令行中直接运行代码</h2>
<p>大概就两种套路，从标准输入读取代码，从命令行参数读取代码，从命令行参数读取代码时要留意转义字符</p>
<h3>php</h3>
<p>代码开头都不需要 &lt;? 或 &lt;?php</p>
<pre><code>phpcode=$(cat &lt;&lt;- 'EOF'
echo '123';
echo "asd";
$a="qwe";
echo $a;
echo "\"\$a\"\\";
var_dump($argv);
EOF
);

echo $phpcode | php -a -- a=1;

php -r "$phpcode" -- a=1;

php -a &lt;&lt;- 'EOF'
echo '123';
echo "asd";
$a="qwe";
echo $a;
echo "\"\$a\"\\";
var_dump($argv);
EOF
</code></pre>
<h3>node</h3>
<pre><code>nodecode=$(cat &lt;&lt;- 'EOF'
console.log('hello');
EOF
);

echo $nodecode | node

node -e "$nodecode"

node &lt;&lt;- 'EOF'
console.log('hello');
EOF
</code></pre>
<h3>python</h3>
<pre><code>执行标准输入里的代码，和普通文件里的代码一样，必须要有换行符

pythoncode=$(cat &lt;&lt;- 'EOF'
print('hi1')
print('hi2')
EOF
);

echo $pythoncode | python

python &lt;&lt; 'EOF'
print('hi1')
print('hi2')
EOF

在一行里，换行用分号;替代
python -c "import os;print(os.environ['PATH'])"
</code></pre>
<h2>分页公式</h2>
<h3>相关变量</h3>
<ul>
<li>总行数 totalRecord</li>
<li>当前页 pageNo</li>
<li>每页大小 pageSize</li>
<li>总页数 totalPage</li>
<li>当前页大小 currentPageSize</li>
</ul>
<h3>计算总页数</h3>
<p>伪代码</p>
<pre><code>totalPage = ceil((totalRecord  +  pageSize  - 1) / pageSize);
</code></pre>
<p>php</p>
<pre><code class="lang-php">$totalPage = ceil(($totalRecord  +  $pageSize  - 1) / $pageSize);
</code></pre>
<p>sql</p>
<pre><code class="lang-sql">SELECT @totalRecord := 123, @pageSize := 6;
SELECT ceil((@totalRecord + @pageSize + 1) / @pageSize);
</code></pre>
<p>ceil 是 向上取整 的函数</p>
<h3>sql</h3>
<p>关于分页的语法</p>
<pre><code>SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset
三种写法
SELECT * FROM table LIMIT rows
SELECT * FROM table LIMIT offset, rows
SELECT * FROM table LIMIT rows OFFSET offset
</code></pre>
<p>具体的例子</p>
<pre><code class="lang-sql">-- 每页 10 行，第 1 页
SELECT * FROM table LIMIT 10
SELECT * FROM table LIMIT 0, 10
SELECT * FROM table LIMIT 10 OFFSET 0
-- 每页 10 行，第 2 页
SELECT * FROM table LIMIT 10, 10
SELECT * FROM table LIMIT 10 OFFSET 10
-- 每页 10 行，第 3 页
SELECT * FROM table LIMIT 20, 10
SELECT * FROM table LIMIT 10 OFFSET 20
-- 每页 10 行，第 4 页
SELECT * FROM table LIMIT 30, 10
SELECT * FROM table LIMIT 10 OFFSET 30
</code></pre>
<p>这是获取总行数的 sql</p>
<pre><code class="lang-sql">SELECT count(*) FROM table LIMIT 1;
</code></pre>
<ul>
<li>虽然还有其它方式，但使用 count 是最保险的，多数框架都是用 count 实现的</li>
</ul>
<p>这是获取总页数的 sql</p>
<pre><code class="lang-sql">SELECT @pageSize := 6;
SELECT ceil((count(*) + @pageSize + 1) / @pageSize) FROM table LIMIT 1;
SELECT ceil((count(*) + 7) / 6) from table LIMIT 1;
</code></pre>
<ul>
<li>多数情况下都不会用 sql 来计算</li>
</ul>
<p>这是获取某一页的 sql</p>
<pre><code class="lang-sql">-- 每页 6 行，第 2 页
SELECT @pageSize := 6;
SELECT @pageNo := 2;

SELECT @rows := @pageSize;
SELECT @offset := (@pageNo-1)*@pageSize;

SELECT * FROM table LIMIT @offset, @rows;
SELECT * FROM table LIMIT @rows offset @offset;
</code></pre>
<h3>计算当前页的大小</h3>
<pre><code>计算当前页的行数，这是伪代码
function getCurrentPageSize(pageSize, pageNo, totalRecord, totalPage)
{
    if (pageNo &lt; totalPage) {
        return pageSize;
    } else if (pageNo == totalPage) {
        return pageSize + (totalRecord - totalPage*pageSize);
    } else {
        // Throw an exception
    }
}
</code></pre>
<h2>安装 busybox</h2>
<ul>
<li><p>通过包管理</p>
<pre><code>apt install -y busybox
</code></pre>
</li>
<li><p>通过 docker</p>
<pre><code>docker run -it --rm --name my-busybox busybox:1.36-glibc sh
</code></pre>
</li>
<li><p>通过 type 命令判断当前系统有没有安装 busybox</p>
<pre><code>type busybox
</code></pre>
</li>
<li><p>查看 busybox 的帮助和版本</p>
<pre><code>busybox --help
</code></pre>
</li>
<li><p>可以在浏览器体验 busybox ，但版本好像有一点旧</p>
<pre><code>https://busybox.net/live_bbox/live_bbox.html
</code></pre>
</li>
<li><p>windows 版的 busybox</p>
<pre><code>https://frippery.org/busybox/
https://github.com/rmyorston/busybox-w32
</code></pre>
<p>建议下载 busybox64u.exe 这个版本，64位且支持 unicode ，虽然这个版本只支持 win10和win11</p>
</li>
</ul>
<h3>编译安装</h3>
<p>直接用 apt 安装的 busybox 版本太旧了,
busybox 常常要用到宿主机的文件，容器里的 busybox 用起来不怎么方便。</p>
<p>安装前置的依赖</p>
<pre><code>apt install -y bzip2 &amp;&amp; \
apt install -y make &amp;&amp; \
apt install -y gcc
</code></pre>
<p>下载源码</p>
<pre><code>curl -O "https://busybox.net/downloads/busybox-1.36.1.tar.bz2"
</code></pre>
<p>解压源码</p>
<pre><code>tar -xjf ./busybox-1.36.1.tar.bz2
</code></pre>
<p>切换进源码目录并开始安装</p>
<pre><code>cd busybox-1.36.1
make defconfig
make install
</code></pre>
<p>编译后的 可执行二进制文件 可能在当前编译的目录，可能在源码的目录，反正要找一下</p>
<pre><code>find / -name busybox
</code></pre>
<p>找到后就复制或剪切到 /bin 目录</p>
<pre><code>cp /root/busybox-1.36.1/busybox /bin/busybox
</code></pre>
<p>一句命令完成下载和安装，但需要是 root 用户，其它用户需要修改对应的目录</p>
<pre><code>apt install -y bzip2 &amp;&amp; \
apt install -y make &amp;&amp; \
apt install -y gcc &amp;&amp; \
cd &amp;&amp; \
curl -O "https://busybox.net/downloads/busybox-1.36.1.tar.bz2" &amp;&amp; \
tar -xjf ./busybox-1.36.1.tar.bz2 &amp;&amp; \
cd busybox-1.36.1 &amp;&amp; \
make defconfig &amp;&amp; \
make install &amp;&amp; \
cp /root/busybox-1.36.1/busybox /bin/busybox &amp;&amp; \
cd
</code></pre>
<h2>如何自建一个 DNS 服务</h2>
<p>使用这个仓库的代码来搭建 DNS ，
使用这个仓库是因为笔者平时主要使用php做开发，
<a href="https://github.com/yswery/PHP-DNS-SERVER">https://github.com/yswery/PHP-DNS-SERVER</a></p>
<p>使用的是 v1.4.1 版本</p>
<pre><code>git checkout v1.4.1
</code></pre>
<ol>
<li><p>下载源码</p>
<pre><code>https://github.com/yswery/PHP-DNS-SERVER
</code></pre>
</li>
<li><p>安装依赖，加上 --ignore-platform-reqs 参数，是因为这个仓库声明依赖的php版本比较旧，没这个参数可能无法下载composer里的依赖</p>
<pre><code>composer install --no-suggest --no-dev --ignore-platform-reqs
</code></pre>
</li>
<li><p>参考 example/example.php 文件自己新建一个启动用的php文件 startup.php
```php
require_once <strong>DIR</strong>.'/vendor/autoload.php';</p>
</li>
</ol>
<p>$json = &lt;&lt;&lt; EOF
{
    "test.localhost.com": {
      "A": "127.0.0.1"
    }
}
EOF;</p>
<p>class JsonTextResolver extends \yswery\DNS\Resolver\JsonResolver
{
    public function addZoneText(string $zone)
    {
        $zone = json_decode($zone, true);
        $this-&gt;addZoneArr($zone);
    }</p>
<pre><code>public function addZoneArr(array $zone)
{
    $resourceRecords = $this-&gt;isLegacyFormat($zone) ? $this-&gt;processLegacyZone($zone) : $this-&gt;processZone($zone);
    $this-&gt;addZone($resourceRecords);
}
</code></pre>
<p>}</p>
<p>// JsonResolver created and provided with json dns records
$jsonResolver = new JsonTextResolver([]);
$jsonResolver-&gt;addZoneText($json);</p>
<p>// ipconfig /flushdns
// php localhost2.php</p>
<p>// System resolver acting as a fallback to the JsonResolver
$systemResolver = new yswery\DNS\Resolver\SystemResolver();</p>
<p>// StackableResolver will try each resolver in order and return the first match
$stackableResolver = new yswery\DNS\Resolver\StackableResolver([$jsonResolver, $systemResolver]);</p>
<p>// Create the eventDispatcher and add the event subscribers
$eventDispatcher = new \Symfony\Component\EventDispatcher\EventDispatcher();
$eventDispatcher-&gt;addSubscriber(new \yswery\DNS\Event\Subscriber\EchoLogger());
$eventDispatcher-&gt;addSubscriber(new \yswery\DNS\Event\Subscriber\ServerTerminator());</p>
<p>// Create a new instance of Server class
$config = null;
$storageDirectory = null;
$useFilesystem = false;
$ip = '127.0.0.1';
$port = 53;
$server = new yswery\DNS\Server($stackableResolver, $eventDispatcher, $config, $storageDirectory, $useFilesystem, $ip, $port);</p>
<p>// Start DNS server
$server-&gt;start();</p>
<pre><code>
&lt;!--
$temp_file = tempnam(sys_get_temp_dir(), 'aaa');
\define('TEMP_RECORD_FILE', $temp_file);

register_shutdown_function(function(){
    if (is_file(TEMP_RECORD_FILE)) {
        unlink(TEMP_RECORD_FILE);
    }
});

$json = &lt;&lt;&lt; EOF
{
    "shop-dev.theclub.com.hk": {
      "A": "127.0.0.1"
    }
}
EOF;
file_put_contents(TEMP_RECORD_FILE, $json);
// ipconfig /flushdns
// php localhost.php

// JsonResolver created and provided with path to file with json dns records
$jsonResolver = new yswery\DNS\Resolver\JsonResolver([TEMP_RECORD_FILE]);
--&gt;

1. 这是启动的命令，可以把这个命令保存在一个用于启动的脚本文件
&lt;!-- startup.bat startup.sh --&gt;
</code></pre>
<p>php startup.php</p>
<pre><code>
1. 修改网卡的 dns 配置
&lt;!-- 一般情况下 主DNS 访问失败时才会访问 备用DNS ，查询没有结果不算访问失败 --&gt;

1. 可以用这样的命令来测试是否生效，如果没有生效可以尝试刷洗 dns 缓存
</code></pre>
<p>nslookup -debug -querytype=A -port=53 test.localhost.com 127.0.0.1</p>
<pre><code>
1. 如何写配置文件可以参考仓库里的文档或参考 example 里的文件

1. 如果不把设为服务，则每次开机后都要手工启动一次

## 在本地使用 unbound 搭建一个 DNS 服务

笔者原本是想用php的库来建一个本地的dns服务，但找了很久都没找到合适的，最后还是选择用 unbound ，
和 bind 相比， unbound 提供了免编译免安装的版本。

使用的是 v1.19.0 版本

1. unbound 的仓库
</code></pre>
<p><a href="https://github.com/NLnetLabs/unbound">https://github.com/NLnetLabs/unbound</a></p>
<pre><code>
1. unbound 的文档
</code></pre>
<p><a href="https://unbound.docs.nlnetlabs.nl/en/latest/index.html">https://unbound.docs.nlnetlabs.nl/en/latest/index.html</a></p>
<pre><code>
1. 下载 unbound
</code></pre>
<p><a href="https://nlnetlabs.nl/projects/unbound/download/">https://nlnetlabs.nl/projects/unbound/download/</a></p>
<pre><code>
1. 下载完后，解压，然后复制一份配置文件
</code></pre>
<p>cp example.conf unbound.conf</p>
<pre><code>
1. 修改配置文件，整个配置文件非常大，在特定位置改好这几项就好了
</code></pre>
<p>interface: 127.0.0.1</p>
<p>local-data: "test.localhost.com A 127.0.0.1"</p>
<p>forward-zone:
    name: "."
    forward-addr: 系统原本的主dns地址
    forward-addr: 系统原本的备用dns地址</p>
<pre><code>
1. 检测配置文件
</code></pre>
<p>unbound-checkconf unbound.conf
./unbound-checkconf.exe unbound.conf</p>
<pre><code>
1. 运行
</code></pre>
<h1>在前台运行</h1>
<p>unbound -vv -c unbound.conf
./unbound.exe -vv -c unbound.conf</p>
<h1>在后台运行</h1>
<p>unbound -d -vv -c unbound.conf
./unbound.exe -d -vv -c unbound.conf
```</p>
&lt;!-- unbound 如何设置 DNS-over-HTTPS？ --&gt;

<h2>那些能作为工具的网站</h2>
<ul>
<li>能查看到编译的汇编代码
  <a href="https://gcc.godbolt.org/">https://gcc.godbolt.org/</a></li>
<li>能在线运行 php 代码，能一次运行多个版本<ul>
<li><a href="https://3v4l.org/">https://3v4l.org/</a></li>
<li><a href="https://onlinephp.io/">https://onlinephp.io/</a></li>
<li><a href="https://phphub.net/sandbox/">https://phphub.net/sandbox/</a></li>
</ul>
</li>
<li>一个能生成 curl 命令的网站，在开发的时候十分有用，特别是测试第三方接口的时候
  <a href="https://reqbin.com/">https://reqbin.com/</a></li>
<li>在线的 svg 编辑器
  <a href="https://c.runoob.com/more/svgeditor/">https://c.runoob.com/more/svgeditor/</a></li>
<li>可视化的正则表达式<ul>
<li><a href="https://jex.im/regulex/">https://jex.im/regulex/</a></li>
<li><a href="https://www.debuggex.com/">https://www.debuggex.com/</a></li>
<li><a href="https://regexper.com/">https://regexper.com/</a></li>
<li><a href="https://regex101.com/">https://regex101.com/</a></li>
<li><a href="https://regexr.com/">https://regexr.com/</a></li>
<li><a href="https://pythonium.net/regex">https://pythonium.net/regex</a></li>
</ul>
</li>
<li>ASCII 画图
  <a href="https://asciiflow.com/">https://asciiflow.com/</a></li>
<li>百度翻译能直接复制图片，并识别出文字</li>
<li>临时上传图片用的<ul>
<li><a href="http://ipaiban.com/bianji">http://ipaiban.com/bianji</a></li>
</ul>
</li>
<li>文本压缩，去除空行和多余的空格
  <a href="http://www.wuqianling.top/software/notepad/compress.html">http://www.wuqianling.top/software/notepad/compress.html</a></li>
<li>url 编码<ul>
<li>因此当你需要编码整个 URL，就用 encodeURI。</li>
<li>如果只需要编码 URL 中的参数时，就使用 encodeURIComponent。</li>
<li><a href="https://www.iamwawa.cn/urldecode.html">https://www.iamwawa.cn/urldecode.html</a></li>
</ul>
</li>
<li>graphql 格式化
  <a href="https://verytoolz.com/graphql-formatter.html">https://verytoolz.com/graphql-formatter.html</a></li>
<li>在线的剪切板<ul>
<li><a href="https://pastebin.com/">https://pastebin.com/</a></li>
<li><a href="https://paste.centos.org/">https://paste.centos.org/</a></li>
<li><a href="https://paste.debian.net/">https://paste.debian.net/</a></li>
<li><a href="https://pastebin.mozilla.org/">https://pastebin.mozilla.org/</a></li>
<li><a href="https://github.com/PrivateBin/PrivateBin">https://github.com/PrivateBin/PrivateBin</a></li>
<li><a href="https://github.com/DarrenOfficial/dpaste">https://github.com/DarrenOfficial/dpaste</a></li>
<li><a href="https://github.com/lovasoa/whitebophir">https://github.com/lovasoa/whitebophir</a></li>
</ul>
</li>
<li>工具网站的集合<ul>
<li><a href="https://c.runoob.com/">https://c.runoob.com/</a></li>
<li><a href="https://tool.oschina.net/">https://tool.oschina.net/</a></li>
</ul>
</li>
<li>各种 jdk 的下载渠道
  <a href="https://www.injdk.cn/">https://www.injdk.cn/</a></li>
<li>英文缩略词查询
  <a href="https://www.abbreviationfinder.org/cn/">https://www.abbreviationfinder.org/cn/</a></li>
<li>在线 ps<ul>
<li><a href="https://www.photopea.com/">https://www.photopea.com/</a></li>
<li><a href="https://pixlr.com/">https://pixlr.com/</a></li>
</ul>
</li>
<li>拯救词穷的字典。由清华大学 NLP 实验室开源，可以根据你的意思返回相关词汇，有效解决词穷、话到嘴边说不出来的窘境。<ul>
<li><a href="https://wantwords.net/">https://wantwords.net/</a></li>
<li><a href="https://github.com/thunlp/WantWords">https://github.com/thunlp/WantWords</a></li>
</ul>
</li>
<li>用于查看 winapi 里的各种结构体，以及各个 Windows 版本的差异
  <a href="http://terminus.rewolf.pl/terminus/">http://terminus.rewolf.pl/terminus/</a></li>
<li>微软的数学求解器
  <a href="https://mathsolver.microsoft.com/">https://mathsolver.microsoft.com/</a></li>
<li>由 google 提供的在线调试工具
  <a href="https://toolbox.googleapps.com/apps/main/">https://toolbox.googleapps.com/apps/main/</a></li>
<li>网页快照<ul>
<li><a href="https://web.archive.org/save">https://web.archive.org/save</a></li>
<li><a href="http://archive.is/">http://archive.is/</a></li>
</ul>
</li>
</ul>
