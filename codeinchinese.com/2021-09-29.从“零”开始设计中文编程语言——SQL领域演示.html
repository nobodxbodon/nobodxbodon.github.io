<h2>原文：<a href="http://codeinchinese.com/2021-09-29.%E4%BB%8E%E2%80%9C%E9%9B%B6%E2%80%9D%E5%BC%80%E5%A7%8B%E8%AE%BE%E8%AE%A1%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94SQL%E9%A2%86%E5%9F%9F%E6%BC%94%E7%A4%BA">2021-09-29.从“零”开始设计中文编程语言——SQL领域演示</a></h2>
<p>通过逐步完善一个简单的中文编程语言语法并最后转换为 SQL 语句，演示一种快速搭建中文编程语言原型的方法。</p>
<p>达成效果是，如下的中文语句：</p>
<pre><code>创建读者表，编号为整数，出生年为文本
</code></pre>
<p>转换生成 SQL 语句：</p>
<pre><code class="language-SQL">CREATE TABLE 读者 ( 编号 INTEGER, 出生年 TEXT )
</code></pre>
<p>文中代码在 Python 3.8 下运行通过，需安装 <a href="https://pypi.org/project/rply-ulang/">RPly 木兰定制版</a> 0.8.0。</p>
<h3>一、中文标识符</h3>
<p>首先来识别一个标识符——“读者”。下面是完整代码。</p>
<pre><code class="language-python">from rply import 分词器母机, 语法分析器母机

分词母机 = 分词器母机()
分词母机.添了('标识符', r'读者')

分析器母机 = 语法分析器母机(['标识符'])

@分析器母机.语法规则("句 : 标识符")
def 句(片段):
    return 片段[0].getstr() # 第一个片段的内容

分词器 = 分词母机.产出()
分析器 = 分析器母机.产出()

print(分析器.按语法分词(分词器.分词('读者')))
</code></pre>
<p>运行此源码文件可见输出。</p>
<p>先简单看下源码，分词母机添加的一条词法规则：标识符可以是“读者”。分析器母机添加的一条语法规则：句子只包含一个标识符，而且解析后直接输出它的内容（在 “句(片段)”方法中返回）。</p>
<p>最后对“读者”这一字符串进行按语法分词，输出的就是“读者”。（输出还有一句“回退次数：0”，请暂时无视）</p>
<p>当然，标识符不止有“读者”，于是将词法改为如下正则表达式，允许多个中文字符：</p>
<pre><code class="language-python">分词母机.添了('标识符', r'[\u4e00-\u9fa5]+')
</code></pre>
<p>这样，即使末句改为“观众”，也可被识别。</p>
<h3>二、创建读者表</h3>
<p>从创建表格开始设计语法，添加些关键词。先来一个“表”，希望能解析“读者表”后输出表名“读者”。</p>
<p>添加对应词法规则：</p>
<pre><code class="language-python">分词母机.添了('表', '表')
</code></pre>
<p>记得将它加到语法分析母机的词表中（注：此文后面的部分不再复述此代码，忘加的话就会碰到 “KeyError: '表'” 这种报错）：</p>
<pre><code class="language-python">分析器母机 = 语法分析器母机(['表', '标识符'])
</code></pre>
<p>接着把语法规则改为：</p>
<pre><code class="language-python">@分析器母机.语法规则("句 : 标识符 表")
</code></pre>
<p>好了，现在对“读者表”进行解析，即末句改为：</p>
<pre><code class="language-python">print(分析器.按语法分词(分词器.分词('读者表')))
</code></pre>
<p>如期输出了“读者”。</p>
<p>同理添加“创建”，希望解析“创建读者表”后暂仍输出“读者”。照样添加词法规则（注：此文之后部分不再复述此代码）：</p>
<pre><code class="language-python">分词母机.添了('创建', '创建')
</code></pre>
<p>改语法规则：</p>
<pre><code class="language-python">句 : 创建 标识符 表
</code></pre>
<p>好，现在解析“创建读者表”，但为何输出“创建”了呢？</p>
<p>细看一下这段：</p>
<pre><code class="language-python">@分析器母机.语法规则("句 : 创建 标识符 表")
def 句(片段):
    return 片段[0].getstr()
</code></pre>
<p>修改语法规则后，现在一“句”中有三个片段，“片段[0]”现在对应的是“创建”，标识符应该是第二个片段，即“片段[1]”。修改之后，解析“创建读者表”就如期输出“读者”。</p>
<h3>三、单列</h3>
<p>创建表格时，可以对列进行声明，比如：“创建读者表，出生年为整数”。先支持一列。</p>
<p>添加“为”、“整数”两个关键词，并添加中文逗号：</p>
<pre><code class="language-python">分词母机.添了('逗号', '，')
</code></pre>
<p>语法呢？“创建读者表，出生年为整数”的第一部分是表声明，后面是逗号，以及列声明。那么就加这条语法规则：</p>
<pre><code>建表 : 表声明 逗号 列声明
</code></pre>
<p>表声明的规则与之前相同：</p>
<pre><code>表声明 : 创建 标识符 表
</code></pre>
<p>列声明的语法就是：</p>
<pre><code>列声明 : 标识符 为 整数
</code></pre>
<p>与表声明类似，“片段[0].getstr()”就可从列声明中获得列名。</p>
<p>需注意的是，在建表方法中，片段[0] 取得的是表声明的输出值，即标识符名，这里不需再用 getstr()。另可用格式化字符串简化代码如下：</p>
<pre><code class="language-python">def 建表(片段):
    return f"{片段[0]}：{片段[2]}"
</code></pre>
<p>解析“创建读者表，出生年为整数”后输出：“读者：出生年”</p>
<h3>四、多列</h3>
<p>表格当然可以有多列。比如：“创建读者表，编号为整数，出生年为整数”。</p>
<p>原本在表声明后的单一列声明，现在变为了对各列的声明：</p>
<pre><code>建表 : 表声明 逗号 各列声明
</code></pre>
<p>如何描述各列声明的语法规则呢？分情况来看，如果只包含一个列声明，就这样：</p>
<pre><code>各列声明 : 列声明
</code></pre>
<p>如果包含更多呢？可以这样描述，在一个“各列声明”后面再加上逗号和一个“列声明”，有点递归的意思：</p>
<pre><code>各列声明 : 各列声明 逗号 列声明
</code></pre>
<p>那么如何区分处理这两种情况？看这段，各列声明的两种规则放在一起，用一个方法处理：</p>
<pre><code class="language-python">@分析器母机.语法规则("各列声明 : 列声明")
@分析器母机.语法规则("各列声明 : 各列声明 逗号 列声明")
def 各列声明(片段):
    return f"{片段[0]}" if len(片段) == 1 else f"{片段[0]}，{片段[2]}"
</code></pre>
<p>这里通过判断片段的个数来区分，还有其他方法比如判断某词的类型。</p>
<p>至此解析“创建读者表，编号为整数，出生年为整数”后输出：“读者：编号，出生年”</p>
<h3>五、多种数据类型</h3>
<p>除了整数，还可以有其他的列类型，比如文本。这也方便，与“整数”类似，添加“文本”一词后，添加如下语法：</p>
<pre><code class="language-python">列类型 : 整数 | 文本
</code></pre>
<p>这与上面的“各列声明”分两行效果相同，是同一语法元素的多种并列规则。</p>
<p>再把原本的列声明改为：</p>
<pre><code class="language-python">列声明 : 标识符 为 列类型
</code></pre>
<p>列声明的输出加上列类型后，解析“创建读者表，编号为整数，出生年为文本”后输出：“读者：编号-整数，出生年-文本”</p>
<h3>六、转换为SQL</h3>
<p>至此，各语法元素看起来解析无误，那么各语法规则已定，这部分仅对处理方法的返回值作了修改。</p>
<p>举几个例子，列类型应该返回 INTEGER 或者 TEXT：</p>
<pre><code class="language-python">return "INTEGER" if 片段[0].getstr()=="整数" else "TEXT"
</code></pre>
<p>表声明部分：</p>
<pre><code class="language-python">return f"CREATE TABLE {片段[1].getstr()}"
</code></pre>
<p>建表时将各列声明置于 () 中：</p>
<pre><code class="language-python">return f"{片段[0]} ( {片段[2]} )"
</code></pre>
<p>另几处就请自行尝试吧。</p>
<h3>完整源码</h3>
<p>此文的完整代码约四十行，<a href="https://github.com/nobodxbodon/rply/blob/master/docs/%E6%BC%94%E7%A4%BA/%E4%B8%AD%E6%96%87%E8%BD%ACSQL.py">开源在此</a>。如想继续完善创建表、记录以及其他查询、删除等语法，<a href="https://github.com/nobodxbodon/rply/blob/5aabd499bcdf7d5f6edfec67cb8955c0c32b459d/tests/test_%E6%8C%89%E8%AF%AD%E6%B3%95%E5%88%86%E8%AF%8D.py#L496">此测试用例</a> 供参考。如有任何问题欢迎在源码库反馈。</p>
<p><em><strong>注：本文中语言的设计是在搭建原型之前就有了草稿，见 <a href="https://gitee.com/Program-in-Chinese/overview/issues/I48P02#note_6549284_link">此楼</a>。此设计尚未经过实践检验，欢迎指摘。</strong></em></p>
