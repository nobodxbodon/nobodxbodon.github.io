<h2><a href="https://github.com/kneep/kneep.github.io/blob/master/content/posts/memory-model/introduction/index.md">仓库源文</a>，<a href="https://kneep.github.io/posts/memory-model/introduction/">站点原文</a></h2>
<p>讨论编程问题的时候，尤其是在并发编程的领域，我们经常看到会「内存模型」这个词，英语通常叫「Memory Model」或「Memory Consistency Model」。理解「内存模型」究竟意味着什么，对于写出高效稳定的计算机程序至关重要。但是，理解「内存模型」并不是一件容易的事情。本系列文章的目的，希望能对「内存模型」这个概念，给出浅显易懂的解释。尤其是帮助在嵌入式开发领域的软件工程师理解、掌握工作中必须要用到的知识。</p>
<p>本篇我们先从一个简单的问题开始，介绍内存模型的概念。</p>
<pre><code class="lang-c">// Core C1
S1: x = NEW;
L1: r1 = y;
</code></pre>
<pre><code class="lang-c">// Core C2
S2: y = NEW;
L2: r2 = x;
</code></pre>
<p>上面的代码采用了类似 C 语言的伪代码，呈现了在两个处理器核上运行的一些指令。对这里的一些符号和初始条件做一些说明：</p>
<ul>
<li><code>C1</code>、<code>C2</code> 代表处理器核（Core）</li>
<li><code>L1</code>、<code>L2</code> 代表读指令（Load）</li>
<li><code>S1</code>、<code>S2</code> 代表写指令（Store）</li>
<li><code>x</code>、<code>y</code> 代表存储在共享内存中的变量</li>
<li><code>r1</code>、<code>r2</code> 代表存储在处理器寄存器中的变量</li>
<li>所有变量的初始值都是 0</li>
<li><code>NEW</code> 代表一个非 0 常量</li>
</ul>
<p>（在系列的后面文章中，都会用类似的表示方法，出现时将不再对此赘述。）</p>
<hr/>
<p>问题来了：
{{&lt; alert &gt;}}
程序运行后，<code>(r1, r2)</code> 的值可能是 <code>(0, 0)</code> 吗？
{{&lt; /alert &gt;}}</p>
<p>这个问题看似很简单，一般的推理是这样的：</p>
<ol>
<li><code>r1 == 0</code> 意味着 <code>y == 0</code></li>
<li><code>y == 0</code> 意味着 <code>y = NEW</code> 尚未执行</li>
<li>所以 <code>r2 = x</code> 更不可能执行</li>
<li>所以 <code>(r1, r2) == (0, 0)</code> 是不可能的</li>
</ol>
<p>这种推理是最符合<strong>直觉</strong>的，不过，它是正确的吗？答案是——<strong>取决于处理器的「内存模型」</strong>。上面的推理，其实是需要某种内存模型来保证的。我们最基本的直觉是——先执行的指令，其结果先「被看到」，在硬件层面保证这种关系是最简单的，写代码的人就可以少操心。但是，硬件实现者的手被束缚了。</p>
<p>另一些内存模型下，<code>(0, 0)</code> 这个结果是可能出现的，因为部分内存模型允许<strong>重排</strong>符合规则的指令，比如这个执行序列：<code>L1 → L2 → S1 → S2</code> 。为什么部分内存模型会允许这样的执行序列呢？主要是为了让硬件的实现者有更大自由度，做更多的优化（优化的原理不是本文重点）。有人自由了，就有人会不自由。程序员感觉世界崩塌了，什么都不可信了。其实，没有完全崩塌，因为指令的重排并不是随机的，而是有一定规则的，并且，当我们识别到有程序需要保证先后顺序的时候，处理器也给了我们工具来实现。</p>
<p>不过无论如何，我们需要学习规则，并使用工具，才能达到目的，编程确实变难了。</p>
<hr/>
<p>到这里，我们对「内存模型」这个概念，已经有了一定的直观认识。对于这样一类程序：</p>
<ul>
<li>运行在某种 CPU 指令集上</li>
<li>在多个 CPU 上执行多个线程</li>
<li>多个线程对共享内存进行读写</li>
</ul>
<p>我们会问：</p>
<ul>
<li>硬件的实现者可以对这些读写指令做哪些优化？规则是什么？</li>
<li>软件的实现者可以信任哪些假设？不能信任哪些假设？如何来保证执行顺序？</li>
</ul>
<p>澄清以上问题的规则，构成了「内存模型」。「内存模型」让 CPU 设计者、编译器实现者、操作系统开发者、应用软件开发者等角色在统一的规则下工作。</p>
<p>从下一篇开始，我们会逐个介绍几种主流的内存模型。</p>
