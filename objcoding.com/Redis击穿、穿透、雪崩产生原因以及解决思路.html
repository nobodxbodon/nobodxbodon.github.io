<h2><a href="https://github.com/objcoding/objcoding.github.io/blob/master/_posts/2021-11-28-redis.md">仓库源文</a>，<a href="https://objcoding.com/2021/11/28/redis">站点原文</a></h2>
<hr/>
<h2>layout: post
title: "Redis击穿、穿透、雪崩产生原因以及解决思路"
categories: Redis
tags: redis 击穿 穿透 雪崩
author: 等不到的口琴</h2>
<ul>
<li>content
{:toc}
大家都知道,计算机的瓶颈之一就是IO,为了解决内存与磁盘速度不匹配的问题,产生了缓存,将一些热点数据放在内存中,随用随取,降低连接到数据库的请求链接,避免数据库挂掉。</li>
</ul>
<h2>击穿</h2>
<p>需要注意的是,<strong>无论是击穿还是后面谈到的穿透与雪崩,都是在高并发前提下</strong>,当缓存中某一个热点key失效。</p>
<p><img alt="" src="https://raw.githubusercontent.com/objcoding/md-picture/master/img/20211128145101.png"/></p>
<h3>为什么会有击穿发生呢？</h3>
<ol>
<li>Key 过期；</li>
<li>Key 被页面置换淘汰；</li>
</ol>
<p>对于第一个原因是因为在Redis中,Key有过期时间,如果某一个时刻(假如商城做活动,零点开始)key失效,那么零点之后对某一个商品查询请求将全都压到数据库上,导致数据库崩。</p>
<p>对于第二个原因,因为内存是有限的,要时时刻刻缓存新的数据,淘汰旧的数据,所以在一定的页面置换策略中,淘汰数据,如果某些商品做活动之前无人问津,势必会被淘汰。</p>
<h3>应对击穿的处理思路</h3>
<p>正常的处理请求如图:</p>
<p><img alt="" src="https://raw.githubusercontent.com/objcoding/md-picture/master/img/20211128145258.png"/></p>
<p>由于key过期在所难免,高流量来到Redis时,根据Redis的单线程特性,可以认为任务是在队列里依次执行的,当请求到达Redis发现Key过期时,进行一个操作:<strong>设置锁</strong></p>
<p>这个流程大概如下:</p>
<ol>
<li>请求到达Redis,发现Redis Key过期,查看有没有锁,没有锁的话回到队列后面排队</li>
<li>设置锁,注意,这儿应该是setnx(),而不是set(),因为可能有其他线程已经设置锁了</li>
<li>获取锁,拿到锁了就去数据库取数据,请求返回后释放锁。</li>
</ol>
<p><img alt="" src="https://raw.githubusercontent.com/objcoding/md-picture/master/img/20211128145328.png"/></p>
<p>但是引出了一个新的问题,如果拿到锁去拿数据的请求然后挂了怎么办?也就是锁没有释放,其他进程都在等锁,解决办法是:</p>
<p>对锁设置一个过期时间,如果到达了过期时间还没释放就自动释放,问题又来了,锁挂了好说,但是如果是锁超时呢?也就是在设定的时间里数据没有取出来,但是锁由过期了,常见的思路是,锁过期时间值递增,但是想想不靠谱,因为第一个请求可能超时,如果后面的也超时呢,接连多次超时之后,锁过期时间值势必特别大了,这样做弊端太多。</p>
<p>另外一个思路是,再开启一个线程,进行监控,如果取数据的线程没有挂的话,就适当延迟锁的过期时间。</p>
<p><img alt="" src="https://raw.githubusercontent.com/objcoding/md-picture/master/img/20211128145346.png"/></p>
<h2>穿透</h2>
<p>穿透主要原因是很多请求都在访问数据库不存在的数据,例如一个卖书的商城一直被请求查询茶叶产品,由于Redis缓存主要是用来缓存热点数据,对于数据库都不存在的数据,是没法缓存的,这种异常流量就会直接到达数据库并且返回"没有"的查询结果。</p>
<p>应对这种请求,处理办法是对访问请求加一层过滤器,例如布隆过滤器、增强版布隆过滤器、布谷鸟过滤器。</p>
<p><img alt="" src="https://raw.githubusercontent.com/objcoding/md-picture/master/img/20211128145441.png"/></p>
<p>除了布隆过滤器,可以增加一些参数检验,例如数据库数据id一般都是递增的,如果请求 id = -10 这种参数,势必绕过Redis,避免这种情况,可以对用户真实性检验等操作。</p>
<h2>雪崩</h2>
<p>雪崩,和击穿类似,不同的是击穿是一个热点Key某时刻失效,而雪崩是大量的热点Key在一瞬间失效,网络上很多博客都在强调解决雪崩的策略是随机过期时间,这个非常不准确,举个例子,银行做活动,之前这个利息系数为2%,过了零点系数改为3%,这种情况能将用户的对应的key改为随机过期吗?如果用的过去的数据叫脏数据。</p>
<p>明显不可以,同样存钱,你存到年底利息300万,隔壁才200万,这不得打架啊,开玩笑~</p>
<p>正确的思路是,首先要看看这个Key过期是不是时点性有关,时点性无关的话,可以随机过期时间解决。</p>
<p>如果是时点性有关,例如刚刚说的银行某一天改变某系数,那么就要利用强依赖击穿方案,策略是先过去的线程更新一下所有key</p>
<p><img alt="" src="https://raw.githubusercontent.com/objcoding/md-picture/master/img/20211128145505.png"/></p>
<p>在后台更新热点key的同时,业务层将进来的请求延时一下,例如短暂的睡几毫秒或者秒,给后面的更新热点key分散压力。</p>
<p>来源：https://www.cnblogs.com/Courage129/p/14348720.html</p>
