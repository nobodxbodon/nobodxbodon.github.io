<h2><a href="https://github.com/knightyun/knightyun.github.io/blob/master/_posts/2018-04-06-recursion-factorial.md">仓库源文</a>，<a href="https://knightyun.github.io/2018/04/06/recursion-factorial">站点原文</a></h2>
<h1>定义</h1>
<p>在编程中函数有一个神奇又难理解的功能，就是递归。递归就是在一个过程中要调用上一步或上几步的结果，使用递归过程的函数就叫递归函数。简单说就是函数自身调用自身（听着有点反自然，像自己举起自己）。</p>
<h1>递归实例</h1>
<p>除了数学的复杂运算中，生活中也有不少递归的实例：</p>
<h2>德罗斯特效应</h2>
<p>德罗斯特效应（Droste effect）是递归的一种视觉形式，即一张图片中的某部分与整张图片相同，如下：
<img alt="20180406205325252.jpg" src="https://i.loli.net/2018/04/15/5ad3565ad7935.jpg"/></p>
<hr/>
<p><img alt="20180406205355939.jpg" src="https://i.loli.net/2018/04/15/5ad3565b03bca.jpg"/></p>
<hr/>
<p><img alt="20180406205418499.jpg" src="https://i.loli.net/2018/04/15/5ad3565b0245f.jpg"/></p>
<hr/>
<blockquote><p>别晕、别晕 -_-</p>
</blockquote>
<p>或者在自己身前和身后都放一面镜子，深刻体会一会儿 ▄︻┻┳══━一</p>
<h1>递归实现</h1>
<p>接下来就用C语言递归函数来实现阶乘功能，源码如下：</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
int factorial(int n) /*外部定义阶乘函数*/
{
    int m;
    if (n &lt; 0)  /*注意要给函数设置一个递归结束条件*/
    {
        printf("输入错误！"); 
        return 0;
    }
    else if (n == 1)
    {
        m = 1;
    }   
    else
    {
        m = n * factorial(n-1); /*调用函数factorial()自身*/
    }
    return m; 
}
int main()
{
    printf("%d", factorial(5)); 

}
</code></pre>
<p>这是程序大概的运算过程：
<img alt="20180406220517224.jpg" src="https://i.loli.net/2018/04/15/5ad3565b00bba.jpg"/></p>
<hr/>
<blockquote><p><strong>这里要注意给函数设置一个递归结束条件，可以是 if 判断句，不然函数就无限调用自身下去了，你之前看着镜子中的镜子中的……自己都晕，程序自然是崩溃了</strong></p>
</blockquote>
