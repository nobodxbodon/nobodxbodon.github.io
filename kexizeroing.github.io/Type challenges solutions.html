<h2><a href="https://github.com/kexizeroing/kexizeroing.github.io/blob/master/src/posts/type-challenges-solutions.md">仓库源文</a>，<a href="https://kexizeroing.github.io/type-challenges-solutions">站点原文</a></h2>
<hr/>
<p>layout: "../layouts/BlogPost.astro"
title: "Type challenges solutions"
slug: type-challenges-solutions
description: ""
added: ""
top: true
order: 6</p>
<h2>updatedDate: "Oct 9 2024"</h2>
<p>Implement the built-in <code>Pick&lt;T, K&gt;</code> generic without using it. Constructs a type by picking the set of properties K from T.</p>
<pre><code class="lang-ts">interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = MyPick&lt;Todo, "title" | "completed"&gt;;

const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
};

// solution
type MyPick&lt;T, K extends keyof T&gt; = {
  [P in K]: T[P];
}
</code></pre>
<blockquote><p>Why <code>extends</code> is used here instead of <code>in</code>?</p>
<ul>
<li><code>K extends keyof T</code>: "K is a type that is assignable to keyof T"</li>
<li><code>K in keyof T</code>: "K is each key in keyof T"</li>
</ul>
</blockquote>
<p>Implement the built-in <code>Readonly&lt;T&gt;</code> generic without using it. Constructs a type with all properties of T set to <code>readonly</code>, meaning the properties of the constructed type cannot be reassigned.</p>
<pre><code class="lang-ts">interface Todo {
  title: string;
  description: string;
}

const todo: MyReadonly&lt;Todo&gt; = {
  title: "Hey",
  description: "foobar",
};

todo.title = "Hello"; // Error: cannot reassign a readonly property
todo.description = "barFoo"; // Error: cannot reassign a readonly property

// solution
type MyReadonly&lt;T&gt; = {
  readonly [P in keyof T]: T[P]
}
</code></pre>
<p>Implement a generic <code>MyReadonly2&lt;T, K&gt;</code> which takes two type arguments T and K. K specify the set of properties of T that should set to readonly. When K is not provided, it should make all properties readonly, just like the normal <code>Readonly&lt;T&gt;</code>.</p>
<pre><code class="lang-ts">// step 1. intersection of both types
type MyReadonly2&lt;T, K&gt; = Omit&lt;T, K&gt; &amp; { readonly [P in K]: T[P] };

// step 2. set a constraint on K
type MyReadonly2&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; { readonly [P in K]: T[P] };

// step 3. when K is not set at all (K to be “all the keys from T”)
type MyReadonly2&lt;T, K extends keyof T = keyof T&gt; = Omit&lt;T, K&gt; &amp; {
  readonly [P in K]: T[P];
};
</code></pre>
<p>Implement a generic <code>DeepReadonly&lt;T&gt;</code> which makes every parameter of an object and its sub-objects readonly recursively.</p>
<pre><code class="lang-ts">type X = {
  x: {
    a: 1;
    b: "hi";
  };
  y: "hey";
};

type Expected = {
  readonly x: {
    readonly a: 1;
    readonly b: "hi";
  };
  readonly y: "hey";
};

// solution
type DeepReadonly&lt;T&gt; = {
  readonly [P in keyof T]: T[P] extends string | number | boolean | Function 
    ? T[P] 
    : DeepReadonly&lt;T[P]&gt;
}

// or
type DeepReadonly&lt;T&gt; = {
  readonly [P in keyof T]: T[P] extends Record&lt;string, unknown&gt;
    ? DeepReadonly&lt;T[P]&gt;
    : T[P];
};
</code></pre>
<p>Given an array, transform to an object type and the key/value must in the given array.</p>
<pre><code class="lang-ts">const tuple = ["tesla", "model 3", "model X", "model Y"] as const;

// expected { tesla: 'tesla', model 3: 'model 3', model X: 'model X', model Y: 'model Y'}
const result: TupleToObject&lt;typeof tuple&gt;;

// solution 1
type TupleToObject&lt;T extends readonly (string | symbol | number)[]&gt; = {
  [P in T[number]]: P
}

// solution 2
// built-in `PropertyKey` represents the data type of a property key.
// It can be a string, a symbol, or a number.
// https://www.totaltypescript.com/concepts/propertykey-type
type TupleToObject&lt;T extends readonly PropertyKey[]&gt; = {
  [P in T[number]]: P
};
</code></pre>
<p>Implement a generic <code>First&lt;T&gt;</code> that takes an Array T and returns it's first element's type.</p>
<pre><code class="lang-ts">type arr1 = ["a", "b", "c"];
type arr2 = [3, 2, 1];

type head1 = First&lt;arr1&gt;; // expected to be 'a'
type head2 = First&lt;arr2&gt;; // expected to be 3

// solution
type First&lt;T extends any[]&gt; = T extends [] ? never : T[0];
</code></pre>
<p>Implement a generic <code>Last&lt;T&gt;</code> that takes an Array T and returns it's last element's type.</p>
<pre><code class="lang-ts">type arr = ["a", "b", "c"];
type tail = Last&lt;arr&gt;; // expected to be 'c'

// solution
// It is a hint to use **variadic tuple types**; we have an array and we need to work with its elements.
// https://fettblog.eu/variadic-tuple-types-preview/
type Last&lt;T extends any[]&gt; = T extends [...infer X, infer L] ? L : never;
</code></pre>
<p>For given a tuple, you need create a generic <code>Length</code>, pick the length of the tuple.</p>
<pre><code class="lang-ts">type tesla = ["tesla", "model 3", "model X", "model Y"];
type teslaLength = Length&lt;tesla&gt;; // expected 4

// solution
type Length&lt;T extends readonly any[]&gt; = T["length"];
</code></pre>
<p>Implement the built-in <code>Exclude&lt;T, U&gt;</code>. Exclude from T those types that are assignable to U.</p>
<pre><code class="lang-ts">type T0 = MyExclude&lt;"a" | "b" | "c", "a"&gt;; // expected "b" | "c"
type T1 = MyExclude&lt;"a" | "b" | "c", "a" | "b"&gt;; // expected "c"

// solution
type MyExclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<blockquote><p>When you are writing <code>T extends U</code> where T is the union, actually what is happening is TypeScript iterates over the union T and applies the condition to each element.</p>
</blockquote>
<p>If we have a type which is wrapped type like <code>Promise</code>. How we can get a type which is inside the wrapped type? You need to unwrap the type recursively.</p>
<pre><code class="lang-ts">type Example1 = MyAwaited&lt;Promise&lt;string&gt;&gt;; // Type is string
type Example2 = MyAwaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;; // Type is number

// solution
// `infer R` is saying "if T is a Promise, infer the type it contains and call it R".
// `Awaited` is a built-in TypeScript utility type that recursively unwraps Promise types.
type MyAwaited&lt;T&gt; = T extends Promise&lt;infer R&gt; ? Awaited&lt;R&gt; : T;
</code></pre>
<p>Implement a utils <code>If</code> which accepts condition C, a truthy return type T, and a falsy return type F. C is expected to be either <code>true</code> or <code>false</code> while T and F can be any type.</p>
<pre><code class="lang-ts">type A = If&lt;true, "a", "b"&gt;; // expected to be 'a'
type B = If&lt;false, "a", "b"&gt;; // expected to be 'b'

// solution
type If&lt;C extends boolean, T, F&gt; = C extends true ? T : F;
// `strictNullChecks: false`
type If&lt;C extends boolean, T, F&gt; = C extends undefined | null 
  ? never
  : (C extends true ? T : F)
</code></pre>
<p>Implement the JavaScript <code>Array.concat</code> function in the type system. A type takes the two arguments. The output should be a new array that includes inputs in ltr order.</p>
<pre><code class="lang-ts">type Result = Concat&lt;[1], [2]&gt;; // expected to be [1, 2]
// solution
type Concat&lt;T extends unknown[], U extends unknown[]&gt; = [...T, ...U];
</code></pre>
<p>Implement the JavaScript <code>Array.includes</code> function in the type system. A type takes the two arguments. The output should be a boolean true or false.</p>
<pre><code class="lang-ts">// expected to be `false`
type isFruit = Includes&lt;['apple', 'banana', 'orange'], 'dog'&gt; // expected to be `false`

// solution
type Includes&lt;T extends unknown[], U&gt; = U extends T[number] ? true : false;
</code></pre>
<p>Implement the generic version of <code>Array.push</code> and <code>Array.unshift()</code>.</p>
<pre><code class="lang-ts">type Result = Push&lt;[1, 2], "3"&gt;;  // [1, 2, '3']
type Result = Unshift&lt;[1, 2], 0&gt;; // [0, 1, 2]

// solution
type Push&lt;T extends unknown[], U&gt; = [...T, U];
type Unshift&lt;T extends unknown[], U&gt; = [U, ...T];
</code></pre>
<p>Implement a generic <code>Pop&lt;T&gt;</code> that takes an Array T and returns an Array without it's last element.</p>
<pre><code class="lang-ts">type arr = ["a", "b", "c", "d"];
type arr1 = Pop&lt;arr&gt;; // expected to be ['a', 'b', 'c']

// solution
type Pop&lt;T extends any[]&gt; = T extends [...infer H, infer T] ? H : never;
</code></pre>
<p>Implement the built-in <code>Parameters&lt;T&gt;</code> generic without using it.</p>
<pre><code class="lang-ts">const foo = (arg1: string, arg2: number): void =&gt; {...}
type FunctionParamsType = MyParameters&lt;typeof foo&gt; // expected [string, number]

// solution
type MyParameters&lt;T&gt; = T extends (...args: infer P) =&gt; any ? P : never;
</code></pre>
<p>Implement the built-in <code>ReturnType&lt;T&gt;</code> generic without using it.</p>
<pre><code class="lang-ts">const fn = (v: boolean) =&gt; {
  if (v) return 1;
  else return 2;
};
type a = MyReturnType&lt;typeof fn&gt;; // should be "1 | 2"

// solution
type MyReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer P ? P : never
</code></pre>
<p>Implement the built-in <code>Omit&lt;T, K&gt;</code> generic without using it. Constructs a type by picking all properties from T and then removing K.</p>
<pre><code class="lang-ts">interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = MyOmit&lt;Todo, "description" | "title"&gt;;

const todo: TodoPreview = {
  completed: false,
};

// solution
// https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types
// 1. a mapped type can create new object types: type Options&lt;T&gt; = { [P in keyof T]: T[P] };
// 2. re-map keys (`as`) in mapped types to create new keys, or filter out keys
// 3. filter out keys by producing never
type MyOmit&lt;T, K&gt; = { [P in keyof T as P extends K ? never : P]: T[P] };
</code></pre>
<p>Implement a generic <code>TupleToUnion&lt;T&gt;</code> which covers the values of a tuple to its values union.</p>
<pre><code class="lang-ts">type Arr = ['1', 2, boolean]
type Test = TupleToUnion&lt;Arr&gt; // expected '1' | 2 | boolean

// solution
// lookup types: looks like an element access, but are written as types
type TupleToUnion&lt;T&gt; = T extends unknown[] ? T[number] : never
</code></pre>
<p>Type the function <code>PromiseAll</code> that accepts an array of <code>PromiseLike</code> objects. The returning value should be <code>Promise&lt;T&gt;</code> where T is the resolved result array.</p>
<pre><code class="lang-ts">const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise&lt;string&gt;((resolve, reject) =&gt; {
  setTimeout(resolve, 100, "foo");
});

// expected to be `Promise&lt;[number, number, string]&gt;`
const p = Promise.all([promise1, promise2, promise3] as const);

// solution
// step 1. the function that returns Promise&lt;T&gt;
declare function PromiseAll&lt;T&gt;(values: T): Promise&lt;T&gt;;

// step 2. `values` is an array and has a readonly modifier 
declare function PromiseAll&lt;T extends unknown[]&gt;(
  values: readonly [...T],
): Promise&lt;T&gt;;

// step 3. unwrap the type from Promise inside the `values`
declare function PromiseAll&lt;T extends unknown[]&gt;(
  values: readonly [...T],
): Promise&lt;{ [P in keyof T]: T[P] extends Promise&lt;infer R&gt; ? R : T[P] }&gt;;
</code></pre>
