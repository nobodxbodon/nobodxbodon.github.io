<h2><a href="https://github.com/kexizeroing/kexizeroing.github.io/blob/master/src/posts/intro-to-typescript.md">仓库源文</a>，<a href="https://kexizeroing.github.io/intro-to-typescript">站点原文</a></h2>
<hr/>
<p>layout: "../layouts/BlogPost.astro"
title: "Intro to TypeScript"
slug: intro-to-typescript
description: ""
added: "Jun 12 2022"
tags: [js]</p>
<h2>updatedDate: "Aug 8 2024"</h2>
<blockquote><p>There is a broad spectrum of what TypeScript can give you. On the one side of this spectrum, we have: writing good old JavaScript, without types or filling the gaps with any, and after the implementation is done — fixing the types. On the other side of the spectrum, we have type-driven development. Read from <a href="https://www.aleksandra.codes/fighting-with-ts">https://www.aleksandra.codes/fighting-with-ts</a></p>
<p>TypeScript allows you to write complex yet elegant code. Some TypeScript users love to explore the possibilities of the type system and love to encode logic at type level. This practice is known as type gymnastics. The community also helps users to learn type gymnastics by creating fun and challenges such as <a href="https://github.com/type-challenges/type-challenges">type challenges</a>.</p>
<p><a href="https://github.com/JoshuaKGoldberg/create-typescript-app">create-typescript-app</a> is a one-stop-shop solution to set up a new repository with comprehensive, configurable, opinionated TypeScript tooling.</p>
</blockquote>
<p>TypeScript is a strongly typed programming language that builds on JavaScript. It is currently developed and maintained by Microsoft as an open source project. TypeScript supports multiple programming paradigms such as functional, generic, imperative, and object-oriented.</p>
<p>Every time you write JavaScript in e.g. VS Code, TypeScript runs behind the curtains and gives you information on built-in APIs. In fact, a lot of people think that they can live without TypeScript because JavaScript support is so fantastic in modern editors. Guess what’s, it has always been TypeScript. <em>(In VS Code, open a <code>.ts</code> file, <code>Cmd+Shift+P</code> enter "Select TypeScript Version" to check. If you select "Use Workspace Version", the setting is written to <code>.vscode/settings.json</code>.)</em></p>
<h2>Setting up TypeScript</h2>
<p>To start off, the TypeScript compiler will need to be installed in order to convert TypeScript files into JavaScript files. To do this, TypeScript can either be installed globally or only available at the project level.</p>
<pre><code class="lang-sh"># use npm
npm install --global typescript
npm install --save-dev typescript

# use yarn
yarn global add typescript
yarn add --dev typescript
</code></pre>
<p>A <code>tsconfig.json</code> file is used to configure TypeScript project settings. The <code>tsconfig.json</code> file should be put in the project's root directory. You can run the <code>tsc --init</code> to generate a <code>tsconfig.json</code> file with some default options set and a bunch of other options commented out. In order to transpile the TypeScript code to JavaScript, the <code>tsc</code> command needs to be run. Running <code>tsc</code> will have the TypeScript compiler search for the <code>tsconfig.json</code> file which will determine the project's root directory as well as which options to use when compiling the TypeScript.</p>
<pre><code class="lang-json">{
  "compilerOptions": {
    /* Base Options: */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "verbatimModuleSyntax": true,
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    /* If transpiling with TypeScript: */
    "moduleResolution": "NodeNext",
    "module": "NodeNext",
    "outDir": "dist",
    "sourceMap": true,
    /* If NOT transpiling with TypeScript: */
    "moduleResolution": "Bundler",
    "module": "ESNext",
    "noEmit": true,
    // keep the JSX as part of the output to be further consumed by another transform step.
    // "jsx": "preserve",
    /* If your code runs in the DOM: */
    /* "dom" and "dom.iterable" give you types for window, document etc. */
    "lib": ["es2022", "dom", "dom.iterable"],
    /* If your code doesn't run in the DOM: */
    "lib": ["es2022"],
    /* If you're building for a library: */
    "declaration": true,
  }
}
</code></pre>
<p><code>target</code> tells TS which ES specification you want the transpiled code to support. Whatever you choose for <code>target</code> affects the default value of <code>lib</code> which in turn tells TS what type definitions to include in your project. If you need any extra polyfill in your project, <code>lib</code> is how to make TS happy about it. For example, you need to support IE11 but also you would like to use promises. IE11 supports ES5, but promises is an ES6 feature. You import a promises polyfill, but TS is still giving an error. Now you just need to tell TypeScript that your code will target ES5 (<code>"target": "es5"</code>) and it's safe to use promises in the codebase: <code>"lib": ["dom", "es5", "es2015.promise"]</code>.</p>
<p><code>module</code> is a setting with a bunch of different options. But really, there are only two modern options. <code>NodeNext</code> tells TypeScript that your code will be run by Node.js. And <code>Preserve</code> tells TypeScript that an external bundler will handle the bundling.</p>
<blockquote><p>In <code>ESNext</code> you aren’t allowed to write <code>import Foo = require("foo")</code> because we assume there is no <code>require</code>. <strong><code>module: "ESNext"</code> is required with <code>moduleResolution: "bundler"</code></strong>. In <code>NodeNext</code>, we know that a given module might be an ES module or it might be a CJS module, based on its file extension(<code>mjs</code>, <code>.cjs</code>) and/or the <code>type</code> field in the nearest<code>package.json</code> file.</p>
</blockquote>
<p>See examples:</p>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript-Babel-Starter/blob/master/tsconfig.json">https://github.com/Microsoft/TypeScript-Babel-Starter/blob/master/tsconfig.json</a></li>
<li><a href="https://github.com/vuejs/tsconfig/blob/main/tsconfig.json">https://github.com/vuejs/tsconfig/blob/main/tsconfig.json</a></li>
<li><a href="https://www.totaltypescript.com/tsconfig-cheat-sheet">https://www.totaltypescript.com/tsconfig-cheat-sheet</a></li>
<li><a href="https://deno.com/blog/intro-to-tsconfig">https://deno.com/blog/intro-to-tsconfig</a></li>
</ul>
<p>Run <code>tsc --noEmit</code> that tells TypeScript that we just want to check types and not create any output files. If everything in our code is all right, <code>tsc</code> exits with no error. <code>tsc --noEmit --watch</code> will add a <code>watch</code> mode so TypeScript reruns type-checking every time you save a file.</p>
<blockquote><p><code>json</code> doesn't normally allow comments, but comments are valid in <code>tsconfig.json</code>. It's officially supported by TypeScript and VSCode understands it too. What's going on here is <a href="https://github.com/microsoft/node-jsonc-parser">jsonc</a>, or "JSON with JavaScript style comments", a proprietary format used by a bunch of Microsoft products, most notably Typescript and VSCode.</p>
</blockquote>
<p>By the way, <code>jsconfig.json</code> is a descendant of <code>tsconfig.json</code>. The presence of <code>jsconfig.json</code> file in a directory indicates that the directory is the root of a JavaScript project.</p>
<h2>Basic Static Types</h2>
<p>TypeScript brings along static types to the JavaScript language. <strong>TypeScript's types don't exist at runtime.</strong> They're only used to help you catch errors at compile time.</p>
<p><a href="https://www.totaltypescript.com/ts-reset">ts-reset</a> from Total TypeScript is a 'CSS reset' for TypeScript, improving types for common JavaScript API's. For example, <code>.json()</code> and <code>JSON.parse</code> return unknown, <code>.filter(Boolean)</code> behaves exactly how you expect.</p>
<pre><code class="lang-ts">let isAwesome: boolean = true;
let name: string = 'Chris';
let decimalNumber: number = 42;
let whoKnows: any = 1;

// Array types can be written in two ways
let myPetFamily: string[] = ['rocket', 'fluffly', 'harry'];
let myPetFamily: Array&lt;string&gt; = ['rocket', 'fluffly', 'harry'];

// A tuple is an array that contains a fixed number of elements with associated types.
let myFavoriteTuple: [string, number, boolean];
myFavoriteTuple = ['chair', 20, true];

// Tuple types can’t be inferred. If we use type inference directly on a tuple, 
// we will get the wider array type
let tuple = ['Stefan', 38];  // type is (string | number)[]

/*
An enum is a way to associate names to a constant value. 
Enums are useful when you want to have a set of distinct values that have a descriptive name associated with it.
By default, enums are assigned numbers that start at 0 and increase by 1 for each member of the enum.
*/
enum Sizes {
  Small,
  Medium,
  Large,
}
Sizes.Small;   // 0
Sizes.Medium;  // 1
Sizes.Large;   // 2

// The first value can be set to a value other than 0
enum Sizes {
  Small = 1,
  Medium,
  Large,
}
Sizes.Small;   // 1
Sizes.Medium;  // 2
Sizes.Large;   // 3

// String values can also be assigned to an enum.
enum ThemeColors {
  Primary = 'primary',
  Secondary = 'secondary',
  Dark = 'dark',
  DarkSecondary = 'darkSecondary',
}

// Real-world examples of Typescript enums
enum LogLevel {
    ERROR,
    WARNING,
    INFO,
    DEBUG
}

enum HTTPStatus {
  OK = 200,
  Redirect = 301,
  BadRequest = 400,
  Unauthorized = 401,
  NotFound = 404,
  InternalServerError = 500,
}
</code></pre>
<p>Fortunately, you don't have to specify types absolutely everywhere in your code because TypeScript has <strong>Type Inference</strong>. Type inference is what the TypeScript compiler uses to automatically determine types. TypeScript can infer types during variable initialization, when default parameter values are set, and while determining function return values.</p>
<h2>Type Annotation</h2>
<p>When the Type Inference system is not enough, you will need to declare types on variables.</p>
<pre><code class="lang-ts">// Use interface to put together multiple type annotations
interface Animal {
  kind: string;
  weight: number;
  color?: string; // optional property
}

let dog: Animal;
dog = {
  kind: 'mammal',
  weight: 10,
};

// Type Alias
// `interface` and `type` are compatible here, because their shape (structure) is the same.
type Animal = {
  kind: string;
  weight: number;
  color?: string;
};
let dog: Animal;

// Inline Annotations
let dog: {
  kind: string;
  weight: number;
};

dog = {
  kind: 'mammal',
  weight: 10,
};

// Union Type (a type can be one of multiple types, type A = X | Y)
// Narrow down the types of values: typeof, truthiness, instanceof...
const sayHappyBirthday = (name: string | null) =&gt; {
  if (name === null) {
    console.log('Happy birthday!');
  } else {
    console.log(`Happy birthday ${name}!`);
  }
};

// Intersection Type (a type is the combination of all listed types, type A = X &amp; Y)
type Student = {
  id: string;
  age: number;
};
type Employee = {
  companyId: string;
};
let person: Student &amp; Employee;

// `typeof` operator takes any object and extracts the shape of it.
const defaultOrder = {
  x: 1,
  y: {
    a: 'apple',
    b: [1,2]
  }
}
type Order = typeof defaultOrder

function createUser(name: string, role: 'admin' | 'maintenance') {
  return {
    name,
    role,
    createdAt: new Date()
  }
}

const user = createUser('Stefan', 'admin')
type User = typeof user

// Built-in Helper Types (https://www.typescriptlang.org/docs/handbook/utility-types.html)
const fieldsToUpdate: Partial&lt;Todo&gt;
const todo: Readonly&lt;Todo&gt;
const cats: Record&lt;string, string | number&gt;
type TodoPreview = Omit&lt;Todo, "description"&gt;
type TodoPreview = Pick&lt;Todo, "title" | "completed"&gt;
// retrieve the return type from the function signature without run the function
type User = ReturnType&lt;typeof createUser&gt;
// collect all arguments from a function in a tuple
type Param = Parameters&lt;typeof createUser&gt;
</code></pre>
<pre><code class="lang-tsx">// https://www.totaltypescript.com/react-component-props-type-helper
import { ComponentProps } from "react"

type ButtonProps = ComponentProps&lt;"button"&gt;
// "button" | "submit" | "reset" | undefined
type ButtonPropsType = ButtonProps["type"]

type MyDivProps = ComponentProps&lt;"div"&gt; &amp; {
  myProp: string
}

type MyCompProps = ComponentProps&lt;typeof MyComp&gt;
</code></pre>
<p>In TypeScript, every function has a return type. If we don’t explicitly type or infer, the return type is by default <code>void</code>, and <code>void</code> is a keyword in JavaScript returning <code>undefined</code>.</p>
<p><strong>Declaration merging for interfaces</strong> means we can declare an interface at separate positions with different properties, and TypeScript combines all declarations and merges them into one. You use <code>declare</code> to let TypeScript know that the variable exists, even though it's not declared in the code.</p>
<pre><code class="lang-ts">declare module "react" {
  interface CSSProperties {
    [key: `--${string}`]: string | number;
  }
}
</code></pre>
<p><strong>Type hierarchy</strong>: TypeScript sets <code>any</code> as the default type for any value or parameter that is not explicitly typed or can’t be inferred. You will rarely need to declare something as <code>any</code> (<strong>you may need the type <code>unknown</code></strong>, <code>any</code> and <code>unknown</code> are top types). <code>null</code> and <code>undefined</code> are bottom values. (nullish values are excluded from all types if the option <code>strictNullChecks</code> is active in <code>tsconfig.json</code>). The very bottom of the type hierarchy is <code>never</code>. <code>never</code> doesn’t accept a single value at all and is used for situations that should never occur.</p>
<p><strong>Value Types</strong>: We can narrow down primitive types to values.</p>
<pre><code class="lang-ts">// Type is string, because the value can change.
let conference = 'conference';
// Type is 'conference', because the value can't change anymore.
const conf = 'conference';

type TechEvent = {
  title: string,
  kind: 'webinar' | 'conference' | 'meetup'
}
function getEvent(event: TechEvent) {...}

const abc = {
  title: 'abc',
  kind: 'conference'
}
// error here: types of `abc` and TechEvent are incompatible
// the property `kind` in `abc` will not be inferred as 'conference' but as string
getEvent(abc);

// fix 1 (add type annotation)
const abc: TechEvent = {
  title: 'abc',
  kind: 'conference'
}

// fix 2 (type cast to the value type)
const abc = {
  title: 'abc',
  kind: 'conference' as 'conference'
}

// fix 3 (assign a primitive value to a const so fixate its value type) 
const abc = {
  title: 'abc',
  kind: 'conference' as const
}

// Dynamically update types
// lookup type
type EventKind = TechEvent['kind']

// mapped type (keys to be generated automatically and mapped to a TechEvent list)
type GroupedEvents = {
  [Kind in EventKind]: TechEvent[]
}

// keyof (get object keys of the type)
type GroupProperties = keyof GroupedEvents
</code></pre>
<p><strong>Generic Types</strong>: Instead of working with a specific type, we work with a parameter that is then substituted for a specific type. Type parameters are denoted within angle brackets at function heads or class declarations. <em><a href="https://ts.chibicode.com/generics">Generics are not scary</a>. They’re like regular function parameters, but instead of values, it deals with types.</em></p>
<pre><code class="lang-ts">// Type as the parameter
const fillArray = &lt;T&gt;(len: number, elem: T) =&gt; {
  return new Array&lt;T&gt;(len).fill(elem);
};
const newArray = fillArray&lt;string&gt;(3, 'hi');

// Generic constraints (boundaries)
type URLObject = {
  [k: string]: URL
}
function loadFile&lt;Formats extends URLObject&gt;(fileFormats: Formats, format: keyof Formats)
</code></pre>
<h3>Declaring global variables</h3>
<p>If you try to access <code>window.__INITIAL_DATA__</code> in a TypeScript file, the compiler will produce a type error because it can't find a definition of the <code>__INITIAL_DATA__</code> property anywhere.</p>
<pre><code class="lang-ts">// Example comes from https://mariusschulz.com/blog/declaring-global-variables-in-typescript
type InitialData = {
  userID: string;
};

// 1. Declare a global variable using the `declare var` syntax
// declare a global variable in the global scope 
declare global {
  var __INITIAL_DATA__: InitialData;
}

// or create a `globals.d.ts` file
declare var __INITIAL_DATA__: InitialData;


// 2. Augment the window interface
declare global {
  interface Window {
    __INITIAL_DATA__: InitialData;
  }
}
</code></pre>
<h3>How to use @ts-expect-error</h3>
<p><code>@ts-expect-error</code> lets you specify that an error will occur on the next line of the file, which is helpful letting us be sure that an error will occur. If <code>@ts-expect-error</code> doesn't find an error, it will source an error itself <em>(Unused '@ts-expect-error' directive)</em>.</p>
<p>When you actually want to ignore an error, you'll be tempted to use <code>@ts-ignore</code>. It works similarly to <code>@ts-expect-error</code>, except for one thing: it won't error if it doesn't find an error.</p>
<p>Sometimes, you'll want to ignore an error that later down the line gets fixed. If you're using <code>@ts-ignore</code>, it'll just ignore the fact that the error is gone. But with <code>@ts-expect-error</code>, you'll actually get a hint that the directive is now safe to remove. So if you're choosing between them, pick <code>@ts-expect-error</code>.</p>
<h2>Building the Validation Schema with Zod</h2>
<p><a href="https://github.com/colinhacks/zod">Zod</a> is a TypeScript-first schema declaration and validation library. With Zod, you declare a validator once and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.</p>
<pre><code class="lang-js">import { z } from "zod";

// creating a schema for strings
const mySchema = z.string();

// parsing
mySchema.parse("tuna"); // =&gt; "tuna"
mySchema.parse(12); // =&gt; throws ZodError

// "safe" parsing (doesn't throw error if validation fails)
mySchema.safeParse("tuna"); // =&gt; { success: true; data: "tuna" }
mySchema.safeParse(12); // =&gt; { success: false; error: ZodError }

const User = z.object({
  username: z.string(),
});

User.parse({ username: "Ludwig" });

// extract the inferred type
type User = z.infer&lt;typeof User&gt;;
// { username: string }
</code></pre>
<p>Sometimes you don't trust the data entering your app. For those cases, you should use Zod. Let’s build a schema for a form.</p>
<pre><code class="lang-js">const formSchema = z
  .object({
    username: z.string().min(1, "Username is required").max(100),
    email: z.string().email("Invalid email address").min(1, "Email is required"),
    password: z
      .string()
      .min(1, "Password is required")
      .min(8, "Password must have more than 8 characters"),
    confirmPassword: z.string().min(1, "Password confirmation is required"),
  })
  // Zod lets you provide custom validation logic via refinements.
  .refine((data) =&gt; data.password === data.confirmPassword, {
    path: ["confirmPassword"], // path of error
    message: "Passwords do not match",
});

// We can use this type to tell `react-hook-form` what our data should look like.
type FormSchemaType = z.infer&lt;typeof formSchema&gt;;
</code></pre>
<blockquote><p><a href="https://github.com/fabian-hiller/valibot">Valibot</a> is very similar to Zod, helping you validate data easily using a schema. The biggest difference is the modular design and the ability to reduce the bundle size to a minimum.</p>
<p>JSON Schema is a declarative language for defining structure and constraints for JSON data.</p>
<ul>
<li>Zod to JSON Schema: <a href="https://github.com/StefanTerdell/zod-to-json-schema">https://github.com/StefanTerdell/zod-to-json-schema</a></li>
<li>JSON Schema to Zod: <a href="https://github.com/StefanTerdell/json-schema-to-zod">https://github.com/StefanTerdell/json-schema-to-zod</a></li>
</ul>
</blockquote>
<h2>Adding Type Check to JavaScript</h2>
<p>TypeScript provides code analysis for JavaScript and VS Code gives us TypeScript out of the box (TypeScript language server). With the addition of <code>//@ts-check</code> as the very first line in our JavaScript file, TypeScript became active and started to add red lines to code pieces that just don’t make sense.</p>
<p><a href="https://deno.com/blog/document-javascript-package">JSDoc</a> is a way to annotate JavaScript code using comments. JSDoc comments are any block comments that begin with <code>/**</code> and end with <code>*/</code> that precede a block of code. The comments can span multiple lines. Each line should start with <code>*</code> and should be indented by one space. JSDoc supports a variety of tags that can be used to provide additional information about your symbols, such as <code>@param</code> for parameters, <code>@returns</code> for the return value, or <code>@typeParam</code> for type parameters. TypeScript uses this annotations to get more information on our intended types.</p>
<pre><code class="lang-js">// @ts-check
/**
 * @param {number} numberOne
 * @param {number} numberTwo
 * @returns {number}
 */
function addNumbers(numberOne, numberTwo) {
  return numberOne + numberTwo
}

/**
 * @typedef {Object} ShipStorage 
 * @property {number} max
 * @property {string[]} items 
 */

/** @type ShipStorage */
const storage = {
  max: 10,
  items: []
}

/**
 * @param {ShipStorage} storage
 */
function doStuff(storage) {}
</code></pre>
<h2>Set up a Node server with TypeScript in 2024</h2>
<pre><code class="lang-sh"># install dev dependencies
npm i -D typescript ts-node @types/node

# initialize TypeScript
npx tsc --init
</code></pre>
<pre><code class="lang-json">{
  "name": "my-node-app",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "dev": "node --env-file=.env --watch -r ts-node/register src/index.ts",
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "devDependencies": {
    "@types/node": "^20.11.17",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  },
  "engines": {
    "node": "&gt;=20.6.0"
  }
}
</code></pre>
<blockquote><p>Make sure you’re using Node &gt;=20.6 — it’s required for some of the flags used in this setup. The <code>--watch</code> flag was added in Node v18.11.0. The <code>--env-file</code> flag was added in Node v20.6.0.</p>
</blockquote>
<p>How to run ts files from command line? There is <a href="https://github.com/TypeStrong/ts-node">ts-node</a> that will compile the code and REPL for node.js: <code>npx ts-node src/foo.ts</code>. <code>tsc</code> writes js to disk. <code>ts-node</code> doesn't need to do that and runs ts on the fly. But it's not typechecking your code. So we recommend to type check your code first with <code>tsc</code> and then run it with <code>ts-node</code> before shipping it.</p>
<blockquote><p>Run JS/TS file on Node.js using Vite's resolvers and transformers: <code>npx vite-node index.ts</code>. <a href="https://www.npmjs.com/package/vite-node">vite-node</a> is the engine that powers Vitest and Nuxt 3 Dev SSR. It supports ESM &amp; TypeScript out of the box.</p>
</blockquote>
