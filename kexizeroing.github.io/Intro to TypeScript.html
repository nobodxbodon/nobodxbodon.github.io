<h2><a href="https://github.com/kexizeroing/kexizeroing.github.io/blob/master/src/blog/intro-to-typescript.md">仓库源文</a>，<a href="https://kexizeroing.github.io/intro-to-typescript">站点原文</a></h2>
<p>TypeScript is a strongly typed programming language that builds on JavaScript. It is currently developed and maintained by Microsoft as an open source project. TypeScript supports multiple programming paradigms such as functional, generic, imperative, and object-oriented.</p>
<p>Every time you write JavaScript in e.g. VS Code, TypeScript runs behind the curtains and gives you information on built-in APIs. In fact, a lot of people think that they can live without TypeScript because JavaScript support is so fantastic in modern editors. Guess what’s, it has always been TypeScript. <em>In VS Code, open a <code>.ts</code> file, <code>Cmd+Shift+P</code> enter "Select TypeScript Version" to check. There is a "Use VS Code's Version" and "Use Workspace Version" (this is from node_modules).</em></p>
<blockquote><p>Even if you don't write your code in <code>.ts</code> files, you're probably using TypeScript. That's because TypeScript is the IntelliSense engine. Even if you're not using VSCode, if your editor gives you code completion, parameter info, quick info, member lists, etc. while writing JS code, you are almost certainly running the TypeScript language service.</p>
</blockquote>
<h2>Setting up TypeScript</h2>
<p>To start off, the TypeScript compiler will need to be installed in order to convert TypeScript files into JavaScript files. To do this, TypeScript can either be installed globally or only available at the project level.</p>
<p>Run <code>tsc --noEmit</code> that tells TypeScript that we just want to check types and not create any output files. If everything in our code is all right, <code>tsc</code> exits with no error. <code>tsc --noEmit --watch</code> will add a <code>watch</code> mode so TypeScript reruns type-checking every time you save a file.</p>
<p>A <code>tsconfig.json</code> file is used to configure TypeScript project settings. The <code>tsconfig.json</code> file should be put in the project's root directory. You can run the <code>tsc --init</code> to generate a <code>tsconfig.json</code> file with some default options set and a bunch of other options commented out. In order to transpile the TypeScript code to JavaScript, the <code>tsc</code> command needs to be run. Running <code>tsc</code> will have the TypeScript compiler search for the <code>tsconfig.json</code> file which will determine the project's root directory as well as which options to use when compiling the TypeScript.</p>
<pre><code class="lang-json">{
  "compilerOptions": {
    /* Base Options: */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "verbatimModuleSyntax": true,
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,

    /* If transpiling with TypeScript: */
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "dist",
    "sourceMap": true,

    /* If NOT transpiling with TypeScript: */
    "module": "Preserve",
    "moduleResolution": "Bundler",
    "noEmit": true,

    // keep the JSX as part of the output to be further consumed by another transform step.
    // "jsx": "preserve",

    /* If your code runs in the DOM: */
    "lib": ["es2022", "dom", "dom.iterable"],
    /* If your code doesn't run in the DOM: */
    "lib": ["es2022"],

    /* If you're building for a library: */
    // Ts will automatically generate .d.ts files alongside your compiled JS files.
    "declaration": true,
  }
}
</code></pre>
<p><code>strict</code> option acts as shorthand for enabling several different type checking options, including catching potential <code>null</code> or <code>undefined</code> issues and stronger checks for function parameters, among others. Without <code>noUncheckedIndexedAccess</code> enabled, TS assumes that indexing will always return a valid value, even if the index is out of bounds. This means that we have to handle the possibility of <code>undefined</code> values when accessing array or object indices.</p>
<p><code>target</code> tells TS which ES specification you want the transpiled code to support. <code>target</code> doesn't polyfill. <code>lib</code> tells TS what type definitions to include in your project. If you don’t specify it explicitly, TypeScript will choose a default set of libraries based on your <code>target</code>. Basically, set <code>lib</code> to <code>["dom", "dom.iterable", "es2022"]</code> if your code run in the DOM, and set it to <code>["es2022"]</code> if not.</p>
<p><code>module</code> is a setting with a bunch of different options, which specifies how TS should treat your imports and exports. But really, there are only two modern options. <code>NodeNext</code> tells TypeScript that your code will be run by Node.js. And <code>Preserve</code> tells TypeScript that an external bundler will handle the bundling (also set <code>noEmit</code> to true).</p>
<blockquote><p>How does TS know what module system (ESM or CJS) to emit?</p>
<ol>
<li>The way this is decided is via <code>module</code>. You can hardcode this by choosing some older options. <code>module: CommonJS</code> will always emit CommonJS syntax, and <code>module: ESNext</code> will always emit ESM syntax.</li>
<li>Using the recommended <code>module: NodeNext</code>, we know that a given module might be an ES module or it might be a CJS module, based on its file extension(<code>mts</code>, <code>.cts</code>) and/or the <code>type</code> field in the nearest <code>package.json</code> file.</li>
</ol>
</blockquote>
<p><code>module: "NodeNext"</code> also implies <code>moduleResolution: "NodeNext"</code>. <code>NodeNext</code> is a shorthand for the most up-to-date Node.js module behavior. <code>module: "Preserve"</code> implies <code>moduleResolution: "Bundler"</code>.</p>
<p>TypeScript has built-in support for transpiling JSX syntax, and the <code>jsx</code> option tells TS how to handle JSX syntax. <code>preserve</code> means keeps JSX syntax as-is. <code>react</code> transforms JSX into <code>React.createElement</code> calls <em>(for React 16 and earlier)</em>. <code>react-jsx</code> transforms JSX into <code>_jsx</code> calls, and automatically imports from <code>react/jsx-runtime</code> <em>(for React 17 and later)</em>.</p>
<p>By default <code>moduleDetection</code> set to <code>auto</code>, if we don't have any <code>import</code> or <code>export</code> statements in a <code>.ts</code> file, TypeScript treats it as a script. <strong>By adding the <code>export {}</code> statement, you're telling TS that the <code>.ts</code> is a module</strong>. <code>moduleDetection: force</code> will treat all files as modules, and you will need to use <code>import</code> and <code>export</code> statements to access functions and variables across files.</p>
<p>Relative import paths <a href="https://www.totaltypescript.com/relative-import-paths-need-explicit-file-extensions-in-ecmascript-imports">need explicit file extensions in ES imports</a> when <code>--moduleResolution</code> is <code>node16</code> or <code>nodenext</code> <em>(currently identical to <code>node16</code>)</em>.</p>
<ol>
<li>Most bundlers let you omit the file extension when importing files. But TS rules like <code>moduleResolution: NodeNext</code> force you to specify the file extension. This can feel really weird when you're working in <code>.ts</code> files, but writing <code>.js</code> on your imports. Why do we need to do it? Well, it's the spec. <strong>The Node spec requires that you use <code>.js</code> file extensions for all ESM imports and exports. By default, TypeScript does not change the specifiers of imported modules.</strong> If you want to go back to the old style, then specify <code>moduleResolution: Bundler</code> and bundle your code with a tool like esbuild.</li>
<li>TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk is host-defined, and TypeScript is not a host.</li>
<li><code>--allowImportingTsExtensions</code> allows TypeScript files to import each other with a TypeScript-specific extension like <code>.ts</code>, <code>.mts</code>, or <code>.tsx</code>. This flag is only allowed when <code>--noEmit</code> is enabled. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between <code>.ts</code> files work.</li>
</ol>
<pre><code class="lang-js">// @moduleResolution: node16
// @rootDir: src
// @outDir: dist
// @Filename: src/math.mts
export function add(a: number, b: number) {
  return a + b;
}
// @Filename: src/main.mts
import { add } from "./math.mjs";
add(1, 2);
</code></pre>
<p>Since TypeScript 5.0, <code>verbatimModuleSyntax</code> is the recommended way to enforce <code>import type</code>. When it is set to true, any imports or exports without a <code>type</code> modifier are left around. Anything that uses the <code>type</code> modifier is dropped entirely. You may get the message when enabling <code>verbatimModuleSyntax</code> (as expected): <em>'SomeType' is a type and must be imported using a type-only import.</em></p>
<pre><code class="lang-ts">// Erased away entirely
import type { A } from "a";
// Rewritten to `import { b } from "bcd";`
import { b, type c, type d } from "bcd";
// Rewritten to `import {} from "xyz";`
import { type xyz } from "xyz";
</code></pre>
<p>How multiple <code>tsconfig.json</code> files can be composed together?</p>
<ol>
<li>Your IDE determines which <code>tsconfig.json</code> to use by looking for the closest one to the current <code>.ts</code> file.</li>
<li>When you have multiple <code>tsconfig.json</code> files, it's common to have shared settings between them. We can create a new <code>tsconfig.base.json</code> file that can be extended from.</li>
</ol>
<p>See examples:</p>
<ul>
<li><a href="https://github.com/vuejs/tsconfig/blob/main/tsconfig.json">https://github.com/vuejs/tsconfig/blob/main/tsconfig.json</a></li>
<li><a href="https://www.totaltypescript.com/tsconfig-cheat-sheet">https://www.totaltypescript.com/tsconfig-cheat-sheet</a></li>
<li><a href="https://deno.com/blog/intro-to-tsconfig">https://deno.com/blog/intro-to-tsconfig</a></li>
<li><a href="https://github.com/tsconfig/bases">https://github.com/tsconfig/bases</a></li>
</ul>
<blockquote><p><code>json</code> doesn't normally allow comments, but comments are valid in <code>tsconfig.json</code>. It's officially supported by TypeScript, and VSCode understands it too. What's going on here is <a href="https://github.com/microsoft/node-jsonc-parser">jsonc</a>, or "JSON with Comments", a proprietary format used by a bunch of Microsoft products, most notably Typescript and VSCode. For example, VS Code’s <code>settings.json</code> file is actually <code>settings.jsonc</code>.</p>
<p>JSON5 is a superset of JSON that makes JSON more human-friendly, not just comments but also relaxed rules for quoting. It's also a subset of ES5, so valid JSON5 files will always be valid ES5.</p>
<p>They’re both formats/specs (and usually implemented as libraries) that extend standard JSON for developer convenience.</p>
</blockquote>
<p>By the way, <code>jsconfig.json</code> is a descendant of <code>tsconfig.json</code>. The presence of <code>jsconfig.json</code> file in a directory indicates that the directory is the root of a JavaScript project.</p>
<h2>Structural typing</h2>
<p>TypeScript uses structural typing. This system is different than the type system employed by some other popular languages you may have used (e.g. Java, C#, etc.)</p>
<p>The idea behind structural typing is that two types are compatible if their members are compatible. For example, in C# or Java, two classes named <code>MyPoint</code> and <code>YourPoint</code>, both with public <code>int</code> properties x and y, are not interchangeable, even though they are identical. But in a structural type system, the fact that these types have different names is irrelevant. Because they have the same members with the same types, they are identical.</p>
<pre><code class="lang-ts">interface Something&lt;T&gt; {
  name: string;
}
let x: Something&lt;number&gt;;
let y: Something&lt;string&gt;;
// Why is A&lt;string&gt; assignable to A&lt;number&gt; for interface A&lt;T&gt;?
x = y;

// `Something&lt;T&gt;` doesn't use `T` in any member,
// it doesn't matter what type `T` is.
</code></pre>
<h2>Basic Static Types</h2>
<p>TypeScript brings along static types to the JavaScript language. <strong>TypeScript's types don't exist at runtime.</strong> They're only used to help you catch errors at compile time.</p>
<pre><code class="lang-ts">let isAwesome: boolean = true;
let name: string = 'Chris';
let decimalNumber: number = 42;
let whoKnows: any = 1;

// Array types can be written in two ways
let myPetFamily: string[] = ['rocket', 'fluffly', 'harry'];
let myPetFamily: Array&lt;string&gt; = ['rocket', 'fluffly', 'harry'];

// A tuple is an array that contains a fixed number of elements with associated types.
let myFavoriteTuple: [string, number, boolean];
myFavoriteTuple = ['chair', 20, true];

// Tuple types can’t be inferred. If we use type inference directly on a tuple, 
// we will get the wider array type
let tuple = ['Stefan', 38];  // type is (string | number)[]

/*
An enum is a way to associate names to a constant value. 
Enums are useful when you want to have a set of distinct values that have a descriptive name associated with it.
By default, enums are assigned numbers that start at 0 and increase by 1 for each member of the enum.
*/
enum Sizes {
  Small,
  Medium,
  Large,
}
Sizes.Small;   // 0
Sizes.Medium;  // 1
Sizes.Large;   // 2

// The first value can be set to a value other than 0
enum Sizes {
  Small = 1,
  Medium,
  Large,
}
Sizes.Small;   // 1
Sizes.Medium;  // 2
Sizes.Large;   // 3

// String values can also be assigned to an enum
enum ThemeColors {
  Primary = 'primary',
  Secondary = 'secondary',
  Dark = 'dark',
  DarkSecondary = 'darkSecondary',
}

// An object marked "as const" accomplishes the same thing
const status = {
  pending: 0,
  shipped: 1,
  delivered: 2,
  error: 3,
} as const
</code></pre>
<pre><code class="lang-js">// How numeric enums transpile
// `Object.keys` call on an enum will return both the keys and the values.
var AlbumStatus;
(function (AlbumStatus) {
  AlbumStatus[(AlbumStatus["NewRelease"] = 0)] = "NewRelease";
  AlbumStatus[(AlbumStatus["OnSale"] = 1)] = "OnSale";
  AlbumStatus[(AlbumStatus["StaffPick"] = 2)] = "StaffPick";
})(AlbumStatus || (AlbumStatus = {}));

// How string enums transpile
var AlbumStatus;
(function (AlbumStatus) {
  AlbumStatus["NewRelease"] = "NEW_RELEASE";
  AlbumStatus["OnSale"] = "ON_SALE";
  AlbumStatus["StaffPick"] = "STAFF_PICK";
})(AlbumStatus || (AlbumStatus = {}));
</code></pre>
<blockquote><p>String enums and numeric enums behave differently when used as types:</p>
<ul>
<li>Numeric enums are open to a plain number. (either <code>NumEnum.A</code> or <code>0</code> is ok)</li>
<li>String enums are closed, you can only assign their declared enum members. (<code>StrEnum.A</code> is ok, <code>"A"</code> is error)</li>
</ul>
<p>All other types in TypeScript are compared structurally, meaning that two types are considered the same if they have the same structure. But string enums are compared based on their name (nominally), not their structure.</p>
</blockquote>
<p>Fortunately, you don't have to specify types absolutely everywhere in your code because TypeScript has <strong>Type Inference</strong>. Type inference is what the TypeScript compiler uses to automatically determine types. TypeScript can infer types during variable initialization, when default parameter values are set, and while determining function return values.</p>
<h2>Type Annotation</h2>
<p>When the Type Inference system is not enough, you will need to declare types on variables.</p>
<pre><code class="lang-ts">// Use interface to put together multiple type annotations
interface Animal {
  kind: string;
  weight: number;
  color?: string; // optional property
}

// Type Alias
// `interface` and `type` are compatible here, because their shape is the same.
type Animal = {
  kind: string;
  weight: number;
  color?: string;
};

// Union Type (a type can be one of multiple types, type A = X | Y)
// Narrow down the types of values: typeof, truthiness, instanceof...
function validateUsername(username: string | null): boolean {
  if (typeof username === 'string') {
    return username.length &gt; 5
  }

  return false
}

const handleResponse = (response: APIResponse) =&gt; {
  // response.data: Property 'data' does not exist on type 'APIResponse'.
  if ('data' in response) {
    return response.data.id
  }
}

// Intersection Type (a type is the combination of all listed types, type A = X &amp; Y)
type Student = {
  id: string;
  age: number;
};
type Employee = {
  companyId: string;
};
let person: Student &amp; Employee;

// Interfaces using `extends` are faster than type intersections (can cache)

// Object types in TypeScript aren't "sealed" / "closed" / "final". 
// In other words, if you have a variable of type `{ a: string }`, 
// it's possible that the variable points to a value like `{ a: "hello", b: 42 }`.
interface Dimensions {
  width: number;
  height: number;
  depth?: number;
}

const p = {
  width: 32,
  height: 14,
  depht: 11 // &lt;-- fine
};
const q: Dimensions = p; // also fine

declare function handleRequest(url: string, method: "GET" | "POST"): void;
// Error: Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.
// req.method is inferred to be string
const req = { url: "https://example.com", method: "GET" };
handleRequest(req.url, req.method);

// fix: 
const req = { url: "https://example.com", method: "GET" as "GET" };
// or
const req = { url: "https://example.com", method: "GET" } as const;
</code></pre>
<p><strong>Summary of Type vs Interface:</strong>
<a href="https://www.totaltypescript.com/type-vs-interface-which-should-you-use">https://www.totaltypescript.com/type-vs-interface-which-should-you-use</a></p>
<ul>
<li>Interfaces can't express unions or mapped types, only represent object types. Type aliases can express any type.</li>
<li>Interfaces can use <code>extends</code>, types can't. (<code>interface extends</code> is better for catching errors and for performance)</li>
<li>When you're working with objects that inherit from each other, use interfaces. <code>extends</code> makes TypeScript's type checker run slightly faster than using <code>&amp;</code>.</li>
<li>Interfaces with the same name in the same scope merge their declarations. This is very different from <code>type</code>, which would give you an error if you tried to declare the same type twice.</li>
<li>Type aliases have an implicit index signature of <code>Record&lt;PropertyKey, unknown&gt;</code>, but interfaces don't.</li>
</ul>
<blockquote><p>The <code>PropertyKey</code> type is a global type that represents the set of all possible keys that can be used on an object, including string, number, and symbol. You can find its type definition inside of TypeScript's ES5 type definitions file: <code>declare type PropertyKey = string | number | symbol;</code>.</p>
</blockquote>
<pre><code class="lang-ts">// `typeof` operator allows you to extract a type from a value.
// It is not the same as the `typeof` operator used at runtime
const albumSales = {
  "Kind of Blue": 500,
  "A Love Supreme": 100,
  "Mingus Ah Um": 300,
};
type AlbumSalesType = typeof albumSales;
// type AlbumSalesType = {
//    "Kind of Blue": number;
//    "A Love Supreme": number;
//    "Mingus Ah Um": number;
// }

// Runtime typeof
typeof albumSales; // "object"

// Built-in Helper Types
const fieldsToUpdate: Partial&lt;Todo&gt;
const todo: Readonly&lt;Todo&gt;
// same as `ReadonlyArray&lt;string&gt;`
const readOnlyGenres: readonly string[] = ["rock", "pop", "country"]
type TodoPreview = Omit&lt;Todo, "description"&gt;
type TodoPreview = Pick&lt;Todo, "title" | "completed"&gt;

// The `as const` assertion made the entire object deeply read-only,
// including all nested properties. (js `Object.freeze` only at the first level)
const albumAttributes = {
  status: "on-sale",
} as const;

// Derive types from functions
function sellAlbum(album: Album, price: number, quantity: number) {
  return price * quantity
}
// extracts the parameters from a given function type and returns them as a tuple
type SellAlbumParams = Parameters&lt;typeof sellAlbum&gt;  // [album: Album, price: number, quantity: number]
// retrieve the return type from the function signature without run the function
type SellAlbumReturn = ReturnType&lt;typeof sellAlbum&gt;  // number
// unwrap the Promise type and provide the type of the resolved value
type User = Awaited&lt;ReturnType&lt;typeof fetchUser&gt;&gt;

type CustomAwaited&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T

// Indexed access types
type AlbumTitle = Album["title"];
type AlbumPropertyTypes = Album["title" | "isSingle" | "releaseYear"];
type AlbumPropertyTypes = Album[keyof Album];

// Index signatures for dynamic keys
interface AlbumAwards {
  [iCanBeAnything: string]: boolean;
}
// more concise way
const albumAwards: Record&lt;string, boolean&gt; = {};

// Template literal types can be used to interpolate other types into string types
type PngFile = `${string}.png`;
let myImage: PngFile = "my-image.png";

type Headers = {
  Authorization: `Bearer ${string}`;
}

type ColorShade = 100 | 200 | 300;
type Color = "red" | "blue" | "green";
type ColorPalette = `${Color}-${ColorShade}`;

// "name:Bill" -&gt; { key: "name", value: "Bill" }
type KeyValueSplitter&lt;T extends string&gt; = T extends `${infer K}:${infer V}` ? 
  { key: K; value: V } : never;

// { key: "name", value: "Bill" } -&gt; "name:Bill"
type KVJoin&lt;T extends Record&lt;string, string&gt;&gt; = {
  [K in keyof T]: `${K}:${T[K]}`;
}[keyof T];

// The 'string &amp; {}' trick (loose autocomplete)
type ModelNames = 'a' | 'b' | 'c' | (string &amp; {});
const model: ModelNames = 'a';  // autocomplete and can pass in any string
</code></pre>
<p><code>Omit</code> and <code>Pick</code> have some odd behaviour when used with union types. They are not distributive. This means that when you use them with a union type, they don't operate individually on each union member.</p>
<pre><code class="lang-ts">type MusicProduct = Album | CollectorEdition | DigitalRelease;

type MusicProductWithoutId = Omit&lt;MusicProduct, "id"&gt;;

// Expected:
type MusicProductWithoutId =
  | Omit&lt;Album, "id"&gt;
  | Omit&lt;CollectorEdition, "id"&gt;
  | Omit&lt;DigitalRelease, "id"&gt;;

// Actual:
type MusicProductWithoutId = {
  title: string;
};

// Solution to fix: make our own distributive version of Omit
type DistributiveOmit&lt;T, K extends keyof T&gt; = T extends any
  ? Omit&lt;T, K&gt;
  : never
</code></pre>
<blockquote><p>For orginal <code>Pick&lt;T, K extends keyof T&gt;</code>, when <code>T</code> is a union, <code>keyof T</code> does not mean “all keys from all members” — it means the intersection of keys present in every member of the union.</p>
<p><strong>Distributivity rule:</strong> In <code>T extends U ? X : Y</code>, if <code>T</code> is a naked type parameter and <code>T</code> is a union, TypeScript applies the conditional separately to each union member and unions the results.</p>
</blockquote>
<p>It's worth noting the similarities between <code>Exclude/Extract</code> and <code>Omit/Pick</code>. A common mistake is to think that you can <code>Pick</code> from a union, or use <code>Exclude</code> on an object.</p>
<pre><code class="lang-ts">// Exclude/Extract - union (members)
// Omit/Pick - object (properties)
Exclude&lt;'a' | 1, string&gt;
Extract&lt;'a' | 1, string&gt;
Omit&lt;UserObj, 'id'&gt;
Pick&lt;UserObj, 'id'&gt;
</code></pre>
<blockquote><p><code>Exclude&lt;T, U&gt;</code> isn't the same as <code>T &amp; not U</code>. <code>Exclude</code> is a type alias whose only effect is to filter unions. For example, <code>Exclude&lt;string, "hello"&gt;</code> just means <code>string</code>. It doesn't mean "any string except "hello"", because <code>string</code> is not a union, and thus no filtering occurs.</p>
</blockquote>
<p>Every function has a return type. If we don’t explicitly type or infer, the return type is by default <code>void</code>, and <code>void</code> is a keyword in JavaScript returning <code>undefined</code>. If the function is asynchronous, its return type must be a Promise, e.g. <code>Promise&lt;number&gt;</code> means that our function must return a Promise that resolves to a number.</p>
<p>When you're working with React and TypeScript, you may ask how do I figure out the type of a component's props? How do I get all the types that a div or span accepts? The answer is in a single place: <code>ComponentProps</code>.</p>
<pre><code class="lang-tsx">// https://www.totaltypescript.com/react-component-props-type-helper
import { ComponentProps } from "react"

type ButtonProps = ComponentProps&lt;"button"&gt;
// "button" | "submit" | "reset" | undefined
type ButtonPropsType = ButtonProps["type"]

type MyDivProps = ComponentProps&lt;"div"&gt; &amp; {
  myProp: string
}

type MyCompProps = ComponentProps&lt;typeof MyComp&gt;
</code></pre>
<p><strong>Type hierarchy</strong>: TypeScript sets <code>any</code> as the default type for any value or parameter that is not explicitly typed or can’t be inferred. You will rarely need to declare something as <code>any</code> (<strong>you may need the type <code>unknown</code></strong>, which is a safe type). <code>null</code> and <code>undefined</code> are bottom values. (nullish values are excluded from all types if the option <code>strictNullChecks</code> is active in <code>tsconfig.json</code>). The very bottom of the type hierarchy is <code>never</code>. <code>never</code> doesn’t accept a single value at all <em>(only assignable to itself)</em> and is used for situations that should never occur. You cannot assign anything to <code>never</code>, except for <code>never</code> itself. However, you can assign <code>never</code> to anything.</p>
<p><code>any</code> doesn't really fit into our definition of 'wide' and 'narrow' types. It's not really a type at all - it's a way of opting out of TypeScript's type checking. By marking a variable as <code>any</code>, you're telling the compiler to ignore any type errors that might occur. Using <code>any</code> is considered harmful by most of the community.</p>
<p>When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to <code>any</code>. You usually want to avoid this. Use the compiler flag <code>noImplicitAny</code> to flag any implicit <code>any</code> as an error.</p>
<pre><code>                    unknown
       /        /     |      \       \       \
      /        /      |       \       \       \
{ a: string } string number boolean null undefined
       |        |       |       | 
       |      'wow'    123     true 
       |        |       |       | 
       \________\_______\_______\____/______/
                    never
</code></pre>
<p>The empty object type <code>{}</code> is unique. Instead of representing an empty object, it actually represents anything that isn't <code>null</code> or <code>undefined</code>. <code>{}</code> can accept a number of other types: string, number, boolean, function, symbol, and objects containing properties. The only difference between <code>{}</code> and <code>unknown</code> is that <code>unknown</code> contains every single JavaScript value, including <code>null</code> and <code>undefined</code>.</p>
<p><strong>Value Types</strong>: We can narrow down primitive types to values.</p>
<pre><code class="lang-ts">// Type is string, because the value can change.
let conference = 'conference';
// Type is 'conference', because the value can't change anymore.
const conf = 'conference';

type TechEvent = {
  title: string,
  kind: 'webinar' | 'conference' | 'meetup'
}
function getEvent(event: TechEvent) {...}

const abc = {
  title: 'abc',
  kind: 'conference'
}
// error here: types of `abc` and TechEvent are incompatible
// the property `kind` in `abc` will not be inferred as 'conference' but as string
getEvent(abc);

// fix 1 (add type annotation)
const abc: TechEvent = {
  title: 'abc',
  kind: 'conference'
}

// fix 2 (type cast to the value type)
const abc = {
  title: 'abc',
  kind: 'conference' as 'conference'
}

// fix 3 (assign a primitive value to a const so fixate its value type) 
const abc = {
  title: 'abc',
  kind: 'conference' as const
}

// fix 4 (inline the object, no way that `kind` could be changed)
getEvent({
  title: 'abc',
  kind: 'conference'
})

// `keyof` extracts the keys from an object type into a union type
type GroupProperties = keyof GroupedEvents

// grab the keys and values when we don't know the type of an object
type UppercaseAlbumType = keyof typeof albumTypes
type AlbumType = (typeof albumTypes)[keyof typeof albumTypes]

function printUser(user: User) {
  Object.keys(user).forEach((key) =&gt; {
    // TS error: type 'string' can't be used to index type 'User'
    console.log(user[key])
  })
}

// `Object.keys()` returns string[], not Array&lt;keyof T&gt;
// fix 1
console.log(user[key as keyof User])

// fix 2
Object.keys(user) as Array&lt;keyof User&gt;
</code></pre>
<p>The <code>as</code> assertion is a way to tell TypeScript that you know more about a value than it does. It's a way to override TS type inference and tell it to treat a value as a different type. Another assertion we can use is the non-null assertion, which is specified by using the <code>!</code> operator. It tells TS to remove any <code>null</code> or <code>undefined</code> types from the variable.</p>
<pre><code class="lang-ts">const searchParams = new URLSearchParams(window.location.search)
const id = searchParams.get("id") // string | null

const id = searchParams.get("id") as string;

const x = "Heroes" as number; // Error: 'string' is not assignable to type 'number'
const x = "Heroes" as unknown as number;  // this works
// `as unknown as X` is a convenient way to lie to TS

searchParams.get("id")!;  // same as `searchParams.get("id") as string`
console.log(user.profile!.bio);
</code></pre>
<p><strong>Mapped types</strong> allow you to create a new object type based on an existing type by iterating over its keys and values. This can be let you be extremely expressive when creating new object types. For key remapping, <code>as</code> allows us to remap the key while keeping the original key accessible in the loop.</p>
<pre><code class="lang-ts">type Nullable&lt;T&gt; = {
  [K in keyof T]?: T[K] | null;
};

// `as` keyword to remap the key
type AlbumWithUppercaseKeys = {
  [K in keyof Album as Uppercase&lt;K&gt;]: Album[K];
};

type AttributeGetters = {
  [K in keyof T as `get${Capitalize&lt;K&gt;}`]: () =&gt; T[K];
};
</code></pre>
<p><strong>Generic Types</strong>: Instead of working with a specific type, we work with a parameter that is then substituted for a specific type. Type parameters are denoted within angle brackets at function heads or class declarations. <a href="https://ts.chibicode.com/generics">Generics are not scary</a>. They’re like regular function parameters, but instead of values, it deals with types. <em>Generics are erased during compilation.</em></p>
<pre><code class="lang-ts">type ResourceStatus&lt;TContent&gt; =
  | {
      status: "available";
      content: TContent;
    }
  | {
      status: "unavailable";
      reason: string;
    };

type StreamingPlaylist = ResourceStatus&lt;{
  id: number;
  name: string;
  tracks: string[];
}&gt;;

// Generic functions
function identity&lt;T&gt;(arg: T): T {...}

const removeId = &lt;TObj extends { id: unknown }&gt;(obj: TObj) =&gt; {
  const { id, ...rest } = obj;
  return rest;
};

// Set constraints on type parameters
type HasId = {
  id: number;
};
type ResourceStatus&lt;TContent extends HasId, TMetadata extends object = {}&gt; = ...

type StrictOmit&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt;;

// Conditional types
type ToArray&lt;T&gt; = T extends any[] ? T : T[];
</code></pre>
<h3>Understanding <code>infer</code></h3>
<p>The <code>infer</code> keyword is a powerful tool for extracting types from complex structures. It allows you to "infer" a type variable from a more complex type.</p>
<pre><code class="lang-ts">// Extracting the First Element of a Tuple
type FirstElement&lt;T extends any[]&gt; = T extends [infer F, ...any[]] ? F : never;

// Extracting the Type of an Array Element
type ElementType&lt;T extends any[]&gt; = T extends (infer E)[] ? E : never;

// Extracting the Return Type of a Function
type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : never;

// Extracting the Type of a Property from an Object
type PropertyType&lt;T, K extends keyof T&gt; = T extends { [key in K]: infer P } ? P : never;

type TrimWhitespacePrefix&lt;T&gt; = T extends `${" " | "\t" | "\n"}${infer U}`
  ? TrimWhitespacePrefix&lt;U&gt;
  : T;
</code></pre>
<pre><code class="lang-ts">// `infer N` extracts a type from the input.
// `extends number` ensures that the extracted type N is a number.
type ToNumber&lt;S extends string&gt; = S extends `${infer N extends number}` ? N : never;

type Example1 = ToNumber&lt;"123"&gt;; // 123 (number type)
type Example2 = ToNumber&lt;"abc"&gt;; // never
</code></pre>
<blockquote><p><code>infer N extends number</code> declares a type variable N inferred from the input, constrained to number.</p>
</blockquote>
<h3>Clarifying the <code>satisfies</code> operator</h3>
<p>We could try to catch the <code>bleu</code> typo below by using a type annotation, but we’d lose the information about each property.</p>
<pre><code class="lang-ts">type Colors = "red" | "green" | "blue";
type RGB = [red: number, green: number, blue: number];

const palette: Record&lt;Colors, string | RGB&gt; = {
  red: [255, 0, 0],
  green: "#00ff00",
  bleu: [0, 0, 255]
//~~~~ The typo is correctly detected
};

// But we now have an error here - 'palette.red' "could" be a string
const redComponent = palette.red.at(0);
</code></pre>
<p>The <code>satisfies</code> operator lets us validate that the type of an expression matches some type, without changing the resulting type of that expression.</p>
<pre><code class="lang-ts">const palette = {
  red: [255, 0, 0],
  green: "#00ff00",
  bleu: [0, 0, 255]
//~~~~ The typo is also caught
} satisfies Record&lt;Colors, string | RGB&gt;;

// Both of these methods are still accessible
const redComponent = palette.red.at(0);
const greenNormalized = palette.green.toUpperCase();
</code></pre>
<p>When you use a colon, the type BEATS the value. When you use <code>satisfies</code>, the value BEATS the type. It infers the narrowest possible type, not the wider type you specify.</p>
<pre><code class="lang-ts">const routes: Record&lt;string, {}&gt; = {
  "/": {},
  "/users": {},
  "/admin/users": {},
};

// No error
routes.awdkjanwdkjn;

const routes = {
  "/": {},
  "/users": {},
  "/admin/users": {},
} satisfies Record&lt;string, {}&gt;;

// Property 'awdkjanwdkjn' does not exist on type
// '{ "/": {}; "/users": {}; "/admin/users": {}; }'
routes.awdkjanwdkjn;
</code></pre>
<blockquote><ul>
<li>Use <code>as</code> when you want to tell TypeScript that you know more than it does.</li>
<li>Use <code>satisfies</code> when you want to make sure a value is checked without changing the inference on that value.</li>
<li>The rest of the time, use variable annotations.</li>
</ul>
</blockquote>
<h3>Declaration files</h3>
<p>Let's say we have a <code>.js</code> file that exports a function, if we try to import this file into a TypeScript file, we'll get an error: <em>Cannot find module xxx or its corresponding type declarations.</em> To fix this, we can create a declaration file with the same name as the JavaScript file, but with a <code>.d.ts</code> extension.</p>
<ol>
<li>TypeScript doesn't allow us to include any implementation code inside a declaration file.</li>
<li>Describing JavaScript files by hand can be error-prone - and not usually recommended.</li>
</ol>
<p>The <code>declare</code> keyword can be used to define values which don't have an implementation. It defines the value within the scope it's currently in. <code>declare global</code> lets you add things to the global scope.</p>
<pre><code class="lang-ts">declare const MY_CONSTANT: number;
declare function myFunction(): void;
declare const DEBUG: {
  getState: () =&gt; {
    id: string;
  };
};

declare global {
  const ALBUM_API: {
    searchAlbums(query: string): Promise&lt;Album[]&gt;;
  };
}

// declare types for a module 
declare module "duration-utils" {
  export type Status = 'ok' | 'failed';
  export interface MyType {
    name: string;
    status: Status;
  }
  export type List = MyType[];
  export function formatDuration(seconds: number): string;
}
export {}; // Adding an export turns this .d.ts file into a module

// png.d.ts: declare types for non-JavaScript files
declare module "*.png" {
  const png: string;

  export default png;
}
</code></pre>
<p>How does TypeScript know that <code>.map</code> exists on an array, but <code>.transform</code> doesn't? TypeScript ships with a bunch of declaration files that describe the JavaScript environment. For example, <code>map</code> is defined in <code>lib.es5.d.ts</code>, <code>replaceAll</code> is in <code>lib.es2021.string.d.ts</code>. Looking at the code in <code>node_modules/typescript/lib</code>, you'll see dozens of declaration files that describe the JavaScript environment. Another set of declaration files that ship with TypeScript are the DOM types, which are defined in a file called <code>lib.dom.d.ts</code>. The <code>lib</code> setting in <code>tsconfig.json</code> lets you choose which <code>.d.ts</code> files are included in your project. <em><code>lib: ["es2022"]</code> does include the features from earlier ECMAScript versions like ES5, ES2015, ES2021, etc.</em></p>
<pre><code class="lang-json">{
  "compilerOptions": {
    "target": "es2022",
    "lib": ["es2022", "dom", "dom.iterable"],
    "skipLibCheck": true,
  }
}
</code></pre>
<p>The "lib" in <code>skipLibCheck</code> refers to any <code>.d.ts</code> file. In other words, there is no distinction made between <code>.d.ts</code> files which are "yours" (say, in your files list) and "not yours" (say, in <code>node_modules/@types</code>). <code>skipLibCheck</code> will ignore all these files, meaning you won't get type checking on them. Instead, so put your types in regular TypeScript files.</p>
<p>When you install a library with npm, you're downloading JavaScript to your file system, but not every library bundles <code>.d.ts</code> files. The <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped GitHub repository</a> was built to house high-quality type definitions for numerous popular JavaScript libraries that didn't ship definitions of their own. By <strong>installing a package with <code>@types/*</code></strong> as a dev dependency, you can add type definitions that TypeScript will be able to use immediately.</p>
<pre><code class="lang-sh"># For an npm package "foo", typings for it will be at "@types/foo".
npm install --save-dev @types/node

# Types for a scoped package "@foo/bar" should go in "@types/foo__bar",
# remove the @ and add double-underscore after the scope.
npm install --save-dev @types/babel__preset-env
</code></pre>
<h3>Declaring global variables</h3>
<p>There are two options for modifying the global scope in TypeScript: using <code>declare global</code> or creating a <code>.d.ts</code> declaration file. For example, if you try to access <code>window.__INITIAL_DATA__</code> in a TypeScript file, the compiler will produce a type error because it can't find a definition of the <code>__INITIAL_DATA__</code> property anywhere.</p>
<pre><code class="lang-ts">// Example comes from https://mariusschulz.com/blog/declaring-global-variables-in-typescript
type InitialData = {
  userID: string;
};

// 1. Declare a global variable using the `declare var` syntax
// declare a global variable in the global scope 
declare global {
  var __INITIAL_DATA__: InitialData;
}

// or create a `globals.d.ts` file
declare var __INITIAL_DATA__: InitialData;


// 2. Augment the window interface using "declaration merging" feature
declare global {
  interface Window {
    __INITIAL_DATA__: InitialData;
  }
}
</code></pre>
<p>Another example is to specify an environment variable as a string in the global scope. This will be slightly different than the solution for modifying <code>window</code>. In the <code>@types/node</code> package provided by DefinitelyTyped, there is a <code>NodeJS</code> namespace, which includes the <code>ProcessEnv</code> interface. This interface defines the shape of <code>process.env</code> and is where you can add custom environment variable types. <em>(<code>NodeJS.Global</code>, <code>NodeJS.ProcessEnv</code>, <code>NodeJS.Process</code>, etc)</em></p>
<pre><code class="lang-ts">declare namespace NodeJS {
  interface ProcessEnv {
    MY_ENV_VAR: string;   // [key: string]: string;
  }
}
</code></pre>
<h3>How to use @ts-expect-error</h3>
<p><code>@ts-expect-error</code> lets you specify that an error will occur on the next line of the file, which is helpful letting us be sure that an error will occur. If <code>@ts-expect-error</code> doesn't find an error, it will source an error itself: <em>Unused '@ts-expect-error' directive</em>.</p>
<p>When you actually want to ignore an error, you'll be tempted to use <code>@ts-ignore</code>. It works similarly to <code>@ts-expect-error</code>, except for one thing: it won't error if it doesn't find an error.</p>
<p>Sometimes, you'll want to ignore an error that later down the line gets fixed. If you're using <code>@ts-ignore</code>, it'll just ignore the fact that the error is gone. But with <code>@ts-expect-error</code>, you'll actually get a hint that the directive is now safe to remove. So if you're choosing between them, pick <code>@ts-expect-error</code>.</p>
<p>The <code>@ts-nocheck</code> directive will completely remove type checking for a file. To use it, add the directive at the top of your file.</p>
<h3>Classes differences between TS and ES6</h3>
<p>TypeScript supports access modifiers to control property and method visibility. JavaScript traditionally has no access modifiers, but ES2022 introduced private fields with <code>#</code>.</p>
<p>In TS, when you declare constructor parameters with an access modifier (<code>public</code>, <code>private</code>, <code>protected</code>, or <code>readonly</code>), it automatically creates and initializes a class property for you.</p>
<pre><code class="lang-ts">constructor(private readonly httpService: HttpService) {}

// it is equivalent to writing this in a plain ES6 class:
class MyClass {
  constructor(httpService) {
    this.httpService = httpService;
  }
</code></pre>
<p>TypeScript allows classes to implement interfaces.</p>
<pre><code class="lang-ts">interface Printable {
  print(): void;
}

class Document implements Printable {
  print(): void {
    console.log("Printing document...");
  }
}
</code></pre>
<h2>Building the Validation Schema with Zod</h2>
<p><a href="https://github.com/colinhacks/zod">Zod</a> is a TypeScript-first schema declaration and validation library. With Zod, you declare a validator once and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.</p>
<blockquote><p>TypeScript ensures type safety during development and the build process, while Zod validates untrusted data at runtime. TypeScript is enough for internal functions, controlled components; Anything from external sources (APIs, user input) should use Zod.</p>
</blockquote>
<pre><code class="lang-js">import { z } from "zod";

// creating a schema for strings
const mySchema = z.string();

// parsing
mySchema.parse("tuna"); // =&gt; "tuna"
mySchema.parse(12); // =&gt; throws ZodError

// "safe" parsing (doesn't throw error if validation fails)
mySchema.safeParse("tuna"); // =&gt; { success: true; data: "tuna" }
mySchema.safeParse(12); // =&gt; { success: false; error: ZodError }

const userSchema = z.object({
  username: z.string(),
});

userSchema.parse({ username: "Ludwig" });

// extract the inferred type
type User = z.infer&lt;typeof userSchema&gt;;
// { username: string }
</code></pre>
<p>Sometimes you don't trust the data entering your app. For those cases, you should use Zod. Let’s build a schema for a form.</p>
<pre><code class="lang-js">const formSchema = z
  .object({
    username: z.string().min(1, "Username is required").max(100),
    email: z.string().email("Invalid email address").min(1, "Email is required"),
    password: z
      .string()
      .min(1, "Password is required")
      .min(8, "Password must have more than 8 characters"),
    confirmPassword: z.string().min(1, "Password confirmation is required"),
  })
  // Zod lets you provide custom validation logic via refinements.
  .refine((data) =&gt; data.password === data.confirmPassword, {
    path: ["confirmPassword"], // path of error
    message: "Passwords do not match",
});

// We can use this type to tell `react-hook-form` what our data should look like.
type FormSchemaType = z.infer&lt;typeof formSchema&gt;;
</code></pre>
<p>Zod Mini variant was introduced with the release of Zod 4. Use <code>import * as z from "zod/mini"</code> to import it. Zod Mini implements the exact same functionality as zod, but using a functional, tree-shakable API. If you're coming from zod, this means you generally will use functions in place of methods.</p>
<blockquote><p><a href="https://github.com/fabian-hiller/valibot">Valibot</a> is very similar to Zod, helping you validate data easily using a schema. The biggest difference is the modular design and the ability to reduce the bundle size to a minimum.</p>
<p><a href="https://github.com/arktypeio/arktype">ArkType</a> is a TypeScript-first runtime validation library designed to offer concise, composable, and powerful type definitions with zero dependencies, optimized from editor to runtime.</p>
</blockquote>
<p>&lt;br&gt;
&lt;img alt="izod-and-arktype" src="https://raw.githubusercontent.com/kexiZeroing/blog-images/main/zod-and-arktype.png" width="600"&gt;</p>
<h2>Adding Type Check to JavaScript</h2>
<p>TypeScript provides code analysis for JavaScript and VS Code gives us TypeScript out of the box (TypeScript language server). With the addition of <code>//@ts-check</code> as the very first line in our JavaScript file, TypeScript became active and started to add red lines to code pieces that just don’t make sense.</p>
<p><a href="https://deno.com/blog/document-javascript-package">JSDoc</a> is a way to annotate JavaScript code using comments. JSDoc comments are any block comments that begin with <code>/**</code> and end with <code>*/</code> that precede a block of code. The comments can span multiple lines. Each line should start with <code>*</code> and should be indented by one space. JSDoc supports a variety of tags that can be used to provide additional information about your symbols, such as <code>@param</code> for parameters, <code>@returns</code> for the return value, or <code>@typeParam</code> for type parameters. TypeScript uses this annotations to get more information on our intended types.</p>
<blockquote><p>It is also the TypeScript language service that is used to interpret JSDoc comments. That is why the TypeScript CHANGELOG often includes notes about JSDoc features. It also the reason your JSDoc-related IntelliSense can be governed by a <code>tsconfig.json</code> file and you can run <code>tsc</code> on a project typed with JSDoc comments.</p>
</blockquote>
<pre><code class="lang-js">// @ts-check
/**
 * @param {number} numberOne
 * @param {number} numberTwo
 * @returns {number}
 */
function addNumbers(numberOne, numberTwo) {
  return numberOne + numberTwo
}

/**
 * @typedef {Object} ShipStorage 
 * @property {number} max
 * @property {string[]} items 
 */

/** @type ShipStorage */
const storage = {
  max: 10,
  items: []
}

/**
 * @param {ShipStorage} storage
 */
function doStuff(storage) {}
</code></pre>
