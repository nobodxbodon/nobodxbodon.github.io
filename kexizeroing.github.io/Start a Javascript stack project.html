<h2><a href="https://github.com/kexizeroing/kexizeroing.github.io/blob/master/src/posts/start-js-stack-project.md">仓库源文</a>，<a href="https://kexizeroing.github.io/start-js-stack-project">站点原文</a></h2>
<hr/>
<p>layout: "../layouts/BlogPost.astro"
title: "Start a Javascript stack project"
slug: start-js-stack-project
description: ""
added: "Jun 16 2022"
tags: [web]</p>
<h2>updatedDate: "Jun 30 2024"</h2>
<h2>Start a modern web project</h2>
<pre><code>npm create vite@latest

npm create vite@latest my-vue-app -- --template vue
</code></pre>
<pre><code>npx create-next-app@latest my-app --typescript --tailwind --eslint

npx shadcn-ui@latest init

npx shadcn-ui@latest add button
</code></pre>
<pre><code>npx nuxi@latest init my-app
</code></pre>
<p>Start with templates:</p>
<ul>
<li>Awesome Vite: <a href="https://github.com/vitejs/awesome-vite">https://github.com/vitejs/awesome-vite</a></li>
<li>A Next.js 13 template for building apps with Radix UI and Tailwind CSS: <a href="https://github.com/shadcn-ui/next-template">https://github.com/shadcn-ui/next-template</a></li>
<li>Vercel pre-built solutions: <a href="https://vercel.com/templates">https://vercel.com/templates</a></li>
<li>Cloudflare workers: <a href="https://github.com/cloudflare/workers-sdk">https://github.com/cloudflare/workers-sdk</a></li>
</ul>
<p>A typical full stack web application with Next.js, React, shadcn/ui, Prisma, and MySQL:</p>
<ul>
<li>@clerk/nextjs: add authentication and user management to your Next.js application.</li>
<li>prisma and @prisma/client: an open-source ORM for Node.js and TypeScript. You can integrate Prisma with <a href="https://planetscale.com/docs/prisma/prisma-quickstart">PlanetScale</a>, a MySQL-compatible serverless database. The fastest way to get started with Prisma is by following the <a href="https://www.prisma.io/docs/getting-started/quickstart">Quickstart</a>.</li>
<li>zustand: one of many state management libraries for React. It's kinda like Redux, but much simpler.</li>
<li>react-hot-toast: lightweight notifications for React.</li>
<li>lucide-react: implementation of the lucide icon library for react applications.</li>
<li>next-cloudinary: a community-built solution for using Cloudinary in a Next.js project. It includes tools like the <code>CldImage</code> component, social cards, and an upload widget.</li>
<li>@tanstack/react-table: headless UI for building powerful tables &amp; datagrids for React. (<a href="https://tanstack.com/query/latest/docs">@tanstack/react-query</a> is more popular.)</li>
<li>recharts: chart library to help you to write charts in React.</li>
<li>stripe: access to the Stripe API from applications, and use <a href="https://stripe.com/docs/webhooks">webhook</a> to get real-time updates.</li>
<li>react-quill: a React component that wraps Quill.js for both rich text editor and preview (with <code>readonly</code> props).</li>
<li>@mux/mux-node is a Mux API wrapper for Node projects to post a video. Note that this package uses Mux access tokens and secret keys and is intended to be used in server-side code only. Also add @mux/mux-player-react to integrate <a href="https://docs.mux.com">Mux</a> player into your web application.</li>
<li>react-confetti: create a confetti effect to celebrate the accomplishment of particular steps in an application.</li>
</ul>
<blockquote><p>Why Next.js written by @leeerob: I never need to write separate backends for projects I want to create. I can build my entire project with Next.js. I never have to worry about bundler, compiler, or frontend infrastructure. I'm able to use the latest React features, which I personally find to have a great developer experience. Next.js provides a bunch of components that help me keep my site fast.</p>
</blockquote>
<h3>Remix - full stack web framework</h3>
<ul>
<li>Remix Tutorial: <a href="https://remix.run/start/tutorial">https://remix.run/start/tutorial</a></li>
<li>Remix Templates: <a href="https://remix.run/docs/en/main/guides/templates">https://remix.run/docs/en/main/guides/templates</a></li>
<li>Remix for Next.js Developers: <a href="https://remixfornextdevs.com">https://remixfornextdevs.com</a></li>
</ul>
<pre><code class="lang-jsx">export const action = async ({ params, request }: ActionArgs) =&gt; {
  invariant(params.contactId, "Missing contactId param");
  const formData = await request.formData();
  return updateContact(params.contactId, {
    favorite: formData.get("favorite") === "true",
  });
};

export const loader = async ({ params }: LoaderArgs) =&gt; {
  invariant(params.contactId, "Missing contactId param");
  const contact = await getContact(params.contactId);
  if (!contact) {
    throw new Response("Not Found", { status: 404 });
  }
  return json({ contact });
};
</code></pre>
<blockquote><p>An <code>invariant</code> function from <a href="https://github.com/alexreardon/tiny-invariant">tiny-invariant</a> takes a value, and if the value is falsy then the invariant function will throw. If the value is truthy, then the function will not throw.</p>
</blockquote>
<h3>Using Lightning CSS</h3>
<p><a href="https://lightningcss.dev">Lightning CSS</a> is an extremely fast CSS parser, transformer, and minifier written in Rust. It lets you use modern CSS features and future syntax today. Features such as CSS nesting, custom media queries, high gamut color spaces, logical properties, and new selector features are automatically converted to more compatible syntax based on your browser targets. Lightning CSS is used by Vite, and soon by Tailwind and Next.js. Tools like <code>postcss</code> and <code>autoprefixer</code> are being replaced by faster, all-in-one Rust toolchains.</p>
<p>It can be used as a library from JavaScript or Rust, or from a standalone CLI. It can also be wrapped as a plugin in other build tools, and it is built into Parcel out of the box. For example, as a standalone CLI, it can be used to compile, minify, and bundle CSS files: <code>lightningcss --minify --bundle --targets 'defaults' input.css -o output.css</code>.</p>
<p>CSS Modules are a small but impactful enhancement on top of vanilla CSS. A CSS Module is a CSS file where all class names and animation names are scoped locally by default. They treat the classes defined in each file as unique. Each class name or identifier is renamed to include a unique hash, and a mapping is exported to JavaScript to allow referencing them. CSS Modules are available in almost every <a href="https://github.com/css-modules/css-modules/blob/master/docs/get-started.md">modern bundler and framework</a>.</p>
<h3><code>module</code> and <code>require</code> in Node.js</h3>
<p><strong>Node.js treats each JavaScript file as a separate module and encloses the entire code within a function wrapper</strong>: <code>(function(exports, require, module, __filename, __dirname) {})</code>. The five parameters — <code>exports</code>, <code>require</code>, <code>module</code>, <code>__filename</code>, <code>__dirname</code> are available inside each module. Even if you define a global variable in a module using <code>let</code> or <code>const</code> keywords, the variables are scoped locally to the module rather than being scoped globally.</p>
<p>The <code>module</code> parameter refers to the object representing the current module and <code>exports</code> is a key of the <code>module</code> object which is also an object. <code>module.exports</code> is used for defining stuff that can be exported by a module. <code>exports</code> parameter and <code>module.exports</code> are the same unless you reassign <code>exports</code> within your module.</p>
<pre><code class="lang-js">exports.name = 'Alan';
exports.test = function () {};
console.log(module)  // { exports: { name: 'Alan', test: [Function] } }

// exports is a reference and it's no longer same as module.exports if you change the reference
exports = {
  name: 'Bob',
  add: function () {}
}
console.log(exports) // { name: 'Bob', add: [Function] }
console.log(module)  // { exports: { name: 'Alan', test: [Function] } }

module.exports = {
  name: 'Bob',
  add: function () {}
}
console.log(module)  // { exports: { name: 'Bob', add: [Function] } }
</code></pre>
<p><code>require</code> keyword refers to a function which is used to import all the constructs exported using the <code>module.exports</code> from another module. The value returned by the <code>require</code> function in module y is equal to the <code>module.exports</code> object in the module x. The require function takes in an argument which can be a name or a path. You should provide the name as an argument when you are using the third-party modules or core modules provided by NPM. On the other hand, when you have custom modules defined by you, you should provide the path of the module as the argument.</p>
<p>Modules are cached after the first time they are loaded. This means every call to <code>require('foo')</code> will get exactly the same object returned, if it would resolve to the same file.</p>
<h3>browserslist and postcss</h3>
<p>The <a href="https://github.com/browserslist/browserslist">browserslist</a> configuration (either in <code>package.json</code> or <code>.browserslistrc</code>) uses <code>caniuse</code> data (<a href="https://caniuse.com/usage-table">https://caniuse.com/usage-table</a>) for queries to control the outputted JS/CSS so that the emitted code will be compatible with the browsers specified. It will be installed with webpack and used by many popular tools like autoprefixer, babel-preset-env. You can find these tools require <code>browserslist</code> in the <code>package-lock.json</code> file.</p>
<ul>
<li>There is a <code>defaults</code> query (<code>&gt; 0.5%, last 2 versions, Firefox ESR, not dead</code>), which gives a reasonable configuration for most users.</li>
<li>If you want to change the default set of browsers, we recommend combining <code>last 2 versions</code>, <code>not dead</code> with a usage number like <code>&gt; 0.2%</code>.</li>
<li><code>last 1 version or &gt; 1%</code> is equal to <code>last 1 version, &gt; 1%</code>. Each line in <code>.browserslistrc</code> file is combined with <code>or</code> combiner.</li>
<li>Display target browsers from a browserslist config: <a href="https://browsersl.ist/#q=defaults">https://browsersl.ist/#q=defaults</a></li>
<li>Run <code>npx browserslist</code> in project directory to see what browsers was selected by your queries.</li>
</ul>
<p><code>PostCSS</code> is a tool for transforming CSS with JavaScript plugins. It provides features via its extensive plugin ecosystem to help improve the CSS writing experience. Plugins for just about <a href="https://www.postcss.parts">anything</a>. For example:</p>
<ul>
<li><a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> is one of the many popular PostCSS plugins.</li>
<li><a href="https://github.com/postcss/postcss-import">postcss-import</a> to transform <code>@import</code> rules by inlining content. (<code>postcss-import</code> is different than the import rule in native CSS. You should avoid the import rule in native CSS, since it can prevent stylesheets from being downloaded concurrently which affects the loading speed and performance.)</li>
<li><a href="https://www.npmjs.com/package/postcss-preset-env">postcss-preset-env</a> lets you convert modern CSS into something most browsers can understand, which is similar to <code>@babel/preset-env</code>.</li>
<li><a href="https://cssnano.co">cssnano</a> is a compression tool written on top of the PostCSS ecosystem to compact CSS appropriately.</li>
</ul>
<pre><code class="lang-js">// postcss.config.js
module.exports = {
  plugins: [
    require('postcss-import'),
    require('postcss-preset-env')({ stage: 1 }),
    require('cssnano'),
  ]
}
</code></pre>
<h3>Polyfills and Transpilers</h3>
<p>When Babel compiles your code, what it's doing is taking your syntax and running it through various syntax transforms in order to get browser compatible syntax. What it's not doing is adding any new JavaScript primitives or any properties you may need to the browser's global namespace. One way you can think about it is that when you compile your code, you're transforming it. When you add a polyfill, you're adding new functionality to the browser. For example, Babel can transform <code>arrow functions</code> into regular functions, so, they can be compiled. However, there's nothing Babel can do to transform <code>Promises</code> or <code>Math.trunc</code> into native syntax that browsers understand, so they need to be polyfilled.</p>
<p>With syntax transforms, I recommend <code>babel-preset-env</code>. For polyfills, the most popular one is <code>core-js</code>.</p>
<p><code>core-js</code> provides support for the latest ECMAScript standard and proposals, from ancient ES5 features to bleeding edge features. It is one of the main reasons why developers can use modern ECMAScript features in their development process each day for many years, but most developers just don't know that they have this possibility because of <code>core-js</code> since they use <code>core-js</code> indirectly as it's provided by their transpilers or frameworks.</p>
<p><code>core-js</code> is used by most of the popular websites. We can check it using <code>window['__core-js_shared__'].versions</code>, see details at <a href="https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md">https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md</a></p>
<h3>Live Reload and Hot Reload</h3>
<blockquote><p>When a file is edited, the dev server recompiles with the changes, then pushes a notification to the client code in the browser. The app code can then subscribe to "some file changed" notifications, re-import the new version of the code, and swap out the old code for the new code as the app is still running.</p>
</blockquote>
<p><strong>Live Reload</strong> refreshes the entire app when a file changes. For example, if you were four links deep into your navigation and saved a change, live reloading would restart the app and load the app back to the initial route. <strong>Hot Reload</strong> only refreshes the files that were changed without losing the state of the app. (Webpack's <strong>Hot Module Replacement</strong> replaces the modules that have been modified on the fly without reloading the entire page). The advantage of this is that it doesn't lose your app state, e.g. your inputs on your form fields, your currently selected tab.</p>
<h3>Source Map</h3>
<p>Once you've compiled and minified your code, normally alongside it will exist a sourceMap file(<code>file.js.map</code>). <strong>It helps us with debugging transformed code in its original form</strong>. The bundler will add a source map location comment <code>//# sourceMappingURL=/path/to/file.js.map</code> at the end of every generated bundle, which is required to signify to the browser devtools that a source map is available. Another type of source map is inline which has a base64 data URL like <code># sourceMappingURL=data:application/json;base64,xxx...</code></p>
<p>In development all the source files have associated source maps, but we would not want to ship source maps to our production servers.</p>
<ul>
<li>Source maps are usually large; they could be several hundreds of KBs even after compression.</li>
<li>We may not want to share the original source code of our application with the users.</li>
</ul>
<p><a href="https://github.com/danvk/source-map-explorer">source-map-explorer</a> can be used to analyze and debug space usage through source maps. It shows you a treemap visualization to help you debug where all the code is coming from. Note that use your production builds to inspect bundle size with <code>source-map-explorer</code> to ensure you’re previewing optimized code.</p>
<pre><code class="lang-sh">npm install -g source-map-explorer
# Default behavior - write HTML to a temp file and open it in your browser
source-map-explorer bundle.min.js

# Write output in specific formats to a file
source-map-explorer bundle.min.js --html result.html
source-map-explorer bundle.min.js --json result.json

# Get help
source-map-explorer -h
</code></pre>
<p>&lt;img alt="source-map-explorer" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/008i3skNly1gx2pz85jf1j31lf0u07aa.jpg" width="800" /&gt;</p>
<p>One more thing, Chrome DevTools parses the <a href="https://developer.chrome.com/articles/x-google-ignore-list">x_google_ignoreList</a> field in source maps to help improve developer debugging experience (to filter out generated code and let web developers focus only on the code they author.)</p>
<pre><code class="lang-js">/* demo.js.map */
{
  "version": 3,
  "mappings": "AAAAA, ..." 
  "sources": [
    "app.js",
    "components/Button.ts",
    "node_modules/.../framework.js",
    "node_modules/.../library.js",
    ...
  ],
  "x_google_ignoreList": [2, 3],
  ...
}
</code></pre>
<p>&lt;img alt="source-map-ignore" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/sourcemap-ignore.png" width="500" /&gt;</p>
<blockquote><p>Learn source maps from Google Chrome Developers</p>
<ul>
<li>What are source maps: <a href="https://web.dev/articles/source-maps">https://web.dev/articles/source-maps</a></li>
<li>Using source maps in DevTools: <a href="https://www.youtube.com/watch?v=SkUcO4ML5U0">https://www.youtube.com/watch?v=SkUcO4ML5U0</a></li>
</ul>
</blockquote>
<h2>Set up Prettier and ESLint</h2>
<p>Install <code>Prettier</code> and <code>ESLint</code> VSCode plugins and enable <code>format on save</code> in settings (execute <code>save without formatting</code> command to disable). If you don't see the code formatted automatically on file save then it might be because you have multiple formatters installed in VS Code. Set <code>Format Document With...</code> and choose prettier to get it working.</p>
<p>Install npm packages <code>npm i -D eslint prettier</code>. ESLint only as an npm package does not provide any editor integration, only the CLI executable. Run <code>eslint --init</code> to create a <code>eslintrc.json</code> (or <code>.js</code>, <code>.yml</code>) config file after install eslint globally <code>npm i -g eslint</code> (otherwise need to run <code>./node_modules/eslint/bin/eslint.js --init</code>), pick the options as you prefer. Add <code>eslint src</code> as a lint script which can be run as <code>npm run lint</code>, and it shows eslint errors in the Problems tab. Run <code>npm run lint -- --fix</code> to fix errors (if not format on save).</p>
<p>Formatting and linting are two separate concerns. Use Prettier for code formatting concerns, and linters for code-quality concerns. Mixing the two can have negative impacts on the performance and understandability of your developer tooling.</p>
<ul>
<li><code>eslint-plugin-prettier</code> is a legacy plugin developed a long time ago. It runs Prettier as if it were an ESLint rule, applies formatting on <code>--fix</code>, and <strong>is not recommended</strong>.</li>
<li><code>eslint-config-prettier</code> is the config that turns off all formatting rules. It's recommended by Prettier to be used together with Prettier. You'd still use Prettier itself to actually do the formatting. (Add explicit <code>yarn prettier --check .</code> to CI.)</li>
</ul>
<p>If you don’t use a legacy ESLint shareable config that enables formatting rules, you probably don’t need <code>eslint-config-prettier</code>. Adding <code>eslint-config-prettier</code> at the end of the "extends" list doesn’t do anything if nothing enabled formatting rules to begin with.</p>
<p>Check out the following resources:</p>
<ol>
<li><a href="https://www.joshuakgoldberg.com/blog/you-probably-dont-need-eslint-config-prettier-or-eslint-plugin-prettier/">You Probably Don't Need eslint-config-prettier or eslint-plugin-prettier</a></li>
<li><a href="https://github.com/epicweb-dev/config">Reasonable ESLint, Prettier, and TypeScript configs</a></li>
</ol>
<h3>What is Husky</h3>
<p>While working on an enterprise development team, it is important that all code linting and unit tests are passing before committing code, especially if you are using some form of continuous integration. <a href="https://githooks.com">Git Hooks</a> are a built-in feature of Git that can execute automatically when certain events occur. <strong>Husky</strong>, as a project, is a very popular npm package that allows custom scripts to be ran against your repository to prevent bad <code>git commit</code> and <code>git push</code>, which makes commits of fixing lint errors doesn't happen.</p>
<p>Install husky <code>npm i -D husky</code> and have a "husky" section in the <code>package.json</code> file to add git hooks.</p>
<pre><code class="lang-json">// package.json
"husky": {
    "hooks": {
        "pre-commit": "npm run lint &amp;&amp; npm run test",
        "pre-push": "npm test"
    }
}
</code></pre>
<h2>Deployment a Node.js App with the frontend</h2>
<p>Setup an Ubuntu server, install Node.js, and deploy the app with PM2 process manager and Nginx. This <a href="https://gist.github.com/bradtraversy/b8b72581ddc940e0a41e0bc09172d91b">GitHub gist</a> explains how to deploy to linode and all of the setup steps.</p>
<pre><code>sudo npm install -g pm2
pm2 start backend/server.js

sudo apt install nginx

location / {
  proxy_pass http://localhost:5000;
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection 'upgrade';
  proxy_set_header Host $host;
  proxy_cache_bypass $http_upgrade;
}
</code></pre>
<h3>Debugging Node.js with <code>--inspect-brk</code></h3>
<p><a href="https://www.builder.io/blog/debug-nodejs">https://www.builder.io/blog/debug-nodejs</a></p>
<p>Launch your Node.js process using the <code>--inspect-brk</code> flag (<code>node server.js --inspect-brk</code>). Now, open up any Edge or Chrome dev tools window and click the little green Node.js logo button. A new instance of DevTools will open and connect to the node process.</p>
<blockquote><p>Node.js 20.6.0 now supports reading <code>.env</code> files with the <code>--env-file</code> flag. You'll no longer need the <code>dotenv</code> package. Also supports passing runtime flags like <code>--inspect</code> and <code>--watch</code>. Example from @wesbos:<br/>
&lt;img alt="node-env" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/F5WdyiKXEAAY7So.jpeg" width="600" /&gt;</p>
</blockquote>
<h2>Introducing the Backend For Frontend</h2>
<p>We had server-side functionality which we wanted to expose both via our desktop web UI, and via one or more mobile UIs. We often faced a problem in accommodating these new types of user interface, often as we already had a tight coupling between the desktop web UI and our backed services. However the nature of a mobile experience differs from a desktop web experience. In practice, our mobile devices will want to make different calls, fewer calls, and will want to display different (and probably less) data than their desktop counterparts. This means that we need to add additional functionality to our API backend to support our mobile interfaces.</p>
<p>One solution to this problem is that rather than have a general-purpose API backend, instead you have one backend per user experience - or call it a Backend For Frontend (BFF). The BFF is tightly coupled to a specific UI, and will typically be maintained by the same team as the user interface, thereby making it easier to define and adapt the API as the UI requires.</p>
<p>BFFs can be a useful pattern for architectures where there are a number of backend services, as the need to aggregate multiple downstream calls to deliver user functionality increases. In such situations it will be common for a single call in to a BFF to result in multiple downstream calls to microservices (multiple services hold the pieces of information we want).</p>
<p>The other benefit of using a BFF is that the team creating the interface can be much more fluid in thinking about where functionality lives. For example they could decide to push functionality on to the server-side to promote reuse in the future and simplify a native mobile application, or to allow for the faster release of new functionality. This decision is one that can be made by the team in isolation if they own both the mobile application and the BFF - it doesn't require any cross-team coordination.</p>
<h2>Jamstack</h2>
<p>Jamstack is a web architecture and stands for <strong>J</strong>avascript, <strong>A</strong>PIs, and <strong>M</strong>arkup stack. In this architecture, the frontend and the backend are completely separate. All interactions with the backend and third parties are done using APIs. Markup that incorporates Javascript, is pre-built into static assets, served to a client from a CDN, and relies on reusable APIs for its functionalities. <strong>A Jamstack site is a set of pre-generated static assets served from a CDN.</strong></p>
<blockquote><p>Jamstack is a way of working. It’s not a group of frameworks or services or tied to any particular brands or tech stack. Jamstack is defined by how you build websites, rather than the tools with which you choose to build them.</p>
</blockquote>
<p>Jamstack sites have better performance, are easier to secure and scale, and cost a lot less than sites built with traditional architectures (Jamstack hosting providers take care of all of this for you). Pre-building pages ensure that any errors can be detected early enough. Most importantly, Jamstack allows teams to outsource complex services to vendors who provide, maintain, and secure APIs used on their sites. The APIs can provide specific functionality to static sites like payments, authentication, search, image uploads using Paypal, Auth0, Algolia, Cloudinary.</p>
<p>The most common types of Jamstack site build tools include static site generators (SSG) and headless content management systems (CMS). <strong>Static site generators</strong> are build tools that add content to templates and produce static web pages of a site. These generators can be used for Jamstack sites. Some well-known site generators include Hugo, Gatsby, Jekyll, Next.js, etc.</p>
<p>There are two points in time that you can integrate dynamic content into a Jamsack application:</p>
<ul>
<li><strong>Build time</strong> - During the build process, a Jamstack site can call out to any number of external API services to fetch data to pre-generate static pages. You can think of it like a content cache that applies to all your site’s users.</li>
<li><strong>Run time</strong> - This should typically be content that is user specific, needs to update frequently, or is in response to a specific user action. For example, an ecommerce site may have product details populated at build time, but things like the current inventory, shipping options/prices based upon the user’s location, or the user’s shopping cart would all be populated at run time in the browser. As you may notice, in this example, the content on a single page (product details) may be a combination of both pre-rendered (build time) content (i.e. the product name, photo and description) and run time content (i.e. the product inventory and shipping options based on location).</li>
</ul>
<blockquote><p>What type of website are you building? <a href="https://whattheframework.netlify.app">https://whattheframework.netlify.app</a></p>
</blockquote>
<h2>Headless UI and shadcn/ui</h2>
<p>The web platform is severely lacking in terms of UI components. There's pretty minimal by way of built-in components, and for many that do exist, they are extremely difficult to style. What's best is to get a "headless" UI library: One which handles the logic of accessible, reusable components, but leaves the styling up to you. Headless UI components separate the logic &amp; behavior of a component from its visual representation. They offer maximum visual flexibility by providing no interface.</p>
<p>People constantly have to reinvent the wheel to offer fairly basic functionality, so it’s good that there are libraries to handle the behaviour and accessibility while supporting whatever visual styles you want to make.</p>
<ul>
<li><a href="https://headlessui.com">Headless UI</a> is a good example, which contains completely unstyled, fully accessible UI components, designed to integrate beautifully with Tailwind CSS.</li>
<li><a href="https://github.com/radix-ui/primitives">Radix UI</a> is a low-level UI component library with a focus on accessibility, customization and developer experience. You can use these components either as the base layer of your design system, or adopt them incrementally. Try out: <a href="https://www.radix-ui.com/themes/playground">https://www.radix-ui.com/themes/playground</a></li>
</ul>
<p>Examples:</p>
<ol>
<li>The video <a href="https://www.youtube.com/watch?v=lY-RQjWeweo">So You Think You Can Build A Dropdown?</a> is diving deep into the complexities of designing and building a fully-accessible dropdown menu.</li>
<li><a href="https://github.com/emilkowalski/vaul">Vaul</a> is an unstyled drawer component for React that can be used as a Dialog replacement on tablet and mobile devices.</li>
</ol>
<p>Then it leaves us with the decision about how to style things. This is where <a href="https://ui.shadcn.com">shadcn/ui</a> comes into the picture. It's not a component library, but more of a code registry where you can copy/paste/modify the code to your content. It's built with Tailwind and Radix. <code>shadcn/ui</code> is a collection of reusable components that can be copied and pasted into your apps. Every component can be installed separately. It also provides a CLI that can be used to easily import components into your project, as simple as <code>npx shadcn-ui add card</code>, making it even more convenient to use.</p>
<h3>Design system examples</h3>
<p>A design system is an ever evolving collection of reusable components, guided by rules that ensure consistency and speed, by being the single source of truth for any product development.</p>
<ul>
<li><p>Stack Overflow's Design System: <a href="https://stackoverflow.design">https://stackoverflow.design</a></p>
</li>
<li><p>GitHub’s design system: <a href="https://primer.style">https://primer.style</a></p>
</li>
<li><p>Vercel's Design System: <a href="https://vercel.com/geist/introduction">https://vercel.com/geist/introduction</a></p>
</li>
<li><p>Shopify's Design System: <a href="https://polaris.shopify.com">https://polaris.shopify.com</a></p>
</li>
<li><p>GOV.UK Design System: <a href="https://design-system.service.gov.uk">https://design-system.service.gov.uk</a></p>
</li>
<li><p>Atlassian's Design System: <a href="https://atlassian.design">https://atlassian.design</a></p>
</li>
</ul>
<h2>Serverless</h2>
<p>Your code needs to be hosted on a server. Depending on the size of your code and the amount of users you expect to use your product, you might need many servers. Companies used to have their own facilities and warehouses that held their servers and many still do. But for many, this is not ideal. Servers can be difficult to maintain. Maintaining servers and the buildings that house them can become expensive too. That's where AWS and other <a href="https://getdeploying.com">cloud providers</a> come in.</p>
<p>Cloud is basically renting out servers and data storage that's owned by someone else (Serverless does not mean there aren't any servers; You still need servers to host and run your code.) Through the cloud provider (AWS, Azure, or Google Cloud), you gain access to resources like storage services, servers, networking, analytics, AI, and more. There are many other benefits: You pay only for what you use. You can easily spin up and use new servers when needed, allowing you to scale quickly. You can deploy applications globally.</p>
<p>Serverless is just a way of handling how you are using servers. Instead of handling all the infrastructure and server operations yourself you're relying on a cloud provider. There are different families of cloud services:</p>
<ul>
<li><strong>Infrastructure as a service (IaaS)</strong> - Amazon EC2, Digital Ocean</li>
<li><strong>Platform as a service (PaaS)</strong> - Heroku, AWS Elastic Beanstalk</li>
<li><strong>Software as a service (SaaS)</strong> - Dropbox, iCloud, Slack</li>
<li><strong>Function as a service (FaaS)</strong> - AWS Lambda</li>
</ul>
<p>Serverless functions are an approach to writing back-end code that doesn’t require writing a back-end. In the simplest terms: we write a function using our preferred language, like JavaScript; we send that function to a serverless provider; and then we can call that function just like any API using HTTP methods. These Functions are co-located with your code and part of your Git workflow. You can focus on the business needs and developing a better quality application instead of worrying about the infrastructure and maintenance of a traditional server.</p>
<blockquote><p>AWS provides all the necessary building blocks for the modern web. With over 200 services, AWS caters to every aspect of web application infrastructure, including compute, storage, databases, machine learning, and more. Start watching Basic Elements of AWS: <a href="https://www.proaws.dev/tutorials/basic-elements-of-aws~hk2qv">https://www.proaws.dev/tutorials/basic-elements-of-aws~hk2qv</a></p>
</blockquote>
<h3>Netlify functions</h3>
<p>The serverless functions can be run by <a href="https://cli.netlify.com/netlify-dev">Netlify Dev</a> in the same way they would be when deployed to the cloud. Once you've configured the functions directory in your <code>netlify.toml</code>, the functions will be accessible through netlify dev server. e.g. at <code>http://localhost:8888/.netlify/functions/{function-name}</code>.</p>
<p>Go through the guide (mainly on traditional serverless functions): <a href="https://www.netlify.com/blog/intro-to-serverless-functions/">https://www.netlify.com/blog/intro-to-serverless-functions/</a></p>
<pre><code class="lang-js">// netlify/functions/hello-world.js
export const handler = async () =&gt; {
  return {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Hello world!'
    })
  }
}
</code></pre>
<pre><code class="lang-js">fetchBtn.addEventListener('click', async () =&gt; {
  const response = await fetch('/.netlify/functions/hello-world').then(
    response =&gt; response.json()
  )

  responseText.innerText = JSON.stringify(response)
})
</code></pre>
<h3>What is "edge compute"?</h3>
<p>To solve the latency problem, very smart folks came up with the idea of deploying multiple copies of a program and distributing it around the world. When a user makes a request, it can be handled by the closest copy, thus reducing the distance traveled and the time spent in transit.</p>
<ul>
<li>The <strong>Origin server</strong> refers to the main computer that stores and runs the original version of your application code.</li>
<li><strong>CDNs</strong> store static content (such as HTML and image files) in multiple locations around the world. When a new request comes in, the closest CDN location to the user can respond with the cached result.</li>
<li>Similar to CDNs, <strong>Edge servers</strong> are distributed to multiple locations around the world. But unlike CDNs, which store static content, some Edge servers can run small snippets of code. This means both caching and code execution can be done at the Edge closer to the user.</li>
</ul>
<blockquote><p>Cloud = a server, somewhere;<br/>
Edge = a server, close to you;<br/>
Edge functions = serverless functions run at the Edge;</p>
<p>Edge functions without the database in the same place aren't providing meaningful improvements. Most data is not globally replicated. So running compute in many regions, which all connect to a us-east database, made no sense.</p>
</blockquote>
<p>So what JS engines/runtimes do we have now?</p>
<ul>
<li>Three main engines: V8 (Chromium), SpiderMonkey (Firefox), JavaScriptCore (Safari)</li>
<li>Node.js, Deno, Cloudflare Workers: all run on V8</li>
<li>Bun: runs on JavascriptCore</li>
<li>Edge-computing providers: a limited JavaScript environment running on CDN Nodes</li>
</ul>
<p>For example, <a href="https://developers.cloudflare.com/workers/learning/how-workers-works">Cloudflare Workers</a> provides a serverless execution environment that allows you to create new applications without configuring or maintaining infrastructure. Under the hood, the Workers runtime uses the V8 engine. The Workers runtime also implements many of the standard APIs available in most modern browsers. Rather than running on an individual’s machine, Workers functions run on Cloudflare’s Edge Network - a growing global network of thousands of machines distributed across hundreds of locations.</p>
<blockquote><p><em>workerd</em> is a JavaScript / Wasm server runtime based on the same code that powers Cloudflare Workers. The name "workerd" (pronounced "worker dee") comes from the Unix tradition of naming servers with a "-d" suffix standing for "daemon". The name is not capitalized because it is a program name, which are traditionally lower-case in Unix-like environments.</p>
</blockquote>
<p>Read more about The Edge:</p>
<ul>
<li><a href="https://vercel.com/docs/functions/edge-functions">Vercel Edge Functions</a> (using CloudFlare Workers under the hood)</li>
<li><a href="https://www.netlify.com/blog/edge-functions-explained">Netlify Edge Functions</a> (using Deno under the hood)</li>
<li><a href="https://nuxt.com/blog/nuxt-on-the-edge">Nuxt on the Edge</a></li>
</ul>
