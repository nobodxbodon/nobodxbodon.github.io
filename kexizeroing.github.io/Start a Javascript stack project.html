<h2><a href="https://github.com/kexizeroing/kexizeroing.github.io/blob/master/src/blog/start-js-stack-project.md">仓库源文</a>，<a href="https://kexizeroing.github.io/start-js-stack-project">站点原文</a></h2>
<h2>Start a modern web project</h2>
<pre><code class="lang-sh"># `npm create` is an alias for `npm init`
npm create vite@latest

npm create vite@latest my-vue-app -- --template vue
</code></pre>
<pre><code class="lang-sh">npx create-next-app@latest my-app --typescript --tailwind --eslint

npx shadcn-ui@latest init
</code></pre>
<pre><code class="lang-sh"># nuxt@latest also works. `nuxi` is the cli package, it's minimal and fast to download
# When you install nuxt, it re-exports nuxi as both `nuxi` and `nuxt`
npx nuxi@latest init my-app

# You can build SPA with Nuxt, similar to Vite+Vue but with the power of the Nuxt ecosystem.
# nuxt.config.js
export default {
  ssr: false
}
</code></pre>
<p>Start with templates:</p>
<ul>
<li><a href="https://github.com/vitejs/awesome-vite">https://github.com/vitejs/awesome-vite</a></li>
<li><a href="https://vercel.com/templates">https://vercel.com/templates</a></li>
<li><a href="https://github.com/TanStack/create-tsrouter-app">https://github.com/TanStack/create-tsrouter-app</a></li>
<li><a href="https://nextjs.org/blog/building-apis-with-nextjs">https://nextjs.org/blog/building-apis-with-nextjs</a></li>
</ul>
<p>A typical full stack web application with Next.js, React, shadcn/ui, Prisma, and MySQL:</p>
<ul>
<li>@clerk/nextjs: add authentication and user management to your Next.js application.</li>
<li>prisma and @prisma/client: an open-source ORM for Node.js and TypeScript. You can integrate Prisma with <a href="https://planetscale.com/docs/prisma/prisma-quickstart">PlanetScale</a>, a MySQL-compatible serverless database. The fastest way to get started with Prisma is by following the <a href="https://www.prisma.io/docs/getting-started/quickstart">Quickstart</a>.</li>
<li><a href="https://neon.tech">Neon</a> is a serverless Postgres platform, <em>Neon is to PostgreSQL as PlanetScale is to MySQL</em>. Neon provides a generous free tier, making it a good fit for small applications and hobby projects. (PlanetScale has made the decision to stop offering the Hobby tier.)</li>
<li><a href="https://upstash.com">Upstash</a> is a serverless data platform with Redis, Kafka and Vector Database APIs.</li>
<li>zustand: one of many state management libraries for React. It's kinda like Redux, but much simpler.</li>
<li>react-hot-toast: lightweight notifications for React.</li>
<li>lucide-react: implementation of the lucide icon library for react applications.</li>
<li>next-cloudinary: a community-built solution for using Cloudinary in a Next.js project. It includes tools like the <code>CldImage</code> component, social cards, and an upload widget.</li>
<li>@tanstack/react-table: headless UI for building powerful tables &amp; datagrids for React. (<a href="https://tanstack.com/query/latest/docs">@tanstack/react-query</a> is more popular.)</li>
<li>recharts: chart library to help you to write charts in React.</li>
<li>stripe: access to the Stripe API from applications, and use <a href="https://stripe.com/docs/webhooks">webhook</a> to get real-time updates.</li>
<li>@mux/mux-node is a Mux API wrapper for Node projects to post a video. Note that this package uses Mux access tokens and secret keys and is intended to be used in server-side code only. Also add @mux/mux-player-react to integrate <a href="https://docs.mux.com">Mux</a> player into your web application.</li>
<li><a href="https://next-video.dev">next-video</a> is a react component for adding video to your next.js application. It extends both the <code>&lt;video&gt;</code> element and your Next app with features for automatic video optimization.</li>
<li>react-confetti: create a confetti effect to celebrate the accomplishment of particular steps in an application.</li>
<li><a href="https://github.com/vercel/next.js/tree/canary/examples/auth">next-auth</a> is a complete open-source authentication solution for Next.js applications. <a href="https://github.com/codegenixdev/auth-nextjs-tutorial">auth-nextjs-tutorial</a> is an example project covering both OAuth providers and traditional credential-based authentication.</li>
</ul>
<blockquote><p>Why Next.js written by @leeerob: I never need to write separate backends for projects I want to create. I can build my entire project with Next.js. I never have to worry about bundler, compiler, or frontend infrastructure. I'm able to use the latest React features, which I personally find to have a great developer experience. Next.js provides a bunch of components that help me keep my site fast.</p>
</blockquote>
<h3>Remix - full stack web framework</h3>
<ul>
<li>Remix Tutorial: <a href="https://remix.run/start/tutorial">https://remix.run/start/tutorial</a></li>
<li>React Router Tutorial: <a href="https://reactrouter.com/tutorials/address-book">https://reactrouter.com/tutorials/address-book</a></li>
<li>Remix Templates: <a href="https://remix.run/docs/en/main/guides/templates">https://remix.run/docs/en/main/guides/templates</a></li>
<li>Remix for Next.js Developers: <a href="https://remixfornextdevs.com">https://remixfornextdevs.com</a></li>
</ul>
<pre><code class="lang-jsx">export const action = async ({ params, request }: ActionArgs) =&gt; {
  invariant(params.contactId, "Missing contactId param");
  const formData = await request.formData();
  return updateContact(params.contactId, {
    favorite: formData.get("favorite") === "true",
  });
};

export const loader = async ({ params }: LoaderArgs) =&gt; {
  invariant(params.contactId, "Missing contactId param");
  const contact = await getContact(params.contactId);
  if (!contact) {
    throw new Response("Not Found", { status: 404 });
  }
  return json({ contact });
};
</code></pre>
<blockquote><p>An <code>invariant</code> function from <a href="https://github.com/alexreardon/tiny-invariant">tiny-invariant</a> takes a value, and if the value is falsy then the invariant function will throw. If the value is truthy, then the function will not throw.</p>
</blockquote>
<h3>Modular architecture of Front-end applications</h3>
<p>&lt;img alt="apple-style-dock" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/modular-architecture.png" width="700"&gt;</p>
<ul>
<li>Components can’t use modules, but can use everything from the UI layer, while modules use components but can’t use pages. And pages only use modules.</li>
<li>A module shouldn’t use another module, and a component should’t contain complex logic. If logic is still needed, it should be as simple and easily maintainable as possible, otherwise — it’s a module.</li>
</ul>
<h3>Writing Modern JavaScript without a Bundler</h3>
<p><a href="https://playfulprogramming.com/posts/modern-js-bundleless">https://playfulprogramming.com/posts/modern-js-bundleless</a></p>
<ol>
<li>Create <code>index.html</code> and denote our script tag (from our HTML file) as <code>type="module"</code>.</li>
<li>Introduce HMR via <code>browser-sync start --server \"src\" --watch</code>. The page refreshed while we modify any of the files in src.</li>
<li>Use <code>unpkg.com</code> (The CDN for everything on npm) to load libraries in our app. Remember, we need to have <code>import</code> and <code>export</code> lines, looking for files labeled something like ES6 or ESM or BROWSER.</li>
<li>Not all libraries are bundled to support ESM as a single file. If it does not, we may use <code>esbuild</code> to bundle the dependencies.</li>
<li>Leverage an <code>importmap</code> to alias the URL to be imported.</li>
</ol>
<h3>Writing CSS in 2024</h3>
<p><strong>CSS-in-JS libraries</strong> (e.g. styled-components, Emotion for React) allows you to style your components by writing CSS directly in your JavaScript code. The good part includes making styles locally-scoped by default, colocating styles with components, enabling you to reference JavaScript variables in your style rules. But CSS-in-JS adds runtime overhead, the library must "serialize" your styles into plain CSS string that can be inserted into the document. Every time the component renders, the object styles are serialized again. Btw, using CSS-in-JS with newer React features like Server Components and Streaming requires library authors to support the latest version of React.</p>
<pre><code class="lang-js">// const btnStyles = css`
//   width: 100px;
//   height: 100px;
//   color: ${red};
// `;
// 
// strings: ["width: 100px; height: 100px; color: ", ";"]
// interpolations: ["red"]
const interleave = (strings, interpolations) =&gt; {
  return strings.reduce((output, str, i) =&gt; 
    output + str + (interpolations[i] ?? ''), '');
};

const styleElement = document.createElement('style');
document.head.appendChild(styleElement);
const sheet = styleElement.sheet;

export const css = (strings, ...interpolations) =&gt; {
  const styleString = interleave(strings, interpolations).trim();
  // We use 36 as the radix here so that the output string uses the 26 alphabet characters as well.
  // e.g. css-0, css-a
  const className = `css-${sheet.cssRules.length.toString(36)}`;

  sheet.insertRule(`.${className} { ${styleString} }`, sheet.cssRules.length);
  return className;
};
</code></pre>
<p><strong>CSS Modules</strong> are a small but impactful enhancement on top of vanilla CSS. A CSS Module is a CSS file where all class names and animation names are scoped locally by default. They treat the classes defined in each file as unique. Each class name or identifier is renamed to include a unique hash, and a mapping is exported to JavaScript to allow referencing them. CSS Modules are available in almost every <a href="https://github.com/css-modules/css-modules/blob/master/docs/get-started.md">modern bundler and framework</a>.</p>
<p><strong>Tailwind</strong> uses a compiler to generate only the classes used. So while the utility CSS framework contains many possible class names, only the classes used will be included in the single, compiled CSS file. Tailwind classes are just utilities for normal CSS that adhere to a design system. You can mix and match Tailwind with CSS Modules.</p>
<blockquote><ol>
<li>Tailwind CSS is incredibly performance focused and aims to produce the smallest CSS file possible by only generating the CSS you are actually using in your project.</li>
<li>The way Tailwind scans your source code for classes is intentionally very simple — we don’t actually parse or execute any of your code in the language it’s written in, we just use regular expressions to extract every string that could possibly be a class name. (Don’t construct class names dynamically)</li>
</ol>
</blockquote>
<pre><code class="lang-js">// What `twMerge` and `clsx` solve
// `tailwind-merge` intelligently merges conflicting Tailwind classes.
// twMerge('px-2 py-1 bg-red', 'p-3 bg-[#B91C1C]');
// 
// But some developers prefer to use an object-based syntax for conditional classes
// `clsx` is generally used to construct className strings conditionally.
// clsx({ foo:true, bar:false, baz:isTrue() });
//
// Combine twMerge and clsx to a single `cn` (short for "class names") function
import { clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs))
}
</code></pre>
<p><a href="https://lightningcss.dev">Lightning CSS</a> is an extremely fast CSS parser, transformer, and minifier written in Rust. It lets you use modern CSS features and future syntax today. Features such as CSS nesting, custom media queries, high gamut color spaces, logical properties, and new selector features are automatically converted to more compatible syntax based on your browser targets. Lightning CSS is used by Vite, and soon by Tailwind and Next.js. Tools like <code>postcss</code> and <code>autoprefixer</code> are being replaced by faster, all-in-one Rust toolchains.</p>
<p>Lightning CSS can be used as a library from JavaScript or Rust, or from a standalone CLI. It can also be wrapped as a plugin in other build tools, and it is built into Parcel out of the box. For example, as a standalone CLI, it can be used to compile, minify, and bundle CSS files: <code>lightningcss --minify --bundle --targets 'defaults' input.css -o output.css</code>.</p>
<h3><code>module</code> and <code>require</code> in Node.js</h3>
<p><strong>Node.js treats each JavaScript file as a separate module and encloses the entire code within a function wrapper</strong>: <code>(function(exports, require, module, __filename, __dirname) {})</code>. The five parameters — <code>exports</code>, <code>require</code>, <code>module</code>, <code>__filename</code>, <code>__dirname</code> are available inside each module. Even if you define a global variable in a module using <code>let</code> or <code>const</code> keywords, the variables are scoped locally to the module rather than being scoped globally.</p>
<p>The <code>module</code> parameter refers to the object representing the current module and <code>exports</code> is a key of the <code>module</code> object which is also an object. <code>module.exports</code> is used for defining stuff that can be exported by a module. <code>exports</code> parameter and <code>module.exports</code> are the same unless you reassign <code>exports</code> within your module.</p>
<pre><code class="lang-js">exports.name = 'Alan';
exports.test = function () {};
console.log(module)  // { exports: { name: 'Alan', test: [Function] } }

// exports is a reference and it's no longer same as module.exports if you change the reference
exports = {
  name: 'Bob',
  add: function () {}
}
console.log(exports) // { name: 'Bob', add: [Function] }
console.log(module)  // { exports: { name: 'Alan', test: [Function] } }

module.exports = {
  name: 'Bob',
  add: function () {}
}
console.log(module)  // { exports: { name: 'Bob', add: [Function] } }
</code></pre>
<p><code>require</code> keyword refers to a function which is used to import all the constructs exported using the <code>module.exports</code> from another module. The value returned by the <code>require</code> function in module y is equal to the <code>module.exports</code> object in the module x. The require function takes in an argument which can be a name or a path. You should provide the name as an argument when you are using the third-party modules or core modules provided by NPM. On the other hand, when you have custom modules defined by you, you should provide the path of the module as the argument.</p>
<p>Modules are cached after the first time they are loaded. This means every call to <code>require('foo')</code> will get exactly the same object returned, if it would resolve to the same file.</p>
<h3>browserslist and postcss for compatibility</h3>
<p>The <a href="https://github.com/browserslist/browserslist">browserslist</a> configuration <em>(either in <code>package.json</code> or <code>.browserslistrc</code>)</em> uses <code>caniuse</code> data for queries to control the outputted JS/CSS so that the emitted code will be compatible with the browsers specified. It will be installed with webpack and used by many popular tools like autoprefixer, babel-preset-env. You can find these tools require <code>browserslist</code> in the <code>package-lock.json</code> file.</p>
<ul>
<li>There is a <code>defaults</code> query (<code>&gt; 0.5%, last 2 versions, Firefox ESR, not dead</code>), which gives a reasonable configuration for most users.</li>
<li>If you want to change the default set of browsers, we recommend combining <code>last 2 versions</code>, <code>not dead</code> with a usage number like <code>&gt; 0.2%</code>.</li>
<li><code>last 1 version or &gt; 1%</code> is equal to <code>last 1 version, &gt; 1%</code>. Each line in <code>.browserslistrc</code> file is combined with <code>or</code> combiner.</li>
<li>Display target browsers from a browserslist config: <a href="https://browsersl.ist/#q=defaults">https://browsersl.ist/#q=defaults</a></li>
<li>Run <code>npx browserslist</code> in project directory to see what browsers was selected by your queries.</li>
</ul>
<p><code>PostCSS</code> is a tool for transforming CSS with JavaScript plugins. It provides features via its extensive plugin ecosystem to help improve the CSS writing experience. Currently, PostCSS has more than 200 plugins.</p>
<ul>
<li><a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> is one of the many popular PostCSS plugins. It doesn't add polyfills, only adds prefixes.</li>
<li><a href="https://github.com/postcss/postcss-import">postcss-import</a> to transform <code>@import</code> rules by inlining content. (<code>postcss-import</code> is different than the import rule in native CSS. You should avoid the import rule in native CSS, since it can prevent stylesheets from being downloaded concurrently which affects the loading speed and performance.)</li>
<li><a href="https://www.npmjs.com/package/postcss-preset-env">postcss-preset-env</a> is a plugin that allows you to use modern CSS features while automatically adding the necessary fallbacks for older browsers, based on the specified compatibility targets. It includes <code>Autoprefixer</code> as part of its feature set. </li>
<li><a href="https://cssnano.co">cssnano</a> is a compression tool written on top of the PostCSS ecosystem to compact CSS appropriately.</li>
</ul>
<pre><code class="lang-js">// postcss.config.js
// This will take care of both vendor prefixes and polyfills
module.exports = {
  plugins: [
    require('postcss-preset-env')({
      stage: 3, // Determines which CSS features to polyfill. Default is 2
      features: {
        // https://github.com/csstools/postcss-plugins/blob/main/plugin-packs/postcss-preset-env/FEATURES.md
        'nesting-rules': true
      },
      browsers: 'last 2 versions, &gt; 1%, not ie &lt;= 8'
    })
  ]
};
</code></pre>
<pre><code class="lang-js">module.exports = {
  plugins: [
    require('autoprefixer')({
      overrideBrowserslist: ['last 2 versions', '&gt; 1%', 'not ie &lt;= 8']
    })
  ]
};
</code></pre>
<blockquote><p>PostCSS itself is a Node.js module that parses CSS into an abstract syntax tree (AST); passes that AST through any number of "plugin" functions; and then converts that AST back into a string, which you can output to a file. PostCSS plugins can do pretty much whatever they want with the parsed CSS.</p>
</blockquote>
<h3>Polyfills and Transpilers</h3>
<p>When Babel compiles your code, what it's doing is taking your syntax and running it through various syntax transforms in order to get browser compatible syntax. What it's not doing is adding any new JavaScript primitives or any properties you may need to the browser's global namespace. One way you can think about it is that when you compile your code, you're transforming it. When you add a polyfill, you're adding new functionality to the browser. For example, Babel can transform <code>arrow functions</code> into regular functions, so, they can be compiled. However, there's nothing Babel can do to transform <code>Promises</code> or <code>Math.trunc</code> into native syntax that browsers understand, so they need to be polyfilled.</p>
<p><strong>It's crucial to understand the difference between language syntax and runtime API:</strong></p>
<ul>
<li>If a browser or Babel doesn't understand a piece of syntax, you'll usually see a compile-time error, such as: <code>SyntaxError: Unexpected token 'async'</code>.</li>
<li>Runtime APIs are part of the standard library and only available if the JavaScript engine (e.g., the browser) supports them. Babel does not polyfill runtime APIs. If a browser doesn’t support it, you’ll get a runtime error.</li>
</ul>
<table>
<thead><tr>
<th>Feature</th>
<th>Type</th>
<th>Babel Transforms?</th>
<th>Error Type</th>
<th>Fix if Unsupported</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>async/await</code></td>
<td>Syntax</td>
<td>✅ Yes</td>
<td>Compile-time</td>
<td>Use <code>@babel/plugin-transform-async-to-generator</code> or <code>@babel/preset-env</code></td>
</tr>
<tr>
<td>Arrow functions</td>
<td>Syntax</td>
<td>✅ Yes</td>
<td>Compile-time</td>
<td>Babel</td>
</tr>
<tr>
<td><code>Array.prototype.includes</code></td>
<td>Runtime API</td>
<td>❌ No</td>
<td>Runtime</td>
<td>Polyfill via <code>core-js</code></td>
</tr>
<tr>
<td><code>Promise</code></td>
<td>Runtime API</td>
<td>❌ No</td>
<td>Runtime</td>
<td>Polyfill via <code>core-js</code></td>
</tr>
<tr>
<td><code>Object.assign</code></td>
<td>Runtime API</td>
<td>❌ No</td>
<td>Runtime</td>
<td>Polyfill or use lodash</td>
</tr>
</tbody>
</table>
<p>With syntax transforms, I recommend <code>@babel/preset-env</code>. For polyfills, the most popular one is <code>core-js</code>.</p>
<p><code>core-js</code> provides support for the latest ECMAScript standard and proposals, from ancient ES5 features to bleeding edge features. It is one of the main reasons why developers can use modern ECMAScript features in their development process each day for many years, but most developers just don't know that they have this possibility because of <code>core-js</code> since they use <code>core-js</code> indirectly as it's provided by their transpilers or frameworks.</p>
<p><code>core-js</code> is used by most of the popular websites. We can check it using <code>window['__core-js_shared__'].versions</code>, see details at <a href="https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md">https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md</a></p>
<h3>The current state of ES5 on the web today</h3>
<p><a href="https://philipwalton.com/articles/the-state-of-es5-on-the-web/">https://philipwalton.com/articles/the-state-of-es5-on-the-web/</a></p>
<p><strong>It turns out that most sites on the internet ship code that is transpiled to ES5, yet still doesn’t work in IE 11</strong>, which meaning the transpiler and polyfill bloat is being downloaded by 100% of their users, but benefiting none of them.</p>
<ul>
<li>89% of sites serve at least 1 JavaScript file containing untranspiled ES6+ syntax.</li>
<li>79% of sites serve at least 1 JavaScript file containing ES5 helper code.</li>
<li>68% of sites serve at least 1 JavaScript file containing both ES5 helper code as well as untranspiled ES6+ syntax in the same file.</li>
</ul>
<p>For a site to serve users code that contains both ES5 helpers and untranspiled ES6+ syntax, there’s really only two plausible explanations:</p>
<ol>
<li>The site doesn’t need to support ES5 browsers, but some of their dependencies transpile to ES5, so therefore ES5 code appears in their output.</li>
<li>The site intended to support ES5 browsers, but they didn’t realize that some of their dependencies publish untranspiled ES6+ syntax, and they didn’t configure their bundler to transpile code in <code>node_modules</code>.</li>
</ol>
<h3>Live Reload and Hot Reload</h3>
<blockquote><p>When a file is edited, the dev server recompiles with the changes, then pushes a notification to the client code in the browser. The app code can then subscribe to "some file changed" notifications, re-import the new version of the code, and swap out the old code for the new code as the app is still running.</p>
</blockquote>
<p><strong>Live Reload</strong> refreshes the entire app when a file changes. For example, if you were four links deep into your navigation and saved a change, live reloading would restart the app and load the app back to the initial route. <strong>Hot Reload</strong> only refreshes the files that were changed without losing the state of the app. (Webpack's <strong>Hot Module Replacement</strong> replaces the modules that have been modified on the fly without reloading the entire page). The advantage of this is that it doesn't lose your app state, e.g. your inputs on your form fields, your currently selected tab.</p>
<h3>Next.js app router and pages router</h3>
<p>Pages in the <code>app</code> directory are Server Components by default. This is different from the pages directory where pages are Client Components. The <code>app</code> directory uses nested folders to define routes and a special <code>page.js</code> file to make a route segment publicly accessible.</p>
<p>In app, you should use the three new hooks imported from <code>next/navigation</code>: <code>useRouter()</code>, <code>usePathname()</code>, and <code>useSearchParams()</code>.</p>
<p>In the pages directory,<code>getServerSideProps</code> is used to fetch data on the server and forward props to the default exported React component in the file. In the App Router, we can colocate our data fetching inside our React components using Server Components.</p>
<p>In the pages directory, <code>getStaticProps</code> function is used to pre-render a page at build time. In the app directory, data fetching with <code>fetch()</code> set <code>{ cache: 'force-cache' }</code>, which will cache the request data until manually invalidated. This is similar to <code>getStaticProps</code> in the pages directory.</p>
<p>In the pages directory, <code>getStaticPaths</code> function is used to define the dynamic paths that should be pre-rendered at build time. In the app directory, <code>getStaticPaths</code> is replaced with <code>generateStaticParams</code>.</p>
<blockquote><p>With Next.js 15, <code>fetch</code> requests are no longer cached by default. Next.js fetches the resource from the remote server on every request in development, but will fetch once during next build because the route will be statically prerendered. If Dynamic APIs are detected on the route, Next.js will fetch the resource on every request.</p>
</blockquote>
<h2>Set up Prettier and ESLint</h2>
<p>Install <code>Prettier</code> and <code>ESLint</code> VSCode plugins and enable <code>format on save</code> in settings (execute <code>save without formatting</code> command to disable). If you don't see the code formatted automatically on file save then it might be because you have multiple formatters installed in VS Code. Set <code>Format Document With...</code> and choose prettier to get it working.</p>
<p>Install npm packages <code>npm i -D eslint prettier</code>. ESLint only as an npm package does not provide any editor integration, only the CLI executable. Run <code>eslint --init</code> to create a <code>eslintrc.json</code> (or <code>.js</code>, <code>.yml</code>) config file after install eslint globally <code>npm i -g eslint</code> (otherwise need to run <code>./node_modules/eslint/bin/eslint.js --init</code>), pick the options as you prefer. Add <code>eslint src</code> as a lint script which can be run as <code>npm run lint</code>, and it shows eslint errors in the Problems tab. Run <code>npm run lint -- --fix</code> to fix errors (if not format on save).</p>
<p>Formatting and linting are two separate concerns. Use Prettier for code formatting concerns, and linters for code-quality concerns. Mixing the two can have negative impacts on the performance and understandability of your developer tooling.</p>
<ul>
<li><code>eslint-plugin-prettier</code> is a legacy plugin developed a long time ago. It runs Prettier as if it were an ESLint rule, applies formatting on <code>--fix</code>, and <strong>is not recommended</strong>.</li>
<li><code>eslint-config-prettier</code> is the config that turns off all formatting rules. It's recommended by Prettier to be used together with Prettier. You'd still use Prettier itself to actually do the formatting. (Add explicit <code>yarn prettier --check .</code> to CI.)</li>
</ul>
<p>If you don’t use a legacy ESLint shareable config that enables formatting rules, you probably don’t need <code>eslint-config-prettier</code>. Adding <code>eslint-config-prettier</code> at the end of the "extends" list doesn’t do anything if nothing enabled formatting rules to begin with.</p>
<p>Check out the following resources:</p>
<ol>
<li><a href="https://www.joshuakgoldberg.com/blog/you-probably-dont-need-eslint-config-prettier-or-eslint-plugin-prettier/">You Probably Don't Need eslint-config-prettier or eslint-plugin-prettier</a></li>
<li><a href="https://github.com/epicweb-dev/config">Reasonable ESLint, Prettier, and TypeScript configs</a></li>
</ol>
<h3>Lint like a senior developer by CJ</h3>
<p>Watch this: <a href="https://www.youtube.com/watch?v=Kr4VxMbF3LY">https://www.youtube.com/watch?v=Kr4VxMbF3LY</a></p>
<ol>
<li>Install <code>pnpm i -D eslint @antfu/eslint-config</code></li>
<li>Update <code>eslint.config.mjs</code> using the config from <a href="https://gist.github.com/w3cj/21b1f1b4857ecd13d076075a5c5aaf13/">https://gist.github.com/w3cj/21b1f1b4857ecd13d076075a5c5aaf13/</a></li>
<li>Try to run the script <code>"lint": "eslint ."</code> and install the required eslint plugins.</li>
<li>Copy the VS Code support (auto fix on save) settings from <a href="https://github.com/antfu/eslint-config">https://github.com/antfu/eslint-config</a> to your <code>.vscode/settings.json</code>.</li>
<li>Add a <code>"lint:fix": "eslint --fix ."</code> script and run it.</li>
</ol>
<h3>What is Husky</h3>
<p>While working on an enterprise development team, it is important that all code linting and unit tests are passing before committing code, especially if you are using some form of continuous integration. <a href="https://githooks.com">Git Hooks</a> are a built-in feature of Git that can execute automatically when certain events occur. <strong>Husky</strong>, as a project, is a very popular npm package that allows custom scripts to be ran against your repository to prevent bad <code>git commit</code> and <code>git push</code>, which makes commits of fixing lint errors doesn't happen.</p>
<p>Install husky <code>npm i -D husky</code> and have a "husky" section in the <code>package.json</code> file to add git hooks.</p>
<pre><code class="lang-json">// package.json
"husky": {
  "hooks": {
    "pre-commit": "npm run lint &amp;&amp; npm run test",
    "pre-push": "npm test"
  }
}
</code></pre>
<h2>Introducing the Backend For Frontend</h2>
<p>We had server-side functionality which we wanted to expose both via our desktop web UI, and via one or more mobile UIs. We often faced a problem in accommodating these new types of user interface, often as we already had a tight coupling between the desktop web UI and our backed services. However the nature of a mobile experience differs from a desktop web experience. In practice, our mobile devices will want to make different calls, fewer calls, and will want to display different (and probably less) data than their desktop counterparts. This means that we need to add additional functionality to our API backend to support our mobile interfaces.</p>
<p>One solution to this problem is that rather than have a general-purpose API backend, instead you have one backend per user experience - or call it a Backend For Frontend (BFF). The BFF is tightly coupled to a specific UI, and will typically be maintained by the same team as the user interface, thereby making it easier to define and adapt the API as the UI requires.</p>
<p>BFFs can be a useful pattern for architectures where there are a number of backend services, as the need to aggregate multiple downstream calls to deliver user functionality increases. In such situations it will be common for a single call in to a BFF to result in multiple downstream calls to microservices (multiple services hold the pieces of information we want).</p>
<p>The other benefit of using a BFF is that the team creating the interface can be much more fluid in thinking about where functionality lives. For example they could decide to push functionality on to the server-side to promote reuse in the future and simplify a native mobile application, or to allow for the faster release of new functionality. This decision is one that can be made by the team in isolation if they own both the mobile application and the BFF - it doesn't require any cross-team coordination.</p>
<h2>Jamstack</h2>
<p>Jamstack is a web architecture and stands for <strong>J</strong>avascript, <strong>A</strong>PIs, and <strong>M</strong>arkup stack. In this architecture, the frontend and the backend are completely separate. All interactions with the backend and third parties are done using APIs. Markup that incorporates Javascript, is pre-built into static assets, served to a client from a CDN, and relies on reusable APIs for its functionalities. <strong>A Jamstack site is a set of pre-generated static assets served from a CDN.</strong></p>
<blockquote><p>Jamstack is a way of working. It’s not a group of frameworks or services or tied to any particular brands or tech stack. Jamstack is defined by how you build websites, rather than the tools with which you choose to build them.</p>
</blockquote>
<p>Jamstack sites have better performance, are easier to secure and scale, and cost a lot less than sites built with traditional architectures (Jamstack hosting providers take care of all of this for you). Pre-building pages ensure that any errors can be detected early enough. Most importantly, Jamstack allows teams to outsource complex services to vendors who provide, maintain, and secure APIs used on their sites. The APIs can provide specific functionality to static sites like payments, authentication, search, image uploads using Paypal, Auth0, Algolia, Cloudinary.</p>
<p>The most common types of Jamstack site build tools include static site generators (SSG) and headless content management systems (CMS). <strong>Static site generators</strong> are build tools that add content to templates and produce static web pages of a site. These generators can be used for Jamstack sites. Some well-known site generators include Hugo, Gatsby, Jekyll, Next.js, etc.</p>
<p>There are two points in time that you can integrate dynamic content into a Jamsack application:</p>
<ul>
<li><strong>Build time</strong> - During the build process, a Jamstack site can call out to any number of external API services to fetch data to pre-generate static pages. You can think of it like a content cache that applies to all your site’s users.</li>
<li><strong>Run time</strong> - This should typically be content that is user specific, needs to update frequently, or is in response to a specific user action. For example, an ecommerce site may have product details populated at build time, but things like the current inventory, shipping options/prices based upon the user’s location, or the user’s shopping cart would all be populated at run time in the browser. As you may notice, in this example, the content on a single page (product details) may be a combination of both pre-rendered (build time) content (i.e. the product name, photo and description) and run time content (i.e. the product inventory and shipping options based on location).</li>
</ul>
<blockquote><p>In Next.js, <code>generateStaticParams</code> can be used in combination with dynamic route segments (e.g. <code>/posts/[id]</code>) to statically generate routes at build time. <code>generateStaticParams</code> replaces the <code>getStaticPaths</code> function in the Pages Router.</p>
<p>Note that <code>cookies</code>/<code>headers</code> is a Dynamic API whose returned values cannot be known ahead of time. Using it in a layout or page will opt a route into dynamic rendering.</p>
</blockquote>
<pre><code class="lang-js">// Generate static params for all posts at build time
export async function generateStaticParams() {
  const posts = await prisma.post.findMany({
    select: {
      id: true,
    },
  });

  return posts.map((post) =&gt; ({
    id: post.id.toString(),
  }))
}
</code></pre>
<h2>Headless UI and shadcn/ui</h2>
<p>The web platform is severely lacking in terms of UI components. There's pretty minimal by way of built-in components, and for many that do exist, they are extremely difficult to style. What's best is to get a "headless" UI library: One which handles the logic of accessible, reusable components, but leaves the styling up to you. Headless UI components separate the logic &amp; behavior of a component from its visual representation. They offer maximum visual flexibility by providing no interface.</p>
<p>People constantly have to reinvent the wheel to offer fairly basic functionality, so it’s good that there are libraries to handle the behaviour and accessibility while supporting whatever visual styles you want to make.</p>
<ul>
<li><a href="https://headlessui.com">Headless UI</a> is a good example, which contains completely unstyled, fully accessible UI components, designed to integrate beautifully with Tailwind CSS.</li>
<li><a href="https://github.com/radix-ui/primitives">Radix UI</a> is a low-level UI component library with a focus on accessibility, customization and developer experience. You can use these components either as the base layer of your design system, or adopt them incrementally. Try out: <a href="https://www.radix-ui.com/themes/playground">https://www.radix-ui.com/themes/playground</a></li>
</ul>
<p>Examples:</p>
<ol>
<li>The video <a href="https://www.youtube.com/watch?v=lY-RQjWeweo">So You Think You Can Build A Dropdown?</a> is diving deep into the complexities of designing and building a fully-accessible dropdown menu.</li>
<li><a href="https://github.com/emilkowalski/vaul">Vaul</a> is an unstyled drawer component for React that can be used as a Dialog replacement on tablet and mobile devices.</li>
</ol>
<p>Then it leaves us with the decision about how to style things. This is where <a href="https://ui.shadcn.com">shadcn/ui</a> comes into the picture. It's not a component library, but more of a code registry where you can copy/paste/modify the code to your content. It's built with Tailwind and Radix. <code>shadcn/ui</code> is a collection of reusable components that can be copied and pasted into your apps. Every component can be installed separately. It also provides a CLI that can be used to easily import components into your project, as simple as <code>npx shadcn@latest add card</code>, making it even more convenient to use.</p>
<pre><code class="lang-sh"># start at an empty directory (it will help you to create a Next.js project)
npx shadcn@latest init sidebar-01

# import components from v0
npx shadcn add "https://v0.dev/chat/xxx"

# Look for https://v0.dev/chat/xxx/json to know how it works
# https://github.com/jherr/shadcn-differ-demo/blob/main/simple.json
npx shadcn@latest init http://localhost:8080/simple.json

# Add simple-ai components (chat interface components)
# https://github.com/Alwurts/simple-ai
npx shadcn@latest add https://simple-ai.alwurts.com/registry/chat-message.json
</code></pre>
<p>To understand shadcn/ui, first we need to know what does <code>cva (class-variance-authority)</code> do. It basically is a function, that allows us to define variants for the element we want to style. A simple variant definition has a name and a list of possible values, each with a list of classes that should apply.</p>
<pre><code class="lang-jsx">// Using `cva` to handle our variant's classes
import { cva } from "class-variance-authority";

const buttonVariants = cva(["font-semibold", "border", "rounded"], {
  variants: {
    intent: {
      primary: [
        "bg-blue-500",
        "text-white",
        "border-transparent",
        "hover:bg-blue-600",
      ],
      secondary: [
        "bg-white",
        "text-gray-800",
        "border-gray-400",
        "hover:bg-gray-100",
      ],
    },
    size: {
      small: ["text-sm", "py-1", "px-2"],
      medium: ["text-base", "py-2", "px-4"],
    },
  },
  defaultVariants: {
    intent: "primary",
    size: "medium",
  },
});

buttonVariants();
// =&gt; "font-semibold border rounded bg-blue-500 text-white border-transparent hover:bg-blue-600 text-base py-2 px-4"

buttonVariants({ intent: "secondary", size: "small" });
// =&gt; "font-semibold border rounded bg-white text-gray-800 border-gray-400 hover:bg-gray-100 text-sm py-1 px-2"
</code></pre>
<p><a href="https://github.com/lukeed/clsx">clsx</a> is used in <code>cva</code>. It is a utility for constructing <code>className</code> strings conditionally.</p>
<pre><code class="lang-js">import clsx from 'clsx';

clsx('foo', true &amp;&amp; 'bar', 'baz');
//=&gt; 'foo bar baz'

clsx({ foo:true, bar:false, baz:isTrue() });
//=&gt; 'foo baz'

clsx({ foo:true }, { bar:false }, null, { '--foobar':'hello' });
//=&gt; 'foo --foobar'

clsx(['foo', 0, false, 'bar']);
//=&gt; 'foo bar'

clsx(['foo'], ['', 0, false, 'bar'], [['baz', [['hello'], 'there']]]);
//=&gt; 'foo bar baz hello there'
</code></pre>
<p>Combining <code>clsx</code> with <code>tailwind-merge</code> allows us to conditionally join Tailwind CSS classes in classNames together without style conflicts.</p>
<ul>
<li><code>clsx</code> is generally used to conditionally apply a given className.</li>
<li><code>tailwind-merge</code> overrides conflicting Tailwind CSS classes and keeps everything else untouched.</li>
</ul>
<pre><code class="lang-js">import { clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs))
}

// twMerge -&gt; condition &amp;&amp; "bg-green-500"
// clsx -&gt; { "bg-green-500": condition }
&lt;button className={cn(
  "bg-blue-500 py-2 px-4",
  className,
  {
    "bg-green-500": condition
  }
)}&gt;
</code></pre>
<h3>Design system examples</h3>
<p>A design system is an ever evolving collection of reusable components, guided by rules that ensure consistency and speed, by being the single source of truth for any product development.</p>
<ul>
<li><p>Stack Overflow's Design System: <a href="https://stackoverflow.design">https://stackoverflow.design</a></p>
</li>
<li><p>GitHub’s design system: <a href="https://primer.style">https://primer.style</a></p>
</li>
<li><p>Vercel's Design System: <a href="https://vercel.com/geist/introduction">https://vercel.com/geist/introduction</a></p>
</li>
<li><p>Shopify's Design System: <a href="https://polaris.shopify.com">https://polaris.shopify.com</a></p>
</li>
<li><p>GOV.UK Design System: <a href="https://design-system.service.gov.uk">https://design-system.service.gov.uk</a></p>
</li>
<li><p>Atlassian's Design System: <a href="https://atlassian.design">https://atlassian.design</a></p>
</li>
</ul>
<h2>Serverless</h2>
<p>Your code needs to be hosted on a server. Depending on the size of your code and the amount of users you expect to use your product, you might need many servers. Companies used to have their own facilities and warehouses that held their servers and many still do. But for many, this is not ideal. Servers can be difficult to maintain. Maintaining servers and the buildings that house them can become expensive too. That's where AWS and other <a href="https://getdeploying.com">cloud providers</a> come in.</p>
<p>Cloud is basically renting out servers and data storage that's owned by someone else (Serverless does not mean there aren't any servers; You still need servers to host and run your code.) Through the cloud provider (AWS, Azure, or Google Cloud), you gain access to resources like storage services, servers, networking, analytics, AI, and more. There are many other benefits: You pay only for what you use. You can easily spin up and use new servers when needed, allowing you to scale quickly. You can deploy applications globally.</p>
<p>Serverless is just a way of handling how you are using servers. Instead of handling all the infrastructure and server operations yourself you're relying on a cloud provider. There are different families of cloud services:</p>
<ul>
<li><strong>Infrastructure as a service (IaaS)</strong> - Amazon EC2, Digital Ocean</li>
<li><strong>Platform as a service (PaaS)</strong> - Heroku, AWS Elastic Beanstalk</li>
<li><strong>Software as a service (SaaS)</strong> - Dropbox, iCloud, Slack</li>
<li><strong>Function as a service (FaaS)</strong> - AWS Lambda</li>
</ul>
<p>Serverless functions are an approach to writing back-end code that doesn’t require writing a back-end. In the simplest terms: we write a function using our preferred language, like JavaScript; we send that function to a serverless provider; and then we can call that function just like any API using HTTP methods. These Functions are co-located with your code and part of your Git workflow. You can focus on the business needs and developing a better quality application instead of worrying about the infrastructure and maintenance of a traditional server.</p>
<p>An intro to AWS for front-end developers:</p>
<ol>
<li><em>s3</em> – This is just setting up a basic S3 bucket for web hosting static assets.</li>
<li><em>cf-s3</em> – This adds a Cloudfront distribution in front of the S3 bucket to implement edge caching of static assets.</li>
<li><em>lambda</em> – This adds a simple Lambda with function URL to handle backend calls for the site.</li>
<li><em>api-gateway</em> – This assumes you'll have a larger backend than a single function that you'd like to put behind an API Gateway with logical endpoints.</li>
<li><em>dynamodb</em> – This adds a data backend stored in DynamoDB that provides data through the Lambda to the site.</li>
</ol>
<blockquote><p>AWS provides all the necessary building blocks for the modern web. With over 200 services, AWS caters to every aspect of web application infrastructure, including compute, storage, databases, machine learning, and more. Start watching Basic Elements of AWS: <a href="https://www.proaws.dev/tutorials/basic-elements-of-aws~hk2qv">https://www.proaws.dev/tutorials/basic-elements-of-aws~hk2qv</a></p>
</blockquote>
<h3>Fully hosted and self hosting solutions</h3>
<p>In a fully hosted solution, the service provider takes care of hosting the software, managing servers, databases, scaling, and maintaining the infrastructure. Users don’t have to worry about setting up or managing the backend infrastructure. Examples: Google Workspace (formerly G Suite), Shopify, Slack.</p>
<p>In a self-hosted solution, the user is responsible for installing, configuring, and maintaining the software on their own servers or infrastructure. Users have full control over the environment. Examples: WordPress, GitLab.</p>
<h3>Netlify functions</h3>
<p>The serverless functions can be run by <a href="https://cli.netlify.com/netlify-dev">Netlify Dev</a> in the same way they would be when deployed to the cloud. Once you've configured the functions directory in your <code>netlify.toml</code>, the functions will be accessible through netlify dev server. e.g. at <code>http://localhost:8888/.netlify/functions/{function-name}</code>.</p>
<p>Go through the guide (mainly on traditional serverless functions): <a href="https://www.netlify.com/blog/intro-to-serverless-functions/">https://www.netlify.com/blog/intro-to-serverless-functions/</a></p>
<pre><code class="lang-js">// netlify/functions/hello-world.js
export const handler = async () =&gt; {
  return {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Hello world!'
    })
  }
}
</code></pre>
<pre><code class="lang-js">fetchBtn.addEventListener('click', async () =&gt; {
  const response = await fetch('/.netlify/functions/hello-world').then(
    response =&gt; response.json()
  )

  responseText.innerText = JSON.stringify(response)
})
</code></pre>
<h3>What is "edge compute"?</h3>
<p>To solve the latency problem, very smart folks came up with the idea of deploying multiple copies of a program and distributing it around the world. When a user makes a request, it can be handled by the closest copy, thus reducing the distance traveled and the time spent in transit.</p>
<ul>
<li>The <strong>Origin server</strong> refers to the main computer that stores and runs the original version of your application code.</li>
<li><strong>CDNs</strong> store static content (such as HTML and image files) in multiple locations around the world. When a new request comes in, the closest CDN location to the user can respond with the cached result.</li>
<li>Similar to CDNs, <strong>Edge servers</strong> are distributed to multiple locations around the world. But unlike CDNs, which store static content, some Edge servers can run small snippets of code. This means both caching and code execution can be done at the Edge closer to the user.</li>
</ul>
<blockquote><p>Cloud = a server, somewhere;<br/>
Edge = a server, close to you;<br/>
Edge functions = serverless functions run at the Edge;</p>
<p>Edge functions without the database in the same place aren't providing meaningful improvements. Most data is not globally replicated. So running compute in many regions, which all connect to a us-east database, made no sense.</p>
</blockquote>
<p>So what JS engines/runtimes do we have now?</p>
<ul>
<li>Three main engines: V8 (Chromium), SpiderMonkey (Firefox), JavaScriptCore (Safari)</li>
<li>Node.js, Deno, Cloudflare Workers: all run on V8</li>
<li>Bun: runs on JavascriptCore</li>
<li>Edge-computing providers: a limited JavaScript environment running on CDN Nodes</li>
</ul>
<p>For example, <a href="https://developers.cloudflare.com/workers/learning/how-workers-works">Cloudflare Workers</a> provides a serverless execution environment that allows you to create new applications without configuring or maintaining infrastructure. Under the hood, the Workers runtime uses the V8 engine. The Workers runtime also implements many of the standard APIs available in most modern browsers. Rather than running on an individual’s machine, Workers functions run on Cloudflare’s Edge Network - a growing global network of thousands of machines distributed across hundreds of locations.</p>
<p>Learn Cloudflare Workers 101</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=H7Qe96fqg1M">https://www.youtube.com/watch?v=H7Qe96fqg1M</a></li>
<li><a href="https://www.youtube.com/watch?v=QTsaAhFvX9o">https://www.youtube.com/watch?v=QTsaAhFvX9o</a></li>
</ul>
<blockquote><p><em>workerd</em> is a JavaScript / Wasm server runtime based on the same code that powers Cloudflare Workers. The name "workerd" (pronounced "worker dee") comes from the Unix tradition of naming servers with a "-d" suffix standing for "daemon". <em>A daemon is a background, non-interactive program. It is detached from the keyboard and display of any interactive user.</em> The name is not capitalized because it is a program name, which are traditionally lower-case in Unix-like environments.</p>
</blockquote>
<p><strong>Cloudflare</strong> is one of the world’s largest internet networks, designed to improve the speed and security of websites, applications, and blogs. It uses a powerful edge network to deliver content from servers closest to users, ensuring fast performance. Cloudflare also protects online properties from threats such as DDoS attacks, malicious bots, and other cyber threats. Additionally, it offers a free DNS service called 1.1.1.1, which enhances privacy by preventing user data from being tracked or used for targeted advertising.</p>
<p>Read more about The Edge:</p>
<ul>
<li><a href="https://vercel.com/docs/functions/edge-functions">Vercel Edge Functions</a> (using CloudFlare Workers under the hood)</li>
<li><a href="https://www.netlify.com/blog/edge-functions-explained">Netlify Edge Functions</a> (using Deno under the hood)</li>
<li><a href="https://nuxt.com/blog/nuxt-on-the-edge">Nuxt on the Edge</a></li>
</ul>
