<h2><a href="https://github.com/kexizeroing/kexizeroing.github.io/blob/master/src/blog/example-of-compiling-c-code-to-wasm.md">仓库源文</a>，<a href="https://kexizeroing.github.io/example-of-compiling-c-code-to-wasm">站点原文</a></h2>
<hr/>
<p>title: "An example of compiling C code to Wasm"
description: ""
added: "July 23 2023"
tags: [web]</p>
<h2>updatedDate: "Mar 9 2024"</h2>
<blockquote><p>Sometimes you want to use a library that is only available as C or C++ code. Traditionally, this is where you give up. Well, not anymore, because now we have Emscripten and WebAssembly.</p>
</blockquote>
<p>WebAssembly is a type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C# and Rust with a compilation target so that they can run on the web.</p>
<ul>
<li>The first one to writing assembly code with no architecture dependencies was <code>asm.js</code>, a strict subset of JavaScript that could be used as a low-level, efficient target language for compilers. While <code>asm.js</code> still works in browsers, it has been superseded by WebAssembly.</li>
<li>WebAssembly is statically typed, and the low-level code emitted is optimized ahead-of-time. This means that many optimizations are already done during compilation, rather than having to be performed at runtime like with JavaScript.</li>
<li>WebAssembly has two representations: textual and binary. The textual representation is based on S-expressions and commonly uses the file extension <code>.wat</code> (for WebAssembly text format). If you really wanted to, you could write it by hand. The binary format that uses the file extension <code>.wasm</code> is not meant for human consumption, let alone human creation.</li>
</ul>
<pre><code class="lang-wasm">;; add.wat
(module
  (func $add (param $lhs i32) (param $rhs i32) (result i32)
    local.get $lhs
    local.get $rhs
    i32.add)
  (export "add" (func $add))
)
</code></pre>
<p>Neither <code>.wat</code> nor <code>.wasm</code> are particularly very human-friendly. This is where a compiler like Emscripten comes into play. It lets you compile from higher-level languages like C and C++. Btw, <code>wasm-pack</code> is for Rust, which helps you build rust-generated WebAssembly packages.</p>
<p><a href="https://emscripten.org">Emscripten</a> compiles C and C++ code, or any other language that uses LLVM, into WebAssembly, and run it on the Web, Node.js, or other wasm runtimes. Emscripten provides Web support for popular portable APIs such as OpenGL, allowing complex graphical native applications to be ported, such as the Unity game engine and Google Earth.</p>
<h2>Environment setup</h2>
<p>First, let's set up the required development environment. Get the Emscripten SDK, using the instructions on their <a href="https://emscripten.org/docs/getting_started/downloads.html">website</a> or using Homebrew.</p>
<pre><code class="lang-sh"># https://formulae.brew.sh/formula/emscripten
brew install emscripten
emcc --version
emcc --help
</code></pre>
<p>There are a number of options available when compiling with Emscripten, but the main two scenarios are:</p>
<ul>
<li>Compiling to Wasm and creating HTML to run our code in, plus all the JavaScript "glue" code needed to run the Wasm in the web environment.</li>
<li>Compiling to Wasm and just creating the JavaScript.</li>
</ul>
<h2>Compiling an example</h2>
<p>Take a copy of the following simple C example, and save it in a file called <code>hello.c</code>.</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;

int main() {
  printf("Hello World\n");
  return 0;
}
</code></pre>
<p>To build the JavaScript version of this code, simply specify the C file after <code>emcc</code> command. The Emscripten Compiler Frontend (<code>emcc</code>) is used to call the Emscripten compiler from the command line. It is effectively a drop-in replacement for a standard compiler like <code>gcc</code> or <code>clang</code>.</p>
<pre><code class="lang-sh">emcc hello.c
</code></pre>
<p>You should see two files generated by that command: <code>a.out.js</code> and <code>a.out.wasm</code>. The second is a WebAssembly file containing the compiled code, and the first is a JavaScript file containing the runtime support to load and execute it. You can run them using node.js <code>node a.out.js</code>, and it prints “Hello World” to the console as expected.</p>
<pre><code class="lang-js">WebAssembly.compile(...).then(module =&gt; {
  const instance = new WebAssembly.Instance(module)
  const { add, square } = instance.exports

  console.log('2 + 4 =', add(2, 4))
  console.log('3^2 =', square(3))
  console.log('(2 + 5)^2 =', square(add(2 + 5)))
})
</code></pre>
<p>Another command can be used is <code>emcc hello.c -o hello.html</code>. This specifies that we want Emscripten to generate an HTML page to run our code, as well as the Wasm module and the JavaScript "glue" code to compile and instantiate the Wasm so it can be used in the web environment. <em>(Emscripten requires a large variety of JavaScript "glue" code to handle memory allocation, memory leaks, and a host of other problems.)</em> Now all that remains is for you to load the resulting <code>hello.html</code> in a browser that supports WebAssembly.</p>
<p>&lt;img alt="emcc example" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/ad4c5db4-c53a-424d-a509-f5228cde0a16%202.png" width="700" /&gt;</p>
<h2>Using a custom HTML template</h2>
<p>Sometimes you will want to use a custom HTML template. Search for the file <a href="https://github.com/emscripten-core/emscripten/blob/main/src/shell_minimal.html">shell_minimal.html</a> in Emscripten repo, and copy it into a subdirectory called <code>html_template</code>.</p>
<pre><code class="lang-sh">emcc -o hello2.html hello.c -O3 --shell-file html_template/shell_minimal.html
</code></pre>
<ul>
<li>We've specified <code>-o hello2.html</code>, meaning that the compiler will still output the JavaScript glue code and <code>.html</code>.</li>
<li>We've specified <code>-O3</code>, which is used to optimize the code. Emcc has optimization levels like any other C compiler, including: <code>-O0</code> (no optimization), <code>-O1</code>, <code>-O2</code>, <code>-Os</code>, <code>-Oz</code>, <code>-Og</code>, and <code>-O3</code>. <code>-O3</code> is a good setting for release builds. See more at <a href="https://emscripten.org/docs/tools_reference/emcc.html#arguments">https://emscripten.org/docs/tools_reference/emcc.html#arguments</a></li>
<li><code>--shell-file html_template/shell_minimal.html</code> provides the path to the HTML template you want to use to create the HTML you will run your example through.</li>
</ul>
<p>&lt;img alt="emcc example2" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/4n1zrr.png" width="700" /&gt;</p>
