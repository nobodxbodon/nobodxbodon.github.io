<h2><a href="https://github.com/kexizeroing/kexizeroing.github.io/blob/master/src/blog/new-to-mobx-in-react.md">仓库源文</a>，<a href="https://kexizeroing.github.io/new-to-mobx-in-react">站点原文</a></h2>
<h2>Why use MobX</h2>
<p>MobX is a simple, scalable and battle tested state management solution. You can start learning it from <a href="https://mobx.js.org/getting-started">https://mobx.js.org/getting-started</a>.</p>
<p>In large enterprise apps, state is not just a few <code>useState</code> variables, but a complex, reactive graph of data that changes from many sources. MobX’s philosophy is <em>“Anything that can be derived from state, should be derived automatically.”</em> That means no manual setState, no reducers, no boilerplate — MobX tracks dependencies automatically.</p>
<h2>Core concepts of MobX</h2>
<table>
<thead><tr>
<th>Concept</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@observable</code></td>
<td>Marks state as reactive</td>
<td><code>@observable count = 0</code></td>
</tr>
<tr>
<td><code>@computed</code></td>
<td>Derives new data from existing state</td>
<td><code>@computed get doubled() { return this.count * 2 }</code></td>
</tr>
<tr>
<td><code>@action</code></td>
<td>Modifies state in an organized way</td>
<td><code>@action increase() { this.count++ }</code></td>
</tr>
<tr>
<td><code>runInAction</code></td>
<td>Updates observable state inside async code</td>
<td><code>runInAction(() =&gt; { this.count = res.value })</code></td>
</tr>
<tr>
<td><code>@observable.ref</code></td>
<td>Tracks reference only (not deep)</td>
<td><code>@observable.ref data = someProtoMessage</code></td>
</tr>
<tr>
<td><code>observer()</code></td>
<td>Makes React component reactive</td>
<td><code>observer(() =&gt; &lt;div&gt;{store.count}&lt;/div&gt;)</code></td>
</tr>
</tbody>
</table>
<blockquote><p>@observable.ref Explained:
<code>@observable</code> deeply tracks objects and arrays. <code>@observable.ref</code> tracks only the reference, not inner fields. Use <code>@observable.ref</code> when you want MobX to react only when you replace the object entirely.</p>
</blockquote>
<p>MobX enforces that state changes must happen inside actions. When fetching async data, use <code>runInAction</code> to safely mutate observables:</p>
<pre><code class="lang-js">async fetchUser() {
  const data = await fetch("/api/user").then(res =&gt; res.json());
  runInAction(() =&gt; {
    this.user = data;
  });
}
</code></pre>
<h3>Understanding <code>autorun()</code></h3>
<p><code>autorun()</code> automatically tracks any observable values used inside its function. When one of those values changes, the function re-runs, but only if the result of the computation actually changes.</p>
<pre><code class="lang-js">const todoStore = observable({
  todos: [],
  get unfinishedCount() {
    return this.todos.filter(t =&gt; !t.done).length;
  }
});

autorun(() =&gt; {
  console.log("Unfinished todos:", todoStore.unfinishedCount);
});

todoStore.todos.push({ task: "read docs", done: false }); // logs → Unfinished todos: 1
todoStore.todos[0].done = true;                           // logs → Unfinished todos: 0
todoStore.todos[0].task = "rename task";                  // no log — count didn’t change

// Another example with observable nested objects
const user = observable({
  profile: { name: "Alice", age: 20 }
});

autorun(() =&gt; {
  console.log("User name:", user.profile.name);
});

user.profile.name = "Bob";  // logs → User name: Bob
user.profile.age = 21;      // no log — name didn’t change
</code></pre>
<p>This behavior is the foundation of MobX’s reactivity system. It’s dependency-aware, meaning it only re-executes if the specific values used inside the function actually change. The <code>observer()</code> function in React is built on this exact idea, you can think of each reactive component as its own <code>autorun</code>, which re-renders only when the data it reads during rendering changes.</p>
<h2>Use MobX in React</h2>
<p>Let’s write an example using decorators syntax, which is cleaner and more common in large MobX apps.</p>
<pre><code class="lang-js">import { makeObservable, observable, action, computed } from "mobx";
import { observer } from "mobx-react-lite";
import React from "react";

class CounterStore {
  @observable.ref count = 0;

  constructor() {
    makeObservable(this);
  }

  @action increase() {
    this.count++;
  }

  @action decrease() {
    this.count--;
  }

  @computed get doubled() {
    return this.count * 2;
  }
}

const store = new CounterStore();

const Counter = observer(({ store }: { store: CounterStore }) =&gt; (
  &lt;div&gt;
    &lt;p&gt;Count: {store.count}&lt;/p&gt;
    &lt;p&gt;Double: {store.doubled}&lt;/p&gt;
    &lt;button onClick={() =&gt; store.decrease()}&gt;-&lt;/button&gt;
    &lt;button onClick={() =&gt; store.increase()}&gt;+&lt;/button&gt;
  &lt;/div&gt;
));

export default function App() {
  return &lt;Counter store={store} /&gt;;
}
</code></pre>
<p>The <code>observer()</code> function from <code>mobx-react-lite</code> is what makes your React component reactive. Under the hood, this higher-order component (HoC) works similarly to MobX’s <code>autorun</code>: it automatically tracks all observable values accessed during rendering. When any of those observables change, MobX knows exactly which components depend on them and re-renders only those components. This makes MobX both magical and efficient — you don’t need to manually connect state or trigger updates; components simply re-render whenever the data they rely on changes.</p>
<h2>Why shift away from MobX</h2>
<p>MobX automatically tracks dependencies, but this implicitness can sometimes make data flow harder to trace. In contrast, libraries like Redux or Zustand make updates more explicit — you call something like <code>dispatch({ type: "INCREMENT" })</code> or <code>set(state =&gt; ({ count: state.count + 1 }))</code>, so every state change is intentional and easy to follow in debugging or devtools.</p>
<p>Modern React (since Hooks) encourages functions over classes, local state, and custom hooks. MobX’s most elegant syntax (<code>@observable</code>, <code>@action</code>, <code>@computed</code>) was designed for class-based stores with decorators. Although MobX supports hooks and <code>makeAutoObservable</code>, it still feels slightly more old-school compared to libraries that embrace functional patterns from the start (like Zustand).</p>
<blockquote><p>Decorators need Babel or TypeScript configuration, which can feel verbose. <code>makeAutoObservable</code> is a modern way to make things reactive. When you call <code>makeAutoObservable(this)</code>, it walks through your class instance, detects properties, getters, and methods, and automatically applies the right MobX annotations internally.</p>
</blockquote>
<p>MobX is still actively maintained, but community focus has shifted. For most modern React apps, developers often reach for simpler, more function-first solutions like Zustand, Jotai, or Redux Toolkit that align better with React’s hook-based patterns and predictable data flow.</p>
