<h2>原文：<a href="https://kexizeroing.github.io/using-es-modules">Using ES modules</a></h2>
<hr/>
<p>layout: "../layouts/BlogPost.astro"
title: "Using ES modules"
slug: using-es-modules
description: ""
added: "Aug 12 2020"
tags: [js]</p>
<h2>updatedDate: "Apr 02 2023"</h2>
<h2>ES Modules</h2>
<p>While Node.js has been using the CommonJS standard for years and there are a number of JavaScript libraries and frameworks that enable module usage, the browser never had a module system. A module system must be first standardized by ECMAScript and then implemented by the browser. The good news is that modern browsers have started to support module functionality natively, and the use of native JavaScript modules is dependent on the <em>import</em> and <em>export</em> statements. <strong>The import and export statements cannot be used in embedded scripts unless such script has a <code>type="module"</code></strong>.</p>
<h3>Exporting module features</h3>
<p>The first thing you need to do to get access to module features is export them. This is done using the <code>export</code> statement. The easiest way to use it is to place it in front of any items you want exported out of the module. A more convenient way of exporting all the items is to use a single <code>export</code> statement at the end of your module file, followed by a comma-separated list of the features you want to export wrapped in curly braces. You can <strong>export functions, var, let, const, and classes</strong>. They need to be top-level items; you can't use export inside a function.</p>
<pre><code class="lang-javascript">export const name = 'square';

export function draw(ctx, length, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, length, length);
}

export class Square {}

export { name, draw, reportArea, reportPerimeter };
</code></pre>
<h3>Importing features into script</h3>
<p>Once you've exported some features out of your module, you need to import them into your script to be able to use them. Use the <code>import</code> statement, followed by a comma-separated list of the features you want to import <strong>wrapped in curly braces</strong>, followed by the keyword <code>from</code>, followed by the path to the module file. Once you've imported the features into your script, you can use them just like they were defined inside the same file.</p>
<pre><code class="lang-javascript">import { name, draw, reportArea, reportPerimeter } from './modules/square.js';

import { Square } from './modules/square.js';
</code></pre>
<pre><code class="lang-javascript">// ** imports are references, not values **

// module.js
export let thing = 'initial';

setTimeout(() =&gt; {
  thing = 'changed';
}, 500);

// main.js
import { thing as importedThing } from './module.js';
// ESM imports are asynchronous, which also allows for top-level await
const module = await import('./module.js');
let { thing } = await import('./module.js');

setTimeout(() =&gt; {
  console.log(importedThing); // "changed"
  console.log(module.thing); // "changed"
  console.log(thing); // "initial"
}, 1000);
</code></pre>
<h3>Default exports and renaming</h3>
<p>The other type of export called the default export — this is designed to make it easy to have a default function provided by a module. Note that <strong>the lack of curly braces both in export and import statements</strong>. This is because there is only one default export allowed per module. <strong>A default export can be imported with any name</strong>.</p>
<pre><code class="lang-javascript">export default myDefault;
// export anonymous function
export default function() {}

import myDefault from './modules/square.js';
// the above line is shorthand for
import { default as myDefault } from './modules/square.js';

// import the default export and non-default export by name
import React, { Component } from 'react'
</code></pre>
<p>Inside the <code>import</code> and <code>export</code> statement's curly braces, you can use the keyword <code>as</code> along with a new feature name, to change the identifying name you will use inside the module. It arguably makes more sense to leave your module code alone, and make the changes in the imports. This especially makes sense when you are importing from third party modules that you don't have any control over.</p>
<pre><code class="lang-javascript">// inside module.js
export {
  function1 as newFunctionName,
  function2 as anotherNewFunctionName
};

// inside main.js
import { newFunctionName, anotherNewFunctionName } from './modules/module.js';

// inside module.js
export { function1, function2 };

// inside main.js
import { function1 as newFunctionName, function2 as anotherNewFunctionName } from './modules/module.js';

// import as members of an object Module
import * as Square from './modules/square.js';

Square.draw();
Square.reportArea();
</code></pre>
<h3>Applying the module to HTML</h3>
<p>Now we just need to apply the JavaScript module to our HTML page. This is very similar to how we apply a regular script to a page. You need to <strong>include <code>type="module"</code> in the <code>&lt;script&gt;</code> element to declare this script as a module</strong>. You can only use <code>import</code> and <code>export</code> statements inside modules; not regular scripts. Note that <strong>modules use strict mode automatically</strong>. JavaScript module scripts are <strong>deferred by default</strong> (<code>&lt;script defer&gt;</code>). This means the download for the module can happen in parallel with HTML parsing and the execuation is after the DOM is loaded.</p>
<p>If a browser does not support modules, we need to use a combination of <code>type="module"</code> and <code>nomodule</code> attribute.</p>
<ul>
<li>In modern browsers that support module scripts, the script element with the <code>nomodule</code> attribute will be ignored, and the script element with a type of <code>module</code> will be fetched and evaluated as a module script. </li>
<li>Older browser will ignore the script element with a type of <code>module</code>, as that is an unknown script type for them, but they will have no problem fetching and evaluating the other script as a classic script, ignoring the <code>nomodule</code> attribute.</li>
</ul>
<pre><code class="lang-html">&lt;script type="module" src="main.js"&gt;&lt;/script&gt;
&lt;script nomodule src="fallback.js"&gt;&lt;/script&gt;
</code></pre>
<h3>Dynamic module loading</h3>
<p>This allows you to dynamically load modules only when they are needed, rather than having to load everything up front. You can call <code>import()</code> as a function, passing it the path to the module as a parameter. <strong>It returns a promise</strong>, which fulfills with a module object giving you access to that object's exports.</p>
<pre><code class="lang-javascript">import('./modules/square.js').then((Module) =&gt; {
  let square1 = new Module.Square();  // access member in module object
  square1.draw();
  square1.reportArea();
})
</code></pre>
<h3>Import maps</h3>
<p>In common module systems, such as CommonJS, or a module bundler like webpack, the import specifier was mapped to a specific file, and users only needed to apply the bare module specifier (usually the package name) in the import statement, and concerns around module resolution were taken care of automatically.</p>
<p>Now many web developers are using JavaScript's native module syntax, but combining it with bare import specifiers, making their code unable to run on the web without per-application, ahead-of-time modification. We'd like to solve that, and bring these benefits to the web.</p>
<p><a href="https://github.com/WICG/import-maps">This proposal</a> allows control over what URLs get fetched by JavaScript <code>import</code> statements. This allows "bare import specifiers", such as <code>import moment from "moment"</code>, to work. The mechanism for doing this is via an <em>import map</em> which can be used to control the resolution of module specifiers generally.</p>
<p>Today, <code>import moment from "moment"</code> throws, as such bare specifiers are reserved <em>(specifier needs to start with the character <code>/</code>, <code>./</code>, <code>../</code>)</em>. By supplying the browser with the following import map, the above would act as if you had written <code>import moment from "/node_modules/moment/src/moment.js"</code>.</p>
<pre><code class="lang-html">&lt;script type="importmap"&gt;
{
  "imports": {
    "moment": "/node_modules/moment/src/moment.js",
  }
}
&lt;/script&gt;
</code></pre>
<p><em>Update at 2023-03-28:</em> <a href="https://web.dev/import-maps-in-all-modern-browsers">JavaScript import maps are now supported cross-browser</a>. A modern way to use ES modules is with the <code>&lt;script type="importmap"&gt;</code> tag. This tag allows you to define a mapping of external module names to their corresponding URLs, which makes it easier to include and use external modules in your code.</p>
<h2>Getting started with Node.js ESM</h2>
<p>In May, 2020, Node.js v12.17.0 made ESM support available to all Node.js applications without experimental flags. Read more at <a href="https://formidable.com/blog/2021/node-esm-and-exports">https://formidable.com/blog/2021/node-esm-and-exports</a></p>
<p>The <code>package.json</code> file contains a field <code>"type": "module"</code> (defaults to CommonJS when not set). This will make Node.js interpret all files in the package as ESM files. When migrating to <code>mjs</code>, change the <code>module.exports</code> to the ESM <code>export</code> statement and all the <code>require</code> to the respective <code>import</code> statements.</p>
<blockquote><p>CJS is the default; you have to opt-in to ESM mode. You can opt-in to ESM mode by renaming your script from <code>.js</code> to <code>.mjs</code>. Alternately, you can set <code>"type": "module"</code> in package.json, and then you can opt-out of ESM by renaming scripts from <code>.js</code> to <code>.cjs</code>.</p>
</blockquote>
<h3>ESM and CJS are completely different</h3>
<p>Since the dawn of Node, Node modules were written as CommonJS modules. We use <code>require()</code> to import them. When implementing a module for other people to use, we can define <code>exports</code>, either "named exports" by setting <code>module.exports.foo = 'bar'</code> or a "default export" by setting <code>module.exports = 'baz'</code>.</p>
<p>ESM changes a bunch of stuff in JavaScript. Switching the default from CJS to ESM would be a big break in backwards compatibility. Three guidelines for library authors to follow if they need to support CJS and ESM:</p>
<ol>
<li><p>Provide a CJS version of your library. This ensures that your library can work in older versions of Node. <em>ESM scripts can import CJS scripts, but only by using the "default import” syntax <code>import _ from 'lodash'</code>, not the "named import" syntax <code>import { shuffle } from 'lodash'</code>.</em></p>
</li>
<li><p>Provide a thin ESM wrapper for your CJS named exports. It’s easy to write an ESM wrapper for CJS libraries, but it’s not possible to write a CJS wrapper for ESM libraries.</p>
<pre><code class="lang-js">// esm/wrapper.js
import cjsModule from '../index.js';
export const foo = cjsModule.foo;
</code></pre>
</li>
<li><p>Add an <code>exports</code> map to your <code>package.json</code>. Be aware that adding an <code>exports</code> map is always a "semver major" breaking change. By default, your users can reach into your package and <code>require()</code> any script they want, even files that you intended to be internal. The <code>exports</code> map ensures that users can only require/import the entry points that you deliberately expose.</p>
<pre><code class="lang-json">"exports": {
   "require": "./index.js",
   "import": "./esm/wrapper.js"
}
</code></pre>
</li>
</ol>
