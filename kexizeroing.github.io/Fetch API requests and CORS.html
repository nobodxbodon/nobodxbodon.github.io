<h2>原文：<a href="https://kexizeroing.github.io/fetch-api-requests-cors">Fetch API requests and CORS</a></h2>
<hr/>
<h2>layout: "../layouts/BlogPost.astro"
title: "Fetch API requests and CORS"
slug: fetch-api-requests-and-cors
description: ""
added: "Aug 9 2020"
tags: [js, web]
updatedDate: "Jan 13 2024"</h2>
<h2>Fetch API</h2>
<p>Fetch method allows you to make network requests similar to <code>XMLHttpRequest</code>. The main difference is that the Fetch API uses <code>Promise</code>, which enables a simpler and cleaner API, avoiding callback hell and having to remember the complex API of XHR.</p>
<p>The <code>fetch()</code> method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise that resolves to the Response to that request even if the server response is an HTTP error status. Once a Response is retrieved, there are a number of methods available to define what the body content is and how it should be handled.</p>
<blockquote>
<p>At the heart of Fetch are the Interface abstractions of HTTP <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">Request</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Headers">Headers</a>, along with a <code>fetch()</code> method for initiating asynchronous resource requests.</p>
</blockquote>
<ul>
<li>The Promise returned from <code>fetch()</code> <strong>won’t reject on HTTP error status even if the response is an HTTP 404 or 500</strong>. Instead, it will resolve normally and only reject on network failure or if anything prevented the request from completing. So a <code>then()</code> handler must check the <code>Response.ok</code> or <code>Response.status</code> properties.</li>
<li><code>fetch()</code> won’t send cookies, unless you set the credentials in init option. To cause browsers to send credentials in a cross-origin call, add <code>credentials: 'include'</code>.</li>
<li>CORS mode is enabled by default in <code>fetch()</code>.</li>
</ul>
<h3>Init options</h3>
<ul>
<li><strong>method</strong>: e.g., GET, POST. Note that the <code>Origin</code> header is not set on Fetch requests with a method of HEAD or GET. (GET is default)</li>
<li><strong>headers</strong>: Any headers you want to add to your request, contained within a <code>Headers</code> object or an object literal.</li>
<li><strong>body</strong>: Any body that you want to add to your request. Note that a request using the GET or HEAD method cannot have a body.</li>
<li><strong>mode</strong>: The mode you want to use for the request, e.g., <code>cors</code>, <code>no-cors</code>, or <code>same-origin</code>. (<code>cors</code> is default)</li>
<li><strong>credentials</strong>: The request credentials you want to use for the request, e.g., <code>omit</code>, <code>same-origin</code>, or <code>include</code>. To automatically send cookies for the current domain, this option must be provided. (<code>same-origin</code> is default)</li>
</ul>
<pre><code class="language-javascript">async function postData(url = '', data = {}) {
  const response = await fetch(url, {
    method: 'POST',
    cache: 'no-cache',
    credentials: 'same-origin',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  });

  return response.json();
}

postData('https://example.com/answer', { answer: 42 })
  .then(data =&gt; {
    console.log(data);
  });
</code></pre>
<pre><code class="language-javascript">// Checking if the fetch is successful
fetch('flowers.jpg')
  .then(response =&gt; {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.blob();
  })
  .then(myBlob =&gt; {
    myImage.src = URL.createObjectURL(myBlob);
  })
  .catch(error =&gt; {
    console.error('There has been a problem with your fetch operation:', error);
  });
</code></pre>
<pre><code class="language-javascript">// Uploading a file
const formData = new FormData();
const fileField = document.querySelector('input[type="file"]');

formData.append('username', 'abc123');
formData.append('avatar', fileField.files[0]);

fetch('https://example.com/profile/avatar', {
  method: 'PUT',
  body: formData  // this automatically sets the "Content-Type" header to `multipart/form-data`
})
  .then(response =&gt; response.json())
  .then(result =&gt; {
    console.log('Success:', result);
  })
  .catch(error =&gt; {
    console.error('Error:', error);
  });
</code></pre>
<pre><code class="language-javascript">// URLSearchParams as a fetch body
async function isPositive(value) {
  const response = await fetch(`http://text-processing.com/api/sentiment/`, {
    method: 'POST',
    // this automatically sets the "Content-Type" header to `application/x-www-form-urlencoded`
    body: new URLSearchParams({ text: value }) 
  });
  const json = await response.json();
  return json.label === 'pos';
}
</code></pre>
<h3>Abort API</h3>
<p>When the Fetch API was initially introduced, there was no way to set a timeout at all. Browsers have recently added support for the <code>Abort API</code> to support timeouts.</p>
<pre><code class="language-js">const controller = new AbortController();
const signal = controller.signal;

const url = "video.mp4";
const downloadBtn = document.querySelector(".download");
const abortBtn = document.querySelector(".abort");

downloadBtn.addEventListener("click", fetchVideo);

abortBtn.addEventListener("click", () =&gt; {
  controller.abort();
});

function fetchVideo() {
  fetch(url, { signal })
    .then((response) =&gt; {
      console.log("Download complete", response);
    })
    .catch((err) =&gt; {
      console.error(`Download error: ${err.message}`);
    });
}
</code></pre>
<h3>Build on Fetch</h3>
<ul>
<li><a href="https://github.com/elbywan/wretch">wretch</a> is a tiny wrapper built around fetch.</li>
<li>Axios is great <em>(Axios is based on XMLHttpRequests)</em>, but a bit large on kb compared to wretch. <a href="https://github.com/developit/redaxios">Redaxios</a> is a great small alternative to axios.</li>
<li><a href="https://github.com/sindresorhus/ky">Ky</a> is a tiny and elegant HTTP client based on the browser Fetch API.</li>
</ul>
<h2>POST Requests</h2>
<p>The HTTP POST method sends data to the server. The type of the body of the request is indicated by the <code>Content-Type</code> header.</p>
<p>When using cURL, <code>-d</code> means transfer payload, <code>-H</code> is the header info included in requests, <code>GET</code> is the default one, use <code>-X</code> to support other HTTP verbs.</p>
<pre><code class="language-bash"># application/x-www-form-urlencoded
curl -d "param1=value1&amp;param2=value2" -H "Content-Type: application/x-www-form-urlencoded" -X POST http://localhost:3000/data
# in nodeJs, `req.body` is a string, and use `&amp;` to split the string to get parameters 

# application/json
curl -d '{"key1":"value1", "key2":"value2"}' -H "Content-Type: application/json" -X POST http://localhost:3000/data
# in nodeJs, use `JSON.parse(req.body)` to get parameters 
</code></pre>
<blockquote>
<p>More options for curl, check <code>open x-man-page://curl</code></p>
<ul>
<li><strong>-I, --head</strong>: Fetch the headers only. When used on an FTP or FILE, displays the file size and last modification time only.</li>
<li><strong>-i, --include</strong>: Include the HTTP response headers in the output.</li>
<li><strong>-v, --verbose</strong>: Makes curl verbose during the operation. Useful for seeing what's going on under the hood. Try <code>curl -vI https://www.baidu.com</code> as an exmple.</li>
<li><strong>-o, --output &lt;file&gt;</strong>: Write to file instead of stdout.</li>
</ul>
</blockquote>
<p>A POST request is typically sent via an HTML form. In this case, the content type is selected by the string in the <strong><code>enctype</code> attribute</strong> of the <code>form</code> element.</p>
<ul>
<li><strong>application/x-www-form-urlencoded</strong>: the keys and values are encoded in key-value tuples separated by <code>'&amp;'</code>, with a <code>'='</code> between the key and the value. Non-alphanumeric characters in both keys and values are percent encoded. (default type)</li>
<li><strong>multipart/form-data</strong>: each value is sent as a block of data ("body part"), with a user agent defined delimiter ("boundary") separating each part. The keys are given in the <code>Content-Disposition</code> header of each part.</li>
<li><strong>text/plain</strong></li>
</ul>
<p>Use <code>multipart/form-data</code> when your form includes any <code>&lt;input type="file"&gt;</code> elements. <strong>Characters are NOT encoded</strong> (No encoding means you save a lot of CPU cycles and keeps the total body size small). This is important when the form has a file upload control. You want to send the file binary and this ensures that bitstream is not altered.</p>
<ul>
<li>Fields are separated by the given boundary string. The browser must choose a boundary that will not appear in any of the fields, so this is why the boundary may vary between requests.</li>
<li>Every field gets some sub headers before its data: <code>Content-Disposition: form-data</code>, the field name, the filename, followed by the data.</li>
</ul>
<p>&lt;img alt="form-data" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/008vxvgGly1h7pzihd80yj31440gy40l.jpg" width="700"&gt;</p>
<h3>Process the form data</h3>
<ol>
<li><p>What does <code>body-parser</code> do with express? Originally, there was only <code>body-parser</code>, not <code>express.json()</code>. <code>body-parser</code> extracts the entire body portion of an incoming request stream and exposes it on <code>req.body</code>. As of Express version 4.16+, their own <code>body-parser</code> implementation is now included in the default Express package so there is no need for you to download another dependency.</p>
<pre><code class="language-js">app.use(express.json());
// Parsing the URL-encoded data with the `querystring` library (when false) or the `qs` library (when true).
// To be simple,`querystring` cannot parse nested object.
app.use(express.urlencoded({ extended: false }));
</code></pre>
</li>
<li><p>However, <code>body-parser</code> does not handle multipart bodies. <a href="https://github.com/expressjs/multer">Multer</a> is a Node.js middleware for handling <code>multipart/form-data</code>, which is primarily used for uploading files.</p>
<pre><code class="language-js">const express = require('express')
const multer  = require('multer')
// where to upload the files. In case you omit the options object, the files will be kept in memory and never written to disk.
const upload = multer({ dest: 'uploads/' })

const app = express()

app.post('/profile', upload.single('avatar'), function (req, res, next) {
  // req.file is the `avatar` file, which is the file you uploaded
  console.log(req.file)
})
</code></pre>
</li>
</ol>
<h3>POST and PUT</h3>
<p>The difference between <code>PUT</code> and <code>POST</code> is that <code>PUT</code> is idempotent <em>(If you PUT an object twice, it has no effect)</em>. <code>PUT</code> implies putting a resource - completely replacing whatever is available at the given URL with a different thing. Do it as many times as you like, and the result is the same. You can PUT a resource whether it previously exists, or not. So consider like this: do you name your URL objects you create explicitly, or let the server decide? If you name them then use <code>PUT</code>. If you let the server decide then use <code>POST</code>.</p>
<h3>POST and GET</h3>
<p>GET data is appended to the URL as a query string, so there is a hard limit to the amount of data you can transfer. <em>GET is idempotent</em>. POST data is included in the body of the HTTP request and isn't visible in the URL. As such, there's no limit to the amount of data you can transfer over POST.</p>
<p>Responses to the POST method aren’t kept by most caches; if you send information in the path or query via GET, caches can store that information for the future.</p>
<p>&lt;img alt="http-post-get" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/post-get-others.png" width="460"&gt;</p>
<p>As far as security, <strong>POST method is not more secure than GET as it also gets sent unencrypted over network</strong>. HTTPS encrypts the data in transit and the remote server will decrypt it upon receipt; it protects against any 3rd parties in the middle being able to read or manipulate the data. A packet sniffer will show that the HTTP message sent over SSL is encrypted on the wire.</p>
<blockquote>
<p>Should data in an HTTPS request appear as encrypted in Chrome developer tools? The browser is obviously going to know what data it is sending, and the Chrome developer tools wouldn't be very helpful if they just showed the encrypted data. These tools are located in the network stack before the data gets encrypted and sent to the server.</p>
</blockquote>
<p>JSONP doesn't support other methods than GET and also doesn't support custom headers. It basically use a script tag (the domain limitation is ignored) and pass a special parameter that tells the server a little bit about your page. Then the server is able to wrap up its response in a way that your page can handle.</p>
<h3>HEAD and GET</h3>
<p>HEAD requests are just like GET requests, except the body of the response is empty. For example, if a URL might produce a large download, a HEAD request could read its <code>Content-Length</code> header to check the file size without actually downloading it. This kind of request can be used when you want to determine if the content has changed at all - a change in the last modified time or content length usually signifies this. HEAD is also the easiest way to determine if a site is up or down.</p>
<pre><code class="language-js">// Test if a file exists without downloading the entire thing
const { ok } = await fetch('https://xx.com/foo.jpg', { method: 'HEAD' })
console.log(ok)  // true or false
</code></pre>
<h2>Headers</h2>
<p>The Headers interface allows you to create your own headers object via the <code>Headers()</code> constructor. A Headers object has an associated header list, and you can add to this using methods like <code>append()</code>. For security reasons, <strong>some headers can only be controlled by the user agent</strong>. These headers cannot be modified programmatically, like <code>Accept-Charset</code>, <code>Accept-Encoding</code>, <code>Access-Control-Request-Headers</code>, <code>Access-Control-Request-Method</code>, <code>Cookie</code>, <code>Date</code>, <code>Host</code>, <code>Origin</code>. All of the Headers methods throw a <code>TypeError</code> if a header name is used that is not a valid HTTP Header name.</p>
<pre><code class="language-javascript">const content = 'Hello World';

// add a new header using append()
const myHeaders = new Headers();
myHeaders.append('Content-Type', 'text/plain');
myHeaders.append('Content-Length', content.length.toString());
myHeaders.append('X-Custom-Header', 'ProcessThisImmediately');

// passing an object literal to the constructor
const myHeaders = new Headers({
  'Content-Type': 'text/plain',
  'Content-Length': content.length.toString(),
  'X-Custom-Header': 'ProcessThisImmediately'
});

console.log(myHeaders.has('Content-Type')); // true
console.log(myHeaders.has('Set-Cookie'));   // false

myHeaders.append('X-Custom-Header', 'AnotherValue');
console.log(myHeaders.get('X-Custom-Header')); // ['ProcessThisImmediately', 'AnotherValue']

myHeaders.delete('X-Custom-Header');
console.log(myHeaders.get('X-Custom-Header')); // null
</code></pre>
<p>A fetch metadata request header like <code>Sec-Fetch-Dest</code>, <code>Sec-Fetch-Mode</code>, <code>Sec-Fetch-Site</code> provides additional information about the context from which the request originated. These headers are prefixed with <code>Sec-</code>, and hence have <a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name">forbidden header names</a>. As such, they cannot be modified from JavaScript.</p>
<ul>
<li><code>Sec-Fetch-Mode</code> allows a server to distinguish between: requests originating from a user navigating between HTML pages, and requests to load images and other resources. For example, this header would contain <code>navigate</code> for top level navigation requests, while <code>no-cors</code> is used for loading an image.</li>
<li><code>Sec-Fetch-Site</code> tells a server whether a request for a resource is coming from the same origin, the same site, a different site, or is a "user initiated" request.</li>
</ul>
<h2>Response</h2>
<p>You can create a new Response object using the <code>Response()</code> constructor, but you are more likely to encounter a Response object being returned as the result of another API.</p>
<ul>
<li><strong>Response.headers</strong>: The Headers object associated with the response.</li>
<li><strong>Response.ok</strong>: A boolean indicating whether the response was successful (status in the range 200–299) or not.</li>
<li><strong>Response.status</strong>: The status code of the response.</li>
<li><strong>Response.statusText</strong>: The status message corresponding to the status code. (e.g., OK for 200).</li>
<li><strong>Response.url</strong>: The URL of the response. It will be the final URL obtained after any redirects.</li>
</ul>
<p>The body of Response allows you to declare what its content type is and how it should be handled (<code>.json()</code>, <code>.blob()</code>, <code>.arrayBuffer()</code>, <code>.formData()</code>, <code>.text()</code>). For example, The <code>json()</code> method of the Response interface takes a Response stream and reads it to completion. It returns a promise which resolves with the result of parsing the body text as JSON.</p>
<blockquote>
<p><code>Response.body</code> is a <code>ReadableStream</code> of the body contents. <a href="https://mdn.github.io/dom-examples/streams/simple-pump/">In this example</a> we fetch an image, expose the response's stream using <code>response.body</code>, create a reader using <code>ReadableStream.getReader()</code>, then enqueue that stream's chunks into a second, custom readable stream — effectively creating an identical copy of the image.</p>
</blockquote>
<p>&lt;img alt="readable-stream" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/readable-stream.png" width="700"&gt;</p>
<pre><code class="language-js">// An example to fetch image with progress indicator
// https://github.com/AnthumChris/fetch-progress-indicators

const elProgress = document.getElementById('progress');

fetch('https://fetch-progress.anthum.com/30kbps/images/sunrise-baseline.jpg')
.then(response =&gt; {
  const contentEncoding = response.headers.get('content-encoding');
  const contentLength = response.headers.get(contentEncoding ? 'x-file-size' : 'content-length');
  if (contentLength === null) {
    throw Error('Response size header unavailable');
  }

  const total = parseInt(contentLength, 10);
  let loaded = 0;

  return new Response(
    new ReadableStream({
      // This method is called immediately when the object is constructed
      start(controller) {
        const reader = response.body.getReader();

        read();
        function read() {
          reader.read().then(({ done, value }) =&gt; {
            if (done) {
              controller.close();
              return; 
            }
            loaded += value.byteLength;
            elProgress.innerHTML = Math.round(loaded / total * 100) + '%';
            controller.enqueue(value);
            read();
          }).catch(error =&gt; {
            console.error(error);               
          })
        }
      }
    })
  );
})
.then(response =&gt; response.blob())
.then(data =&gt; {
  document.getElementById('img').src = URL.createObjectURL(data);
})
</code></pre>
<h2>Cross-Origin Resource Sharing</h2>
<p>A web application executes a cross-origin HTTP request when it requests a resource that has a different origin (domain, protocol, or port) from its own. For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. XMLHttpRequest and the Fetch API follow the same-origin policy, which means that a web application using those APIs can only request resources from the same origin unless the response from other origins includes the right CORS headers.</p>
<p>CORS works by adding new HTTP headers that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods other than <code>GET</code>, or <code>POST</code> with certain MIME types, the specification mandates that browsers <strong>"preflight"</strong> the request, soliciting supported methods from the server with the HTTP <code>OPTIONS</code> request method, and then, upon "approval" from the server, sending the actual request. Servers can also inform clients whether "credentials" (such as Cookies and HTTP Authentication) should be sent with requests.</p>
<blockquote>
<p>If Site A requests a page from Site B, the browser will actually fetch the requested page on the network level and check if the response headers list Site A as a permitted requester domain.</p>
</blockquote>
<p>&lt;br&gt;
&lt;img alt="same-cross-origin" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/same-cross-origin.png" width="700"&gt;</p>
<p>&lt;br&gt;
&lt;img alt="same-cross-site" src="https://raw.gitmirror.com/kexiZeroing/blog-images/main/same-site.png" width="700"&gt;</p>
<h3>Simple requests</h3>
<p>Simple requests don’t trigger a CORS preflight. It should meet all the following conditions:</p>
<ul>
<li>One of the allowed methods: <code>GET</code>, <code>HEAD</code>, <code>POST</code></li>
<li>Apart from the headers automatically set by the user agent, the only headers which are allowed are those defined as a “CORS-safelisted request-header”, which are: <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code>, <code>Content-Type</code>, etc.</li>
<li>The only allowed values for the <code>Content-Type</code> header are: <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>text/plain</code></li>
</ul>
<p>To allow the simple requests to access the resource, the <code>Access-Control-Allow-Origin</code> header should contain the value that was sent in the request's <code>Origin</code> header.</p>
<p>The <code>Origin</code> request header indicates the origin (scheme, hostname, and port) that caused the request. It is similar to the <code>Referer</code> header, but does not disclose the path, and may be null. Broadly speaking, <strong>user agents add the <code>Origin</code> request header to cross origin requests or same-origin requests except for GET or HEAD requests</strong>.</p>
<h3>Preflight requests</h3>
<p>Preflight requests first send an HTTP request by the <code>OPTIONS</code> method to the resource on the other domain, to determine if the actual request is safe to send. <code>OPTIONS</code> is an HTTP/1.1 method that is used to determine further information from servers, and is a safe method, meaning that it can't be used to change the resource.</p>
<pre><code>OPTIONS /doc HTTP/1.1
Host: bar.other
Origin: http://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type

HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Origin

POST /doc HTTP/1.1
Host: bar.other
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Origin: https://foo.example

HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://foo.example
Content-Type: text/plain
</code></pre>
<p>Note that along with the OPTIONS request, two other request headers are sent: <code>Access-Control-Request-Method</code> and <code>Access-Control-Request-Headers</code>. The <code>Access-Control-Request-Method</code> header notifies the server that when the actual request is sent, it will be sent with a POST request method. The <code>Access-Control-Request-Headers</code> header notifies the server that when the actual request is sent, it will be sent with a <code>X-PINGOTHER</code> and <code>Content-Type</code> custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</p>
<p>In addition to <code>Access-Control-Allow-Origin</code>, the server responds with <code>Access-Control-Allow-Methods</code> and says that POST and GET are viable methods to query the resource. The server also sends <code>Access-Control-Allow-Headers</code> with a value of "X-PINGOTHER, Content-Type", confirming that these are permitted headers to be used with the actual request. Finally, <code>Access-Control-Max-Age</code> gives the value in seconds for how long the response to the preflight request can be cached without sending another preflight request. (Note that each browser has a maximum internal value that takes precedence when the <code>Access-Control-Max-Age</code> is greater).</p>
<p>When sending the actual request after preflight is done, the behavior is identical to how a simple request is handled. In other words, a non-simple request whose preflight is successful is treated the same as a simple request, and the server must still send <code>Access-Control-Allow-Origin</code> header again for the actual response.</p>
<p>If the server specifies a single origin rather than the <code>"*"</code> wildcard, then the server should also <strong>include Origin in the <code>Vary</code> response header</strong> — to indicate clients that server responses will differ based on the value of the Origin request header. <code>Vary</code> header is quite important when a caching proxy is looking for a cache HIT or MISS. It is a way for the web-server to tell any intermediaries (caching proxies) whether a cached response can be used. For example, <code>Vary: *</code> means each request is supposed to be treated as a unique and uncacheable one.</p>
<h3>Requests with credentials</h3>
<p>By default, in cross-site XMLHttpRequest or Fetch invocations, browsers will not send credentials. A specific flag has to be set on the XMLHttpRequest object or the <code>Request</code> constructor when it is invoked. When responding to a credentialed request, the server must specify an origin in the value of the <code>Access-Control-Allow-Origin</code> header, instead of specifying the <code>"*"</code> wildcard.</p>
<ul>
<li>The server must respond with the <code>Access-Control-Allow-Credentials: true</code> header to allow Cookies to be included on cross-origin requests.</li>
<li>The client must set the <code>XMLHttpRequest.withCredentials</code> flag to true in order to make the invocation with Cookies.</li>
<li>Cookies set in CORS responses are subject to normal third-party cookie policies.</li>
</ul>
<h3><code>integrity</code> and <code>crossorigin</code> in CDN links</h3>
<p><code>integrity</code> defines the hash value of a resource (like a checksum) that has to be matched to make the browser execute it. The hash ensures that the file was unmodified and contains expected data. <em>With an <code>integrity</code> set on an external origin and a missing <code>crossorigin</code> the browser will choose to 'fail-open', as if the <code>integrity</code> attribute was not set.</em></p>
<p>The <code>crossorigin</code> attribute, valid on the <code>&lt;audio&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, and <code>&lt;video&gt;</code> elements, provides support for CORS, defining how the element handles cross-origin requests. <code>crossorigin="anonymous"</code> means don't send credentials. Setting the attribute name to an empty value, like <code>crossorigin</code> or <code>crossorigin=""</code>, is the same as <code>anonymous</code>.</p>
<ol>
<li>There are actually three possible values for the <code>crossorigin</code> attribute: <code>anonymous</code>, <code>use-credentials</code>, and an "missing value default" that can only be accessed by omitting the attribute. The default value causes the browser to skip CORS entirely, which is the normal behavior (<code>Sec-Fetch-Mode: no-cors</code>).</li>
<li>The <code>crossorigin</code> attribute should only be used if we care about getting error information for the resource being loaded. Since accessing this information (with CORS settings attribute) requires a CORS check, the <code>Access-Control-Allow-Origin</code> header must be present on the resource for it to be loaded.</li>
</ol>
