<h2><a href="https://gitee.com/Kenneth-Lee-2012/MySummary/blob/master/软件构架设计/语义纠偏——细节调研的目的和方向.rst">仓库源文</a></h2>
<p>.. Kenneth Lee 版权所有 2024</p>
<p>:Authors: Kenneth Lee
:Version: 0.1
:Date: 2024-12-20
:Status: Draft</p>
<p>语义纠偏——细节调研的目的和方向</p>
<hr/>
<p>这个总结最初是想谈架构师有没有必要编码的，但我想得到的结论不是讨论架构师有没有
必要编码，而是架构怎么做失败的。</p>
<p>我之前讨论架构设计的关键，一直用“道”和“名”这两个概念。“道”是全部的事实，而“名”
是对“道”的“总结”。名描述了道的部分特征，但不是全部的特征。所以道可道，但所道之
道（名），非道之本体。</p>
<p>这就好像函数signature描述了函数的接口，但没有描述函数的实现，而我们常常用
signature去“代表”这儿函数，似乎我们说的是这个函数的实现，但其实我们不是。关键
是：函数的实现信息通常signature多，但它的范围通常比signature小。</p>
<p>这个事实很容易解释和理解，但如果你没有深入考虑这个问题，你可能就没有注意到这个
问题的存在。</p>
<p>考量下面这个signature：::</p>
<p>void list_add(struct list_node <em>node, struct list_node </em>head);</p>
<p>这是个非常典型的Linux内核形式的双向链表的函数定义。我们用这个“名”代表了这个函
数的所有可能实现。但它既可以代表下面这样的实现：::</p>
<p>void list_add(struct list_node <em>node, struct list_node </em>head) {
        log("node %p added to %p\n", node, head);
        node-&gt;next = head-&gt;next-&gt;next;
        node-&gt;prev = head;
        head-&gt;next = node;
        node-&gt;next-prev = node;
  }</p>
<p>也可以代表下面这样的实现：::</p>
<p>void list_add(struct list_node <em>node, struct list_node </em>head) {
        validate(node);
        validate(head);
        __list_add_rcu(node, head, head-&gt;next);
  }</p>
<p>这里任何一个实现的信息，都包含了比前面的签名多的逻辑。但逻辑越多限定的范围也越
小，所以signature限定的范围反而是最大的。</p>
<p>signature可以包含任何一种实现。但我们最终会选择一种实现，这个实现总是产生额外
的限制，从而缩小了范围。</p>
<p>这里我只用了一层作为类比，现实的设计显然不会只有几层，比如我最近在做的一个多机
共享内存的实现，每个逻辑要考虑从用户态穿到内核，然后从内核下到虚拟机后端，在从
虚拟机的用户态进入Host的内核，到BIOS，然后访问总线上的控制器……而且每个这样的逻
辑还要和其他逻辑配合……这中间涉及的细节就不是我们的脑子可以同时控制住的。然后我
们在每个设计上就不得不落在某个层面的“名”上面，而没法工作在道上面。</p>
<p>所以，对于做架构来说，我们最难的问题在于，我们所认识的名，以及我们抽象出来的这
个名的所有属性，不一定关注了我们的细节中真正要关心的部分。</p>
<p>所以，架构设计的第一步，不是根据我们已经知道的名字去思考设计逻辑。而是我们首先
得去重新建立我们对这个总结的认知。</p>
<p>比如用户说，“我想要一个Web Server”。你不能马上就认为他要的是一个Nginx那样的东
西。他说的Web Server也不见得就是Web Server，说不定在他看来所有的后端Daemon都叫
Web Server。他心目中的Web Server也不见得是跑在服务器上的，说不定是实现在FPGA上
的。我们说话总是不得不用名，但相同的名，表示的道不一样，关注的属性也不一样，这
才是用架构语言进行沟通的难点。</p>
<p>我说了这么多，我现在和你讨论的“名”，和“道”，和文章一开头说的“名”和“道”的那些意
思，是不是已经不一样了？</p>
<p>所以，在架构设计的早期，我们详细说说业务的使用过程，某个操作员的一天工作日常，
客户的钱是怎么赚到的，为什么客户概念中会有“巡检”这个概念……等等等等，我们都是在
丰富我们一开始并不熟悉的各种“名”，然后我们的设计逻辑才会靠谱。因为这样以后，我
们的名才代表我们说的那个“道”。</p>
<p>我们很多构架设计的错误就在于没有认识到：很多名字的语义，和我们实际对这个名字的
理解是不一样的。所以，架构师确实有必要去编码，这个目的不是为了写什么“核心代码”，
也不是为了“亲近一线，和一线同甘共苦”，而是架构师必须通过这些形式去丰富对那个名
字的认知。</p>
<p>而我们一开始就知道架构师无法编完所有的代码，也无法理解所有的逻辑，这是人脑限制
的。所以架构师通常编“不重复的主要特征逻辑”，比如把模块串起来的主要逻辑，典型的
模块等等，这其实也不那么重要，关键他得知道他的目的就不是为了输出那些代码，而是
他要靠这种工作来辅助他完成一个靠谱的设计，目的是在设计上的，不是为了输出那些代
码。</p>
<p>另一个更关键的问题在于，我们设计上的创新，也都来源于我们对这些概念的重新认知，
用户需要做一个新的产品，必然因为发现了新的问题。他的条件不一样了，就算是出于
“供应链替代”这样的条件，你也会有“技术已经进步”，“我们对过去犯过的错误有新的认
识”，“产品使用范围有所变化”……这些因素的变化，如果我们总是用过去的思维来解释我
们现在用到的概念，我们就会背上所有本来不需要背负的负担。也就基本上失去创新的能
力了。而不做设计的人，往往陷入的就是这样的境地。因为如果不做设计，他就只能使用
固定的名和这个名的属性去制造自己的细节约束。范围都限定死了，你也就失去创新能力
了。</p>
<p>这有人称为“第一性原理”，其实前提就是你要“打开”名字的空间，要花足够的时间去“感
受”一些这个名字的“具象”是什么样的。这才是我们拉高层面进行设计的目的。</p>
