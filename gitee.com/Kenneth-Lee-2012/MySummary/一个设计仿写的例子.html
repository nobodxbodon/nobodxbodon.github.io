<h2><a href="https://gitee.com/Kenneth-Lee-2012/MySummary/blob/master/%E8%BD%AF%E4%BB%B6%E6%9E%84%E6%9E%B6%E8%AE%BE%E8%AE%A1/%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E4%BB%BF%E5%86%99%E7%9A%84%E4%BE%8B%E5%AD%90.rst">仓库源文</a></h2>
<p>.. Kenneth Lee 版权所有 2024</p>
<p>:Authors: Kenneth Lee
:Version: 0.1
:Date: 2024-06-20
:Status: Draft</p>
<p>无价之宝——一个设计仿写的例子</p>
<hr/>
<p>最近评审了一个OS和BIOS的接口设计，我感觉基础定义很不合理的，我大致总结一下这些
我感受不合理的地方：</p>
<ol>
<li><p>它使用一个寄存器传递参数的二进制接口，然后用描述C函数的方式描述这个接口，但
这个二进制接口有两个返回值（我们知道C语言函数调用只有一个返回值）。我感觉这
两个二进制作为返回值的寄存器，其实有一个是用作C函数的返回值，另一个类似Unix
的errno，用来统一表示错误分类的。</p>
</li>
<li><p>但在一个检查某个服务是否被支持的接口中——我们这里假设叫
check_available(service_id)吧，它的返回值是0，而用错误码表示这个服务是否被
支持，这又违背了errno的使用pattern。</p>
</li>
<li><p>errno这样的设计导致了所有错误码都统一编码，但相应的错误在每个请求中其实不共
享。比如请求CPU复位的错误，和取版本号这个错误，错误码是在一个空间里面编码的，
这样毫无意义。在Unix系统中这是合理的，因为Unix系统大部分时候errno是统一处理
的。Unix系统认为一般API的返回值是用来支持主流程运行的，错误码只是用来定位问
题的，特别是叠加的多个调用的时候。比如你调用malloc产生了futex的错误，那么
malloc报的错可能是它自己报的，也可能是futex报的，它需要一个统一的编码来统一
这种错误，你一个OS和BIOS间的接口又没有这样的关系，为什么需要这样定义？</p>
</li>
</ol>
<p>我把这些问题提出来的时候，有人告诉我，其实这个接口是仿OpenSBI的，OpenSBI的设计
就是这样的。</p>
<p>于是我去看了一下OpenSBI，我发现是这样的：</p>
<ol>
<li><p>OpenSBI确实是用了一个C的接口，但它真的明确的基于C的ABI来定义的。它的参数就
是a0-a7，只是补充了a6,a7用来做扩展名和扩展中的功能参数。返回值也是按C标准叫
a0，但扩展了a1，以便返回errno。所以OpenSBI确实可以用C的方法来描述接口，因为
我们可以直接用C的表达直接对应到二进制接口的全部行为上。</p>
</li>
<li><p>OpenSBI确实用了errno的模式，这个我认为其实是不合理的。我个人认为长远维护下
去，维护者估计也会看着不爽。不过一般来说OS-BIOS接口没几个人用，感受到不爽的
人也不会太多。这算是个小瑕疵吧。</p>
</li>
<li><p>OpenSBI那个检查服务是否支持的功能叫sbi_probe_extension()，人家确实是用返回
值来表示服务是否存在，而不是用errno来表示服务是否存在的。更关键的一个问题是，
RISCV是一个以大量扩展为基础的方案，所以它这类检查必须以扩展为单位。而我们现
在谈的这个方案完全不是这回事，这里用服务ID再分功能的方式，其实没什么道理。</p>
</li>
</ol>
<p>其实我看完这个OpenSBI的接口后，我确实发现我评审的这个方案几乎是像素级在复刻
OpenSBI的设计。但我依然认为OpenSBI的设计算不上太好，但还是质量在线的。而上面那
个设计的质量，我在直观感觉上认为是不在线的。</p>
<p>作为一个经常对人家的设计有一堆意见的架构师，我希望通过写这个总结反思一下，我是
不是过于苛刻了。</p>
<p>从直觉想逻辑，我觉得作为一个架构师，如果我允许一个这样设计放在系统中，那么后面
的设计也会复刻前面设计的风格，而这种风格在整个系统中一传递，这个系统后面就很难
维护了。</p>
<p>那么，这个“风格”是什么呢？</p>
<p>我觉得主要还是“无目标导致的无规律”。比如，它也用r6和r7作为扩展ID和功能ID，但
OpenSBI用的是a6和a7啊大哥，a6和a7是RISCV ABI接口中的X16和X17啊。人家是有目的的，
选择了所有的输入参数的最后两个作为输入。你这里用顺序的第六和第七个寄存器作为输
入，这个选择就莫名其妙了。</p>
<p>然后就是前面说的这个检查服务是否存在的调用，设计成那样（用错误码当作返回值用），
明显就是没有搞清楚errno的真正作用所以才是这样的。</p>
<p>这样，你从这个接口上看不到设计选择的明确目的，那么以后补充其他设计的时候，后面
的人就不知道如何取舍了。</p>
<p>每个设计决定，本质都是一个“限制”（“第一个参数放在R0中”，就拒绝了“第一个参数放
在R1中”这个选择，所以设计本质是限制），所以每个设计决定都是一个“代价”（失去自
由的代价）。我们把很多的设计决定综合在一起的时候，需要综合所有设计的自由空间的
交集，这样就会冲突，要消弭冲突，就要取舍。这时，“代价”成本就是谁后退，谁保持的
判断依据了。没有“设计目的”的“设计”，我称为“无价之宝”，又叫“铁索横江”，你不敢动
他，因为复杂了以后你根本不知道会导致什么问题。系统中有一堆这种“无价之宝”，这个
系统就没法维护了。</p>
<p>所以，一旦在设计初期就有大量这种原因都搞不清楚，就是在复刻别人的设计的设计，它
就是危险的，我本能会反对它。</p>
<p>只要不侵犯版权，而且可以达成设计目标，复刻别人的设计是个安全的做法，这我认为应
该鼓励。但复刻设计是复刻经验（所达成的目标），不能复刻样子。</p>
