<h2><a href="https://gitee.com/Kenneth-Lee-2012/MySummary/blob/master/软件构架设计/填空问题.rst">仓库源文</a></h2>
<p>.. Kenneth Lee 版权所有 2025</p>
<p>:Authors: Kenneth Lee
:Version: 0.1
:Date: 2025-02-28
:Status: Draft</p>
<p>填空问题</p>
<hr/>
<p>设计文档的“填空”问题我在单位内部写过多个博客进行批判。这两天评审一个设计文档的
时候又发现多个例子，我就想补充到到这里来。才发现这里从来没有讨论这个问题，所以
我就着记录这些例子的机会，在这里也总结一下这个问题。</p>
<p>我们做设计，是把产品做成的需要，对于一个较大的产品或者软件，我们要考虑的，会遇
到的问题都非常多，我们经常要在无数的细节中找到问题的“主要矛盾和主要的矛盾方面”。
为了保证我们正确抓住这些主要矛盾和主要的矛盾方面，我们需要建立一个或者多个“视
图（View）”：我们看到了产品设计的无数细节，我们挑出某个方面的关键信息，把这些
信息组合到一个逻辑空间中，从而可以在一个封闭的空间中对问题进行推理。</p>
<p>具象化举一个例子：你写一个内存分配函数，你看到的细节是函数入口参数（比如size），
可以分配的内存的整个空间。但凭这个信息你可以写好这个程序吗？很难，你要分别考虑
如下视图：</p>
<ol>
<li>有多少个线程按什么样的规律访问这片内存？</li>
<li>你提供的API的全集是什么？除了可以malloc，还可以realloc吗？会有对齐要求吗？
会有缺页保护的要求吗？会对内存使用的NUMA节点有要求吗？</li>
<li>出错要循什么出错流程处理？直接系统异常？返回错误码？设置全局错误变量（比如
errno）？还是自动修复？</li>
<li>……</li>
</ol>
<p>这些每个考虑的角度，就是一个设计方面的视图。不独立考虑一个个这样的视图，只盯着
malloc这个函数的实现，你没法写好这个函数。而这些视图基本上没法写成程序，到头来，
它们就会变成设计，或者呈现为设计文档。</p>
<p>我这里举的例子还是相对简单的，很多这种设计只简单“记在心中”就可以。但如果把这个
要求放大，比如变成“设计一台服务器”，或者“设计一个指令集”，不落实成文档，几乎没
有办法维护这么多复杂的逻辑。不管理这种设计，我们通常也能设计出产品——的第一个版
本，甚至运气好一点——的几个版本，但基本上都延续不下去。因为产品初期就几个功能几
个场景，有大把的余量让你规避冲突，但等功能都加上来后，这个你怎么加逻辑都没法不
和其他功能冲突了。</p>
<p>如果要对应前面的例子，你的内存分配可能也就一个线程访问，所以你不上锁也无所谓，
或者你上了锁，性能也不会受影响。但如果变成有多个线程访问呢？访问的并行度需要很
高呢？中间还有可能在信号处理和中断处理中调用呢？一开始的逻辑空间如果没有考虑这
些要素，后面的逻辑根本就补充不进去。甚至可能你一开始就没有考虑过这个问题，就这
样加入了很多的代码，之后你在多线程访问下逻辑到底可以自洽还是不能自洽呢？你根本
就不知道，因为你又看不完那么多代码，你怎么知道怎么代码里面具体有没有考虑到两个
线程上下文同时访问会不会错呢？</p>
<p>这就是设计的必要性，没有设计，长远来说，代码根本很难维护，甚至都不用进入维护阶
段，在开发阶段可能就会因为第一波需求没法综合在一起就失败了。</p>
<p>但初学者还在学习代码的反馈，对代码的反馈缺乏认识，写下的代码不跑一下他都不一定
知道结果是什么样的，这种情况你要求他能提前考虑到其他要求，就很难了。这种没什么
可说的，他们只能写一些简单的代码，如果需要做产品，就需要系统工程师带着。</p>
<p>但慢慢这些人会成长，他们也开始做设计了，这些刚刚进入设计的工程师，不一定能这么
快搞明白设计的必要性，因为他们的成功都来自“直接编码”。他们只是在“名义”上觉得
“设计师”都是上司，很厉害，都听说“设计(文档）”，但他们还没有感受到设计有什么用，
也不知道为什么要写设计文档。他们写设计文档是完成某个仪式，而不是认为设计是帮助
他编码的。</p>
<p>我在本文中要说的这个“填空”说的就是这种情况：设计师因为某种仪式要求，自己觉得需
要学习设计也行，某个公司的开发流程要求也罢，决定要写文档了，写这个文档他只是为
了完成这个仪式，要写一个“正确”的文档，而不是因为“代码直接编编不下去”，或者“没
把握这个代码这样假设是不是可以”，所以才决定写一个文档。</p>
<p>这样不带设计目标，而仅仅是为了完成某个仪式而写的“设计文档”，就叫填空。还是用前
面的malloc函数为例，如果他看到别人的设计文档中有个“设计约束”的章节，可能他也会
学着写一个这样的章节。但别人做这个设计，可能是因为有一些严格的外在要求，不放在
这里推整个推理不利，所以才加进来的。比如他可能收到一个要求：“要分配的内存是非
连续的，但以页为粒度的”，这就是一个“设计约束”，设计师考虑他的算法的时候要时刻
考虑到让自己记录可用内存的时候要用非连续的数据结构去记录它。之后到底是多少个线
程上下文来访问这个内存呢？没人告诉他，但这个对他的算法影响很大，他可能又会增加
一个“假设”的章节，说明他的设计是建立在“有多个线程同时来访问”这个基础上的。
这些设计都是有效的。</p>
<p>但只会填空的设计师可能也会写“设计约束”和“假设”的章节，但他并没有体会到这两个条
件的重要性。他可能写的约束是“必须用C语言写”，这句话没有错，但并没有外在的限制
在约束他必须用C语言写，他只是选择了使用C语言来写，这个根本不是他的约束，他这个
约束的设计，就成了一个“填空”了。同样，他的假设也有可能写“支持多线程访问”（因为
他看过他的“前辈”是这样写的），但他的需求不一定是这样，这样的结果，也是让设计变
成一个“填空”了。还有更多的，把写好的代码拷贝到文档中，显得自己在写一个设计文档。
这都是“填空”的例子。</p>
<p>我这次要记录的“填空”的例子是这样的：我评审的是一个指令集手册。我之前已经写了一
部分通用指令的介绍了，我是把这些指令直接分类存放就好了，因为通用指令嘛，你没有
什么好介绍的，除了一些内存读写指令有相关性我用了一章单独介绍外，其他的算法类的，
都罗列就行了。</p>
<p>但这位新加指令的设计师，他做的是一个加速功能，指令之间的关系是很密切的，他也学
我之前的写法一样，也直接出一个列表就算“写完”了。这就是我前面说的“填空”，我和他
沟通的时候，发现可以这样说明白给他听：你考虑你是一个开发者，你仅仅看到你提供的
每条指令，但不告诉你必须先调用谁，再调用谁，也不总结你这个功能加入了多少个寄存
器，你能写出代码来吗？</p>
<p>所以，我发现对刚开始做设计的工程师来说，也许可以通过这样的心法来自己判断自己是
在做设计还是在填空：如果我不做这个设计，影响了谁？是谁（自己或者用户都行）不看
我的结论（约束）会在设计中留下破绽？如果找不到这个人，那么你的设计就是“填空”了。</p>
<p>我在评审他的设计中还发现一个问题：他把一个单独的功能，放到两条指令上了（因为一
条指令放不下这种信息），我就挑刺说，如果两条指令中间发生了中断会怎么样，或者我
不连续写两条指令怎么样？</p>
<p>这不完全是“填空”的问题，更像是缺乏“可能性穷举”的问题，但我也要把这个例子放到这
里来，因为如果站在“用户看到这个定义如何写代码”的角度上，这个问题可以用前面一样
的心法去校验。</p>
<p>不过，设计的时候如果想不到这些可能性的工程师，可能也没有能力想到用户也是需要穷
举所有的可能性的。这个只能说提一嘴罢了。</p>
<h1>其他问题</h1>
<p>下面的问题不完全是“填空”的问题，只是我要记录这个案例，把和这个设计相关的问题也
一起放在里面。</p>
<p>我看到这个设计犯了几次的错误：控制不住视图的范围。比如他设计的是一个类似GPU的
SMIT的加速器。有过GPU设计或者底层使用经验的读者应该知道，GPU使用的是一种可以称
为“锁步执行”的方案。也就是说，单个核的所有硬线程，其实都是共享同一个指令
Counter（PC）的，所以虽然你看着有共享计算Kernel的多个线程同时执行，但其实在硬
件上这些线程的每一步，都是同步的，如果执行的过程中发生了跳转，硬件需要一些寄存
器记住每个线程在跳转的哪一边，从而不执行不在这个分支上的线程的指令。但这个东西
说是这样说，你写Kernel的时候，其实很大程度上是忽略这一点的。所以GPU的手册对开
发者暴露的是：你写的Kernel代码，会被N条Lane的多个线程同时执行，完成你这条Lane
的计算。而不会直接暴露你用来控制这个同步过程的寄存器给开发者。所以，尽管你的硬
件设计有这个控制多条Lane的寄存器，但你在Kernel的接口上是不会暴露这个寄存器的。</p>
<p>而我评审的这个设计，就是直接在手册中给了客户这个寄存器。问题是，看了半天，你都
不知道用户拿着这个寄存器干什么。</p>
<p>这就是“控制不住视图的范围”，做架构设计，我们希望尽量维护每个视图的稳定性，这样
我们修改的时候影响的范围就是有限的。如果每个视图都看到所有的东西，这个系统就没
法维护了。Kernel的开发者知道（这里说“知道”是说他用了你这个逻辑）你有多少条Lane，
知道你怎么控制这些Lane的，知道你的物理寄存器有多少个，知道你的流水线哪里会做
Forward，你修改这些模块的时候会直接影响到软件上啊。以后这个系统怎么改呢？随便
改哪里可能都要几百几千的软件工程师一起动作，还要在几亿几百亿的应用场景中同步升
级的啊。</p>
<p>这个问题的另一个例子是这样的：设计师提供了两条指令，用于“内存分配和释放”，这个
很奇怪，硬件角度哪来的内存分配和释放？内存管理整个就是软件角度的概念，怎么会出
现在硬件接口这个视图上呢？我去问了一下，原来设计者在加速器里面实现了一个私有的
Buffer空间，它这个是用来从这个分配空间中分配内存的。但如果你要开辟这个新的概念
空间，你的建模就应该包括：Buffer如何定义，大小多少，是否和内存一同编置，是否会
出异常，能否做地址翻译，内存序如何定义……等等等等一系列问题了。而设计师居然就觉
得“我这个和软件的内存管理是一样的，你按这个理解就行”？这个例子给我的感觉是，设
计师控制不住视图的范围，是因为建模逻辑空间的时候完全是没有边界感的，不知道建立
一个概念空间的所有概念包括那些内容，是否能在一个概念空间中概念自洽，这些他可能
都没有认识，这种情况下，就不可能认识“视图”的含义了，视图能被理解就是因为它有边
界，从而可以被分成一个区域一个区域去穷举。对这个边界没有感知，就不可能感知到范
围的“补集”在哪里，也没有能力对不同的集合进行穷举了。</p>
<p>下面是另一个错误类型：单一流程。还是这个SMIT的执行过程，比如我们设定了要执行N
条Lane，但引擎只有M条Lane，那么执行的时候需需要分成多个串行的步骤执行了。设计
者把这个串行执行的步骤描述了。但设计完这个，我们肯定马上需要穷举所有的和设想不
一致的其他“异常”流程了。比如在串行的过程中发生中断或者异常会怎么样？是所有的
Lane都被上下文保存还是，只有当前执行的Lane？在执行的过程中如果不同的Lane都访问
相同的内存地址，这个内存序是什么样的？这些都是开发过程中开发工程师需要处理的。
你不能认为你的系统就你自己设想的这样运行吧？</p>
<p>更要命的是，有时设计师甚至就没考虑过编程的人怎么用这个系统。比如这个设计中，设
计师只说了会分成多个Lane执行。居然完全没有提到开发工程师在kernel代码中怎么知道
自己所在的Lane是哪个。这又是一个缺乏经验的误区：设计师认为“我把我设计的每个东
西的细节都告诉你了，怎么你还觉得信息不够呢？”——问题是，你是为客户设计的啊。你
吧砖头垒成一个猪窝，就算你把每块砖怎么放都告诉我了，它也不是我要的房子啊。当然，
这样比喻有点过了，你确实还是打算垒一个人住的房子的，但你不确定我这个角度的使用
逻辑，告诉我你建造的逻辑，它也没法满足我的使用需要啊。</p>
