<h2><a href="https://gitee.com/Kenneth-Lee-2012/MySummary/blob/master/软件构架设计/设计的本质.rst">仓库源文</a></h2>
<p>.. Kenneth Lee 版权所有 2024</p>
<p>:Authors: Kenneth Lee
:Version: 0.1
:Date: 2024-06-26
:Status: Draft</p>
<p>设计的本质</p>
<hr/>
<p>本文记录一个最近的一个观察。我发现，设计本质是在发明“名”，或者说发明一个比较严
格的名。</p>
<p>名是归纳，是在乱相中找到规律。但实际上很多东西没有规律，或者说规律性不明显，而
设计是填补这些规律。</p>
<p>比如说“内存管理”，是一种规律，它有一个隐隐约约的对规律的认识和对这个规律的期望
在其中：我知道有一片内存，肯定可以从里面拿一部分出来，晚点可以还回去，等下次要
用的时候可以再拿。这个规律是隐隐约约的，但里面具体怎么做到的，这个“信息”不存在。</p>
<p>那么设计就是要为这个分配填补无规律的细节。比如，分配要求太多了就返回失败，产生
碎片了进行位置调整，……等等。最后这个“内存管理模块”——虽然包含很多细节——但就可以
用这个名字去代替了。我们都不用管黑盒里面具体是怎么做的，我们只管找它要，给它还，
细节都包装在里面了。这个“内存管理模块”就是一个相对“严格的名”。</p>
<p>所以我们说函数需要是个高扇入低扇出的设计，因为函数的扇出是它内部的细节黑盒，而
扇出是它被使用的名和规律特征。如果扇出和扇入一样大，这个函数就没有“总结”的效果
了。比如你会这样写函数：</p>
<p>.. code-block:: c</p>
<p>int put_data(struct DATA *data) {
    if (--data-&gt;ref_count &lt;= 0) {
      free(data);
    }
  }</p>
<p>但你不会这样写：</p>
<p>.. code-block:: c</p>
<p>int dec_data_ref_count_if_ngt_0_free(struct DATA *data) {
    if (--data-&gt;ref_count &lt;= 0) {
      free(data);
    }
  }</p>
<p>因为我们是在制造一个“函数调用代理为data的使用者减少，如何处理资源可以不用管”的
规律，里面具体是用引用技术，还是用引用树，内存如何分配，都不是我们要制造的规律
。我们人脑其实只能在“名”上思考，我们是从一个“名”，代理为另一个“名”。为了做到这
一点，我们打开这个名，找出一组“小名”，然后填补约束，让另一个名也呈现规律。设计
的本质，就是这个打开小名然后构造另一个规律的过程。</p>
<p>理解这一点有什么用呢？我也不知道。我先记下来，看看未来在解决其他一些问题的时候，
能否更好解释那些问题。</p>
