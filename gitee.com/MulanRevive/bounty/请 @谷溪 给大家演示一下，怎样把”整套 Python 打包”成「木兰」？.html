<h2><a href="https://gitee.com/MulanRevive/bounty/blob/master/进展小结/2020-03-03-请 @谷溪 给大家演示一下，怎样把”整套 Python 打包”成「木兰」？.markdown">仓库源文</a></h2>
<p><a href="https://www.zhihu.com/people/a24d6e757832a354340a1693a10dec8f">@谷溪</a>
的原答在此：
<a href="https://www.zhihu.com/question/366509495/answer/978180132">「木兰」编程语言有什么特色？​</a></p>
<p>下面进行逐段分析：</p>
<h2>看图标就够了？</h2>
<p>在第一时间就发现它是 Pyinstaller 打包，没毛病。问题在于您的这个重大结论：</p>
<blockquote><p>实验了一下，确实是直接用 pyinstaller 把整套 Python 打包了一下就敢自称「自主研发」了。</p>
</blockquote>
<p>这里的“整套 Python”应该指的是 Python 编译器源码吧？我用 pyinstaller 可用的是逆向工程出的 python 代码，就那样<a href="https://zhuanlan.zhihu.com/p/107836848">还没有完全复现 ulang 可执行文件的功能</a>。</p>
<p><strong><em>我真的想知道，您当时，到底，是怎么打包出来的？？</em></strong></p>
<blockquote><p>看到这个图标，Python 工程师们就应该会心一笑了——这tm就是 Pyinstaller 打包以后的默认图标啊，都不用看源码，一下子就露怯了。</p>
</blockquote>
<p>Python 编写的所有脚本用 Pyinstaller 打包之后都是这个默认图标，笑点在哪里？</p>
<p>还“不用看源码”吗？那是不是所有用 Python 编写的脚本再用 Pyinstaller 打包都是“Python 换皮”了？</p>
<h2>解包</h2>
<p>看这个样子，您当时并没有获得它的核心源代码（包括一千多行 Ply 代码），而只是用一个找到的 pyinstaller 解包工具把它解开来看了一眼。</p>
<p>斗胆猜度，也许您对 pyinstaller 和反编译并不熟悉？否则应该能直接生成它逆向的源码吧？还是说，逆向出来了代码，但却与您的论点不符于是无视？</p>
<h2>可以导入 Python 模块是罪过？？</h2>
<p>这里引用了 <a href="https://www.zhihu.com/people/44cf7f9beecff39762ad9afaeb952df0">@minisys</a> 的<a href="https://www.zhihu.com/question/366509495/answer/977687177">回答</a>：</p>
<p>充其量是证明了可以导入python 模块，而在我之后的验证中，它同时也支持<a href="https://zhuanlan.zhihu.com/p/108632734">导入木兰（ul）模块</a>的。</p>
<p>更不用说，基于现有编程语言的库、生态创建新的编程语言<a href="https://zhuanlan.zhihu.com/p/103734308">早有成功先例</a>。</p>
<p><strong><em>您怎么就从这得出“不是什么重新实现了解释器”的结论了呢？</em></strong></p>
<p>请 @谷溪 现身向公众交代一下！</p>
<p><strong><em>否则，您回答有一千多赞打底，谣言的传播范围可远远不止这个数。</em></strong></p>
<p>3/5 已等两天，刚发现当事人无意回应，于是举报：</p>
