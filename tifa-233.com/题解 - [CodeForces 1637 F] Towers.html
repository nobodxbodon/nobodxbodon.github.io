<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/cf1637f.md">仓库源文</a>，<a href="https://tifa-233.com/archives/cf1637f">站点原文</a></h2>
<p><a href="https://codeforces.com/problemset/problem/1637/F">题目链接</a></p>
&lt;!-- more --&gt;

<h2>原始题面</h2>
<p>time limit per test: 2 seconds</p>
<p>memory limit per test: 256 megabytes</p>
<p>input: standard input</p>
<p>output: standard output</p>
<p>You are given a tree with $n$ vertices numbered from $1$ to $n$. The height of the $i$-th vertex is $h_i$. You can place any number of towers into vertices, for each tower you can choose which vertex to put it in, as well as choose its efficiency. Setting up a tower with efficiency $e$ costs $e$ coins, where $e &gt; 0$</p>
<p>It is considered that a vertex $x$ gets a signal if for some pair of towers at the vertices $u$ and $v$ ($u \neq v$, but it is allowed that $x = u$ or $x = v$) with efficiencies $e_u$ and $e_v$, respectively, it is satisfied that $\min(e_u, e_v) \geq h_x$ and $x$ lies on the path between $u$ and $v$</p>
<p>Find the minimum number of coins required to set up towers so that you can get a signal at all vertices</p>
<h3>Input</h3>
<p>The first line contains an integer $n$ ($2 \le n \le 200\,000$) — the number of vertices in the tree</p>
<p>The second line contains $n$ integers $h_i$ ($1 \le h_i \le 10^9$) — the heights of the vertices</p>
<p>Each of the next $n-  1$ lines contain a pair of numbers $v_i, u_i$ ($1 \le v_i, u_i \le n$) — an edge of the tree. It is guaranteed that the given edges form a tree</p>
<h3>Output</h3>
<p>Print one integer — the minimum required number of coins
Examples</p>
<h3>Input</h3>
<pre><code class="lang-input1">3
1 2 1
1 2
2 3
</code></pre>
<h3>Output</h3>
<pre><code class="lang-output1">4
</code></pre>
<h3>Input</h3>
<pre><code class="lang-input2">5
1 3 3 1 3
1 3
5 4
4 3
2 3
</code></pre>
<h3>Output</h3>
<pre><code class="lang-output2">7
</code></pre>
<h3>Input</h3>
<pre><code class="lang-input3">2
6 1
1 2
</code></pre>
<h3>Output</h3>
<pre><code class="lang-otuput3">12
</code></pre>
<h3>Note</h3>
<p>In the first test case it's optimal to install two towers with efficiencies $2$ at vertices $1$ and $3$</p>
<p>In the second test case it's optimal to install a tower with efficiency $1$ at vertex $1$ and two towers with efficiencies $3$ at vertices $2$ and $5$</p>
<p>In the third test case it's optimal to install two towers with efficiencies $6$ at vertices $1$ and $2$</p>
<h2>题意简述</h2>
<p>在一棵无根树上放若干个塔, 每个塔有权值 $e$, 树上结点自带权值 $h$, 要求树上任意结点均在某两个塔之间的简单路径上, 且这两个塔的权值均不小于该结点的权值, 求塔权值的最小和</p>
<h2>解题思路</h2>
<p>显然塔应都放在叶子结点上</p>
<p>为方便起见, 我们让权值最大的点为根节点, 令其为 $r$, 此时我们只需让叶子结点里有两个塔的权值为 $h_r$ 即可</p>
<p>我们考虑一条从根节点到叶子结点的链, 其中根结点的一端相当于有了一个权值为 $h_r$ 的塔, 那么另一端只需放一个权值为该链上的结点权值次大值的塔即可</p>
<blockquote><p>这有 2500 ?</p>
</blockquote>
<h2>复杂度</h2>
<p>$O(n)$</p>
<h2>代码参考</h2>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

{% icodeweb cpa_cpp title:CodeForces_1637F CodeForces/1637F/0.cpp %}

&lt;/details&gt;