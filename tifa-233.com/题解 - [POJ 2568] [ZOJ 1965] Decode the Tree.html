<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/poj-2568.md">仓库源文</a>，<a href="https://tifa-233.com/archives/poj-2568">站点原文</a></h2>
<hr/>
<p>title: "题解 - [POJ 2568] [ZOJ 1965] Decode the Tree"
categories:</p>
<ul>
<li>算法竞赛</li>
<li>题解
tags:</li>
<li>算法竞赛</li>
<li>题解</li>
<li>POJ</li>
<li>ZOJ</li>
<li>数据结构</li>
<li>树</li>
<li>无根树</li>
<li>Prufer序列
date: 2020-07-30 22:03:55</li>
</ul>
<hr/>
<p>题目链接</p>
<ul>
<li><a href="https://vjudge.net/problem/POJ-2568/origin">POJ 2568</a></li>
<li><a href="https://vjudge.net/problem/ZOJ-1965/origin">ZOJ 1965</a></li>
</ul>
<p>&lt;!-- more --&gt;</p>
<h2>原始题面</h2>
<h3>Description</h3>
<p>A tree (i.e. a connected graph without cycles) with vertices numbered by the integers 1, 2, ..., n is given. The "Prufer" code of such a tree is built as follows: the leaf (a vertex that is incident to only one edge) with the minimal number is taken. This leaf, together with its incident edge is removed from the graph, while the number of the vertex that was adjacent to the leaf is written down. In the obtained graph, this procedure is repeated, until there is only one vertex left (which, by the way, always has number n). The written down sequence of n-1 numbers is called the Prufer code of the tree</p>
<p>Your task is, to reconstruct a tree, given its Prufer code. The tree should be denoted by a word of the language specified by the following grammar:</p>
<pre><code class="language-plaintext">T ::= "(" N S ")"

S ::= " " T S

    | empty

N ::= number
</code></pre>
<p>That is, trees have parentheses around them, and a number denoting the identifier of the root vertex, followed by arbitrarily many (maybe none) subtrees separated by a single space character. As an example, take a look at the tree in the figure below which is denoted in the first line of the sample output. To generate further sample input, you may use your solution to Problem 2567</p>
<p>Note that, according to the definition given above, the root of a tree may be a leaf as well. It is only for the ease of denotation that we designate some vertex to be the root. Usually, what we are dealing here with is called an "unrooted tree"</p>
<h3>Input</h3>
<p>The input contains several test cases. Each test case specifies the Prufer code of a tree on one line. You will find $n-1$ numbers separated by a single space. Input is terminated by EOF. You may assume that $1\leqslant n\leqslant 50$</p>
<h3>Output</h3>
<p>For each test case generate a single line containing the corresponding tree, denoted as described above. Note that, in general, there are many ways to denote such a tree: choose your favourite one</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/1.bmp"/></p>
<h3>Sample Input</h3>
<pre><code class="language-input">5 2 5 2 6 2 8
2 3
2 1 6 2 6
</code></pre>
<h3>Sample Output</h3>
<pre><code class="language-output">(8 (2 (3) (5 (1) (4)) (6 (7))))
(3 (2 (1)))
(6 (1 (4)) (2 (3) (5)))
</code></pre>
<h3>Source</h3>
<p>Ulm Local 2001</p>
<h2>题意简述</h2>
<p>给出一个无根树对应的 Prufer 序列, 随意令一个结点为根, 按先序遍历输出该树</p>
<h2>解题思路</h2>
<p>板子题, 没啥好说的</p>
<h2>代码参考</h2>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:POJ_2568 POJ/2568/0.cpp %}</p>
<p>&lt;/details&gt;</p>
