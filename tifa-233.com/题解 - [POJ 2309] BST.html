<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/poj-2309.md">仓库源文</a>，<a href="https://tifa-233.com/archives/poj-2309">站点原文</a></h2>
<p><a href="https://vjudge.net/problem/POJ-2309/origin">题目链接</a></p>
&lt;!-- more --&gt;

<h2>原始题面</h2>
<h3>Description</h3>
<p>Consider an infinite full binary search tree (see the figure below), the numbers in the nodes are 1, 2, 3, .... In a subtree whose root node is X, we can get the minimum number in this subtree by repeating going down the left node until the last level, and we can also find the maximum number by going down the right node. Now you are given some queries as "What are the minimum and maximum numbers in the subtree whose root node is X?" Please try to find answers for there queries</p>
<p><img alt="" src="/Users/xuanwu/work/聚聚/中文博客集锦/源数据/博客聚合/tifa-233.com/source/_posts/1.webp"/></p>
<h3>Input</h3>
<p>In the input, the first line contains an integer N, which represents the number of queries. In the next N lines, each contains a number representing a subtree with root number X ($1 \leqslant X \leqslant 2^{31} - 1$)</p>
<h3>Output</h3>
<p>There are N lines in total, the i-th of which contains the answer for the i-th query</p>
<h3>Sample Input</h3>
<pre><code class="lang-input1">2
8
10
</code></pre>
<h3>Sample Output</h3>
<pre><code class="lang-output1">1 15
9 11
</code></pre>
<h3>Source</h3>
<p>POJ Monthly,Minkerui</p>
<h2>题意简述</h2>
<p>给出 $x$, 输出在满二叉搜索树(如下图)中, 以 $x$ 为根的子树中的最小结点编号和最大结点编号</p>
<p><img alt="" src="/Users/xuanwu/work/聚聚/中文博客集锦/源数据/博客聚合/tifa-233.com/source/_posts/1.webp"/></p>
<h2>解题思路</h2>
<p>在上图中随便找几个例子就能发现</p>
<ul>
<li><p>最小结点编号即为根编号对应二进制位中将最低位的<code>1</code>换为<code>0</code>后<code>+1</code>的值</p>
<p>如: <code>12 -&gt; 1100</code> 和 <code>10 -&gt; 1010</code>, 对应的最小结点编号均为 <code>9 -&gt; 1001</code></p>
</li>
<li><p>最大结点编号即为根编号对应二进制位中将最低位的<code>1</code>后面的<code>0</code>全部变为<code>1</code>的值</p>
<p>如: <code>12 -&gt; 1100</code> 和 <code>14 -&gt; 1110</code>, 对应的最大结点编号均为 <code>15 -&gt; 1111</code></p>
</li>
</ul>
<p>证明是很容易的</p>
<p>对于取最低位<code>1</code>, 有一个运算想必是我们非常熟悉的, 就是<code>lowbit(x)</code>, 答案和它密切相关</p>
<p>设给定结点编号为<code>x</code>, 则</p>
<ul>
<li>最小结点编号即为<code>x - lowbit(x) + 1</code></li>
<li>最大结点编号即为<code>x + lowbit(x) - 1</code></li>
</ul>
<h2>代码参考</h2>
<p>{% icodeweb cpa_cpp title:POJ_2309 POJ/2309/0.cpp %}</p>
