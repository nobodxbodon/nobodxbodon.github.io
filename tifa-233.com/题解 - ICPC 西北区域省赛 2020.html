<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/icpc-cnwp2020.md">仓库源文</a>，<a href="https://tifa-233.com/archives/icpc-cnwp2020">站点原文</a></h2>
<hr/>
<p>title: 题解 - ICPC 西北区域省赛 2020
categories:</p>
<ul>
<li>算法竞赛</li>
<li>题解</li>
<li>ICPC
tags:</li>
<li>算法竞赛</li>
<li>题解</li>
<li>ICPC</li>
<li>数学</li>
<li>数论</li>
<li>Iverson括号</li>
<li>最小公倍数</li>
<li>三分</li>
<li>爬山算法</li>
<li>图论</li>
<li>团</li>
<li>hash</li>
<li>前缀和</li>
<li>DP</li>
<li>随机化</li>
<li>虚树</li>
<li>LCA
date: 2020-11-01 00:57:43</li>
</ul>
<hr/>
<p>感谢两位神仙队友带我</p>
<p>&lt;!-- more --&gt;</p>
<h2>一些碎碎念</h2>
<p>众所周知, 陕西不在西北地区, 云南广西都在西北地区</p>
<p>比赛体验极差, 开始两分钟才发密码, 比赛还一堆锅, 包括但不限于不给数据范围, 样例错误, SPJ 出锅, 数据弱, 出原题</p>
<p>MD 绝了</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/1.png"/></p>
<h2>题目概览</h2>
<p>| 题号<a href="%E6%89%93*%E7%9A%84%E6%98%AF%E8%BF%98%E6%B2%A1%E5%86%99%E7%9A%84%E9%A2%98">^1</a> | 标题<a href="%E5%B8%A6%E8%B6%85%E9%93%BE%E6%8E%A5%E7%9A%84%E6%98%AF%E6%89%BE%E5%88%B0%E4%BA%86%E5%8E%9F%E9%A2%98%E6%88%96%E5%8E%9F%E5%9E%8B">^2</a>                                                      | 时空限制          | AC / Total | 做法         |
| -------- | ------------------------------------------------------------- | ----------------- | ---------- | ------------ |
| A        | 披荆斩棘                                                      | 1000 ms / 256 MB  | 405 / 551  | 签到         |
| B        | 帅的研究                                                      | 2000 ms / 64 MB   | 11 / 237   | hash         |
| C        | <a href="https://www.luogu.com.cn/problem/P3524">聚会</a>                | 2000 ms / 64 MB   | 7 / 298    | 思维题       |
| *D      | 初春饰利与完美图                                              | 1000 ms / 256 MB  | 0 / 48     |              |
| E        | 御坂妹妹的芯片                                                | 1300 ms / 256 MB  | 215 / 1296 | 签到, 前缀和 |
| F        | 上条当麻与考试                                                | 2500 ms / 512 MB  | 9 / 529    | 找规律       |
| G        | 常盘台中学                                                    | 1000 ms / 256 MB  | 246 / 855  | 签到         |
| H        | Run                                                           | 1000 ms / 512 MB  | 229 / 2109 | 签到         |
| *I      | 小 P 的烦恼                                                   | 3000 ms / 64 MB   | 0 / 7      |              |
| *J      | 领地扩充                                                      | 1000 ms / 256 MB  | 38 / 425   | DP / 搜索    |
| K        | Tate 的魔法                                                   | 2000 ms / 256 MB  | 190 / 1475 | 签到         |
| *L      | <a href="https://codeforces.com/problemset/problem/809/E">藤本树与树</a> | 8000 ms / 512 MB  | 0 / 14     | 虚树         |
| *M      | 作曲家                                                        | 5000 ms / 1024 MB | 2 / 47     |              |</p>
<h2>A - 披荆斩棘</h2>
<h3>Description</h3>
<p>早安, ACMer</p>
<p>一条路落叶无迹</p>
<p>走过我走过你我想问你的足迹</p>
<p>山无言水无语</p>
<p>走过春天 走过四季</p>
<p>走过春天 走过我自己</p>
<p>你已经是一名成熟的 ACMer, 在算法比赛中披荆斩棘, 留下属于你的足迹吧！</p>
<h3>Input</h3>
<p>无</p>
<h3>Output</h3>
<p>ACduck</p>
<h3>Sample Input 1</h3>
<p>无</p>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">ACduck
</code></pre>
<h2>B - 帅的研究</h2>
<h3>Description</h3>
<p>帅最近在研究统计, 嗯, 主要就是看看室友们的消费金额他把室友们每天的消费金额如实的统计在小本本上, 现在他看着室友们的消费记录, 他决定来整个活. 他将室友的消费记录分成很多段, 使得每段恰好有 $k$ 天($k&gt;0$),如果这个室友消费记录统计的天数不是 $k$ 的倍数, 最后一块时间长度小于 $k$ 的时间段就被丢弃了. 帅想知道, 选择什么数字 $k$ 可以得到最多的不同的段. 注意这里的段是可以反转的, 即, 子串 <code>1,2,3</code> 和 <code>3,2,1</code> 被认为是一样的</p>
<h3>Input</h3>
<p>第一行一个正整数 $n$, 表示时间的天数. 第二行 $n$ 个空格隔开的正整数 $a_1,a_2,...a_n$, 描述每天的消费金额</p>
<h3>Output</h3>
<p>第一行两个空格隔开的正整数, 第一个表示能获得的最大不同的段的个数, 第二个表示能获得最大值的 $k$ 的个数. 第二行若干空格隔开的正整数 $k$, 表示所有能够取得最大值的 $k$, 请将 $k$ 按照从小到大的顺序输出</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">21
1 1 1 2 2 2 3 3 3 1 2 3 3 1 2 2 1 3 3 2 1
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">6 1
2
</code></pre>
<h3>Hint</h3>
<p>对于 $100%$ 的数据, $1\leq n\leq 2*10^5$, 且对于所有的 $1\leq i \leq n$, 有 $1 \leq a_i \leq n$</p>
<h3>解题思路</h3>
<blockquote>
<p>比赛时:</p>
<p>我(思索一番): emm 这好像是关于 $k$ 的单峰函数 blablabla...</p>
<p>队友: emm 好像是, 那就三分</p>
<p>我: 等下, 这个好像不是严格单调的, 我想想怎么证</p>
<p>然后直到比赛结束我们都没碰这题</p>
<p>出考场后:</p>
<p>旁边队: 这就是三分+hash 啊 blablabla...</p>
<p>如何看待自己嘴出正解之后把自己否了的行为.txt</p>
</blockquote>
<p>用 hash 是显然的, 之后有两种做法</p>
<ol>
<li><p>暴力枚举 $k$</p>
<p>对于当前的 $k$, 一共有 $\lfloor\frac{n}{k}\rfloor$ 个段, 分别正序和逆序计算 hash 统计个数即可</p>
<p>可以用进制 hash 预处理前缀 hash 和后缀 hash, 这样即可 $O(1)$ 求任意段 hash</p>
<p>我们也可以加个剪枝: 记录最大种数 $S$, 如果当前 $k$ 对应的种数小于 $S$, 则后面所有的 $k$ 对应的种数都必然小于 $S$</p>
<p>时间复杂度为</p>
<p>$$
\Theta\left(n+\sum_{i=1}^n\left\lfloor\frac{n}{i}\right\rfloor \right)=O(n\log n)
$$</p>
</li>
<li><p>三分, 爬山...</p>
<p>显然段的种数是 $k$ 的单峰函数, 所以即使不用三分也可以爬山</p>
<blockquote>
<p>淦我比赛时候咋就没想起来</p>
</blockquote>
<p>也可以加个优化:</p>
<p>我们知道 $\lfloor\frac{n}{k}\rfloor$ 的取值最多只有 $2\lfloor\sqrt n\rfloor$ 种</p>
<p>我们记录这 $2\lfloor\sqrt n\rfloor$ 种对应的最小原象, 再对其三分</p>
<p>举个例子: $n=21$, $\lfloor\frac{n}{k}\rfloor\in{1,2,3,4,5,7,10,21}$, 对应的最小原象构成的集合为 ${11,8,6,5,4,3,2,1}$, 只需在该集合上找种数最大值, 最后小范围暴力枚举答案即可</p>
</li>
</ol>
<h2>C - 聚会</h2>
<h3>Description</h3>
<p>帅打算举行一次聚会. 他自然想要这次聚会成功进行. 此外, 帅确信只要邀请的嘉宾都互相认识就可以了. 他目前在试着写一份邀请名单. 帅有 $n$ 个朋友, 这里 $n$ 可以被 $3$ 整除. 幸运的是, 帅的朋友大部分都互相认识. 并且帅想起了一次他参加的聚会, 那次聚会有 $\frac{2}{3}n$​ 个他的朋友参加, 并且他们都互相认识. 不幸的是, 关于那次聚会的具体细节他不记得了... 总的来说, 他忘了是他的哪些朋友参加了. 帅认为他没有义务举办一个大型聚会, 但他想邀请至少 $\frac{n}{3}$​ 个他的朋友. 他不知道邀请谁, 所以请你帮他</p>
<h3>Input</h3>
<p>输入的第一行包含两个整数 $n, m$, 表示帅的朋友数和互相认识的朋友对数</p>
<p>接下来 $m$ 行, 每行两个整数 $a_j,b_j$, 表示朋友 $a_j,b_j$​ 互相认识. 每一对数最多在输入中出现一次</p>
<h3>Output</h3>
<p>按编号升序, 输出一行 $\frac{n}{3}$​​ 个数, 表示帅要邀请的朋友编号. 如果有多组解, 输出任意一组均可</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">6 10
2 5
1 4
1 5
2 4
1 3
4 5
4 6
3 5
3 4
3 6
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">2 4
</code></pre>
<h3>Hint</h3>
<p>对于全部数据, $3\leq n\leq 3000,~{ \frac{2}{3}n(\frac{2}{3}n-1)\over2}\leq m\leq\frac{n(n-1)}{2},~1\leq a_i&lt;b_i\leq n$</p>
<h3>题意简述</h3>
<p>给定一张 n 个点 m 条边的图($3\mid n$), 保证存在一个大小为 $\frac{2}{3}n$ 的团, 要求输出一个大小为 $\frac{n}{3}$​ 的团</p>
<blockquote>
<p>来自 <a href="https://www.luogu.com.cn/problem/P3524">https://www.luogu.com.cn/problem/P3524</a></p>
</blockquote>
<h3>解题思路</h3>
<blockquote>
<p>比赛时上来就交了发并查集, 然后自然没过</p>
<p>后来想了个假做法交了三发没过就扔了</p>
<p>不过在洛谷上能过就离谱</p>
</blockquote>
<hr/>
<blockquote>
<p>2020.11.02 upd: 出题人没写 spj 就更离谱</p>
</blockquote>
<p>先说说正解</p>
<p>设数组<code>vis[1..n]</code>, 其中<code>vis[i]</code>表示点<code>i</code>是否被标记</p>
<ol>
<li>令<code>vis[i]=0</code>, $\forall i\in[1,n]\cap\mathbb{N}$</li>
<li>从<code>1</code>到<code>n</code>枚举<code>i</code><ol>
<li>如果<code>vis[i]==0</code>, 则<ol>
<li>从<code>i+1</code>到<code>n</code>枚举<code>j</code></li>
<li>如果<code>vis[j]==1</code>且<code>i</code>,<code>j</code>间没有边, 则<ol>
<li><code>vis[i]=vis[j]=1</code> (因为图足够稠密, 所以这样是可行的)</li>
<li>跳出该循环</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>输出 $n\over 3$ 个满足<code>vis[i]==0</code>的数<code>i</code></li>
</ol>
<p>然后说说我们的假做法</p>
<p>统计每个结点的度数, 之后按度数降序排序, 取前 $n\over 3$ 个点按编号升序排序后输出</p>
<p>为什么是假做法呢</p>
<p>我们可以构造这样的图</p>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show sample&lt;/font&gt;&lt;/summary&gt;</p>
<pre><code class="language-input1">9 24
1 3
1 5
1 6
2 5
2 6
3 4
3 5
5 6
2 1
2 3
6 3
4 1
2 4
4 5
4 6
7 9
8 9
9 3
9 2
9 5
9 4
9 6
1 7
1 8
</code></pre>
<p>&lt;/details&gt;</p>
<p>画出来是这样的:</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/s-C-1.png"/></p>
<p>我们发现 $1$ 和 $9$ 的度是 $7$, $7$ 和 $8$ 的度是 $2$, 其余点的度是 $6$</p>
<p>按这样的做法就会输出</p>
<pre><code class="language-output1">1 x 9
</code></pre>
<p>其中 $x\in{2,3,4,5,6}$</p>
<p>而 $1$ 和 $9$ 没有边, 所以这是错误答案</p>
<p>但我们看图发现, 如果改成在前 $2n\over 3$ 个点里随机取 $n\over3$ 的点就有很大概率正确, 所以加个随机化取点多交几发就过了, 也可以加个校验多次随机化取点(Las Vegas 随机)</p>
<h3>复杂度</h3>
<ul>
<li>正解: $O(n^2)$</li>
<li>乱搞: $O(n\log n)$</li>
</ul>
<h3>代码参考</h3>
<ul>
<li><p>正解</p>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:icpc-cnwp2020_C_0 misc/icpc-cnwp2020/C/0.cpp %}</p>
<p>&lt;/details&gt;</p>
</li>
<li><p>乱搞</p>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:icpc-cnwp2020_C_1 misc/icpc-cnwp2020/C/1.cpp %}</p>
<p>&lt;/details&gt;</p>
</li>
</ul>
<h2>D - 初春饰利与完美图</h2>
<h3>Description</h3>
<p>初春饰利喜欢画画. 作为学园都市的最强黑客, 她的数据结构学的很好. 她经常画大量的有向图和无向图. 最近她定义了一个新的图类型——完美图. 如果一个无向图的所有点都只被 $1$ 个环经过且只被经过 $1$ 遍, 那么这个图就可以被称为完美图</p>
<p>她已经画了图的点和部分边. 但是这并没有结束. 怎么通过添加边使这个图变成完美图才是最重要的. 初春非常严格, 她不仅要求你的答案是数量最少, 并且是字典序最小的边集</p>
<h3>Input</h3>
<p>第一行包含两个整数 $n$ 和 $m$($1 \leq n \leq 50, 0 \leq m \leq 2500$), 代表总共的点和初春已经画的边数. 接下来 $m$ 行, 每行有两个整数 $x_i$​ 和 $y_i$($1 \leq x_i,y_i \leq n$), 代表初春已经画的边. 初春的初始图可能包括重边和自环</p>
<h3>Output</h3>
<p>第一行输出<code>YES</code>或者<code>NO</code>: 代表能不能构建一个完美图. 如果能输出<code>YES</code>, 并且在接下来一行输出一个整数 $k$, 代表了需要添加的边的数量. 再在接下来 $k$ 行, 每行输出两个整数 $x_j$​ 和 $y_j$​, 代表这些边. 结果可能包含重边和自环, $k$ 可能等于 $0$</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">3 2
1 2
2 3
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">YES
1
1 3
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">2 0
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">YES
2
1 2
1 2
</code></pre>
<h3>Hint</h3>
<p>边集 $(x_1,y_1),(x_2,y_2),...,(x_n,y_n),~x_i\leq y_i$ 字典序小于边集 $(u_1,v_1),(u_2,v_2),...,(u_n,v_n),~u_i\leq v_i$​ 的条件是序列 $x_1,y_1,x_2,y_2,...,x_n,y_n$ 字典序小于序列 $u_1,v_1,u_2,v_2,...,u_n,v_n$</p>
<h3>题意简述</h3>
<h3>解题思路</h3>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
<h2>E - 御坂妹妹的芯片</h2>
<h3>Description</h3>
<p>一方通行把许多御坂美琴的克隆人杀了并且获得许多芯片(数量为 $n$). 一方通行把芯片编号从 $1$ 到 $n$. 摧毁每个芯片需要花 $v_i$​ 的资源. 一方想要考考你, 他会问以下两类问题:</p>
<ol>
<li>他会告诉你两个整数, $l$ 和 $r$($1 \leq l \leq r \leq n$). 你必须告诉他 $\sum_{i=l}^r v_i$</li>
<li>让 $u_i$​ 成为第 $i$ 少花费资源的芯片(指在非降序的排序下, 第 $i$ 个芯片). 这次他依然告诉你两个整数, $l$ 和 $r$($1 \leq l \leq r \leq n$). 你必须告诉他 $\sum_{i=1}^r u_i$​​</li>
</ol>
<h3>Input</h3>
<p>第一行包含一个整数 $n(1 \leq n \leq 10^5)$</p>
<p>第二行包含 $n$ 个整数: $v_1,v_2,v_3,....,v_n(1 \leq v_i \leq 10^9)$, 代表摧毁芯片需要的资源</p>
<p>第三行包含一个整数 $m(1 \leq m \leq 10^5)$, 代表一方的问题个数. 接下来 $m$ 行, 每行包含三个整数 $\textrm{type}$, $l$ 和 $r$($1\leq l\leq r\leq n;~1\leq \textrm{type}\leq 2$), 如果 $\textrm{type}=1$ 你需要回复第一个问题, 如果 $\textrm{type}=2$ 你需要回复第二个问题</p>
<h3>Output</h3>
<p>输出 $m$ 行. 每行包含一个整数, 代表对一方问题的答案</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">6
6 4 2 7 2 7
3
2 3 6
1 3 4
1 1 6
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">24
9
28
</code></pre>
<h3>题意简述</h3>
<p>给一组数 $v_1,v_2,\dots,v_n$, $m$ 组询问, 每次询问以下之一</p>
<ol>
<li>$\sum_{i=l}^r v_i$</li>
<li>$\sum_{i=l}^r u_i$, 其中 $u_1,u_2,\dots,u_n$ 是 $v_1,v_2,\dots,v_n$ 按升序排序后的数列</li>
</ol>
<h3>解题思路</h3>
<p>前缀和, 没啥好说的</p>
<h2>F - 上条当麻与考试</h2>
<h3>Description</h3>
<p>上条当麻今天很早就来到学校, 因为他有一场数学考试, 没错学园都市也得学数学</p>
<p>这场测试是关于基础的加减法的. 小萌老师去照顾受伤的茵蒂克丝了, 没来的时间出题目</p>
<p>所以今天的测试只有 $1$ 道题</p>
<p>这道题的第一行有 $n$ 个整数. 当麻必须对这每对相邻整数进行交替的加减法, 并在下一行写下它们的和或差. 他必须重复这些步骤直到最后一行只剩下 $1$ 个整数. 题目要求第一次先加</p>
<p>注意哦, 如果在上一行最后是加法, 那么这一行应该是从减法开始, 反之亦然</p>
<p>如果最后的结果是对的, 当麻会得到满分, 如果是错的, 那么他只能得到零蛋</p>
<p>请你计算正确答案给当麻参考参考, 这个数字会很大, 所以最后结果请模 $10^9+7$</p>
<h3>Input</h3>
<p>第一行输入一个整数 $n(1 \leq n \leq 200000)$, 代表题目第一行的数字个数</p>
<p>接下来一行输入 $n$ 个整数 $a_1,a_2,a_3,...,a_n$($1 \leq a_i \leq 10^9$)</p>
<h3>Output</h3>
<p>输出结果模 $10^9+7$ 的答案(非负余数)</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">5
3 6 9 12 15
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">36
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">4
3 7 5 2
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">1000000006
</code></pre>
<h3>Hint</h3>
<p>$$
\global\def\add#1#2{\textcolor{00ff00}{\overset{\sf\bf{ #1+#2}}{\sf\bf{+}}}}
\global\def\minus#1#2{\textcolor{ff0000}{\overset{\sf\bf{ #1-#2}}{\sf\bf{-}}}}
\begin{matrix}
\sf\bf3&amp; &amp;\sf\bf6&amp; &amp;\sf\bf9&amp; &amp;\sf\bf12&amp; &amp;\sf\bf15\
&amp;\add 3 6&amp; &amp;\minus 6 9&amp; &amp;\add 9 {12}&amp; &amp;\minus{12}{15}&amp; \
&amp;\sf\bf9&amp; &amp;\sf\bf-3&amp; &amp;\sf\bf21&amp; &amp;\sf\bf-3&amp; \
&amp; &amp;\add 9 {(-3)}&amp; &amp;\minus{(-3)}{21}&amp; &amp;\add{21}{(-3)}&amp; &amp; \
&amp; &amp;\sf\bf6&amp; &amp;\sf\bf-24&amp; &amp;\sf\bf18&amp; &amp; \
&amp; &amp; &amp;\minus 6 {(-24)}&amp; &amp;\add{(-24)}{18}&amp; &amp; &amp; \
&amp; &amp; &amp;\sf\bf30&amp; &amp;\sf\bf-6&amp; &amp; &amp; \
&amp; &amp; &amp; &amp;\minus{30}{(-6)}&amp; &amp; &amp; &amp; \
&amp; &amp; &amp; &amp;\sf\bf36&amp; &amp; &amp; &amp; \
\end{matrix}
$$</p>
<h3>解题思路</h3>
<p>设当前行的数为 $a_1,a_2,\dots,a_n$</p>
<p>我们注意到如果 $n$ 为奇数, 则经过一轮运算后变为 $a_1+a_2,a_2-a_3,...,a_{n-1}-a_n$, 当前行长度变为偶数</p>
<p>如果 $n$ 为偶数, 则经过两轮运算后变为 $a_1+a_3,a_2+a_4,...,a_{n-2}+a_n$, 长度仍为偶数, 且下一轮运算从减法开始</p>
<p>所以这个规律可细分为 4 种情况, 不过不细分也行</p>
<p>最后我们会发现可按照类似杨辉三角的思路解决</p>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:icpc-cnwp2020_F misc/icpc-cnwp2020/F/1.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>G - 常盘台中学</h2>
<h3>Description</h3>
<p>在学园都市常盘台高中, 学生有五种超能力等级从 $1$ 到 $5$, 学生权力被等级所量化</p>
<p>在过去, 常盘台中学分为两类学生, $\texttt{science}$ 侧学生和 $\texttt{magic}$ 侧学生. 这两类学生的人数都是 $n$ 个</p>
<p>校长想要重新分配 $\texttt{science}$ 侧和 $\texttt{magic}$ 侧的学生, 使他们势均力敌. 用另一种话说就是让他们两侧所有等级的学生人数相等</p>
<p>为了实现这一点, 校长实行了交换制度, 在两侧学生中各选一名进行交换. 当然每次交换需要耗费校长一枚炮姐硬币</p>
<p>请问校长至少要多少枚炮姐硬币才能平衡 $\texttt{science}$ 侧和 $\texttt{magic}$ 侧？</p>
<h3>Input</h3>
<p>第一行输入一个整数 $n(1 \leq n \leq 100)$, 代表了两侧的学生个数</p>
<p>第二行输入一串数字 $a_1,a_2,a_3...,a_n$($1 \leq a_i \leq 5$), 代表 $\texttt{science}$ 侧的每位超能力等级</p>
<p>第三行输入一串数字 $b_1,b_2,b_3...,b_n$($1 \leq b_i \leq 5$), 代表 $\texttt{magic}$ 侧的每位超能力等级</p>
<h3>Output</h3>
<p>如果校长能平衡, 输出校长最少花费的炮姐硬币数量. 如果不能, 请输出 $-1$</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">4
5 4 4 4
5 5 4 5
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">1
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">1
5
3
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">-1
</code></pre>
<h3>解题思路</h3>
<p>设 $(c_i,d_i)=\sum_{j=1}^n([a_j=i],[b_j=i])\in\mathbb{Z}^2,~i=1,2,3,4,5$</p>
<p>如果 $2\nmid c_i+d_i,~i=1,2,3,4,5$, 则一定无解</p>
<p>否则答案就是 $\sum_{i=1}^5\frac{|c_i-d_i|}{2}$</p>
<h2>H - Run</h2>
<h3>Description</h3>
<p>Sports are definitely an integral part of the students' lives. In response to the school's call, the students decided to run in the morning. However, for various reasons, it was not practical to get up early to run every day, so Eric decided to run once a day. In other words, if Eric woke up early one day to go running, he would take $a-1$ day off, and then continue to run on day $a$, and so on</p>
<p>Eric's good friends, Delia and Agnes, were so inspired by Eric's commitment to exercise that they decided to do their own morning runs. In order to suit their own circumstances, Delia decided to get up early and run every day $b$, while Agnes decided to get up early and run every day $c$. One morning, Eric, Delia, Agnes and Eric decided to go for a run</p>
<p>One morning, Eric, Delia and Agnes met during their early morning run, and they were very excited and encouraged each other to complete a perfect morning run together. For ease of presentation, let's count the day the three students met as day $0$. Assuming that the three students run the same route and time period each time, they want to know how many days will pass before they meet on the next run. Since none of them can count, they want you to tell them the answer</p>
<h3>Input</h3>
<p>Enter a line containing three positive integers $a,b,c$, which means Eric runs every $a$, Delia runs every $b$ and Agnes runs every $c$ morning</p>
<h3>Output</h3>
<p>The output consists of one line with a positive integer $x$, indicating that the three students will meet on day $x$ next time</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">2 3 5
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">30
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">3 4 6
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">12
</code></pre>
<h3>Sample Input 3</h3>
<pre><code class="language-input3">10 100 1000
</code></pre>
<h3>Sample Output 3</h3>
<pre><code class="language-output3">1000
</code></pre>
<h3>Hint</h3>
<p>$1\leq a,b,c\leq 100000$</p>
<h3>题意简述</h3>
<h3>解题思路</h3>
<blockquote>
<p>比赛时:</p>
<p>我们仨: wc 英文题</p>
<p>1 秒后</p>
<p>我: 等下我看眼样例...emm 这不就把仨数乘起来, 啊不对, 求个 lcm 就完事了</p>
<p>真·面向样例编程</p>
</blockquote>
<p>就是求三个数的 lcm, 搞不懂为啥开了 512MB 空间</p>
<h2>I - 小 P 的烦恼</h2>
<h3>Description</h3>
<p>小 P 在 A 城的首都拥有一家商店. 最近在首都的犯罪活动有所增加, 因此小 P 正在考虑在其商店的仓库中建立更好的安全性</p>
<p>仓库可以表示为具有 $n$ 行和 $m$ 列的矩阵. 矩阵的每个元素均为 <code>.</code>(一片空白区域)或 <code>x</code> (一堵墙)</p>
<p>小 P 希望雇用一些警卫人员(可能为 $0$ )来监视仓库. 每个守卫将在矩阵的某个单元中, 并将保护每个单元在其自己单元的右侧, 每个单元在其自己单元的底部, 直到最近的墙为止. 更正式地讲, 如果守卫站在牢房 $(x_0, y_0)$ 中, 那么如果满足以下所有条件, 他就会保护牢房</p>
<p>$(x_1, y_1)$ 中:</p>
<ol>
<li>$(x_1, y_1)$ 是一个空单元格</li>
<li>$x_0 = x_1$ 且 $y_0 \leq y_1$ 或 $x_0 \leq x_1$ 且 $y_0 = y_1$</li>
<li>$(x_0, y_0)$ 和 $(x_1, y_1)$ 之间没有墙. 这些单元之间可以有一个守卫, 守卫可以互相看</li>
</ol>
<p>警卫只能放置在空的牢房中(并且只能保护空的牢房). 放置警卫的计划是将放置警卫的一组单元格(当然, 如果第一个计划中包含至少一个单元格, 但第二个计划中不包含至少一个单元格, 则两个计划是不同的, 反之亦然). 如果不多于一个不受保护的空单元, 小 P 认为该计划是合适的</p>
<p>小 P 想知道合适计划的数量. 由于它可能非常大, 因此必须模 $10^7$ 输出</p>
<h3>Input</h3>
<p>第一行包含两个数字 $n$ 和 $m$——仓库的长度和宽度($1 \leq n, m \leq250, 1\leq nm\leq 250$)</p>
<p>接着是 $n$ 行, 第 $i$ 行包含一个由 $m$ 个字符组成的字符串——代表仓库的矩阵的第 $i$ 行. 每个字符要么是 <code>.</code> , 要么是 <code>x</code></p>
<h3>Output</h3>
<p>对于每组测试数据, 一行输出一个整数代表答案</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">1 3
.x.
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">3
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">2 2
..
..
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">10
</code></pre>
<h3>题意简述</h3>
<h3>解题思路</h3>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
<h2>J - 领地扩充</h2>
<h3>Description</h3>
<p>Eric 喜欢一款游戏, 游戏是在一个长方形的场地上玩. 在游戏过程中, Eric 可以扩充他的领地, 每一次(个)扩充都会将其中一个领地的大小扩大一定的倍数. 形式上, 有 $n$ 次(个)扩充, 其中第 $i$ 次(个)扩充将宽度或长度(由 Eric 选择)乘以 $a_i$​. 每从次(个)扩充不能使用一次以上, 扩充可以以任何顺序使用</p>
<p>现在 Eric 的领地的大小为 $h\times w$. 他想把它放大, 以便可以在上面放置一个大小为 $a\times b$ 的矩形(沿宽或沿长, 边与场边平行). 求达到 Eric 的目标所需的最小扩充数</p>
<h3>Input</h3>
<p>第一行包含五个整数 $a,b,h,w$ 和 $n$($1\leq a,b,h,w,n\leq 100000$)——需要放置的矩形的大小, 领地的初始大小和可扩充次数</p>
<p>第二行包含 $n$ 个整数 $a_1, a_2, ..., a_n$($2\leq a_i\leq 100000$), 其中 $a_i$​ 等于应用第 $i$ 次扩充时 $a$ 面乘以的整数</p>
<h3>Output</h3>
<p>打印达到 Eric 目标所需的最小扩充数. 如果不可能将矩形放置在所有延长线的区域上, 则打印 $-1$; 如果可以将矩形放置在初始区域上, 则打印 $0$</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">3 3 2 4 4
2 5 4 10
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">1
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">3 4 1 1 3
2 3 2
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">3
</code></pre>
<h3>题意简述</h3>
<h3>解题思路</h3>
<blockquote>
<p>一个队友写 DP 漏了种情况, 另一个队友写了个折半搜索然后<code>sort</code>用错了</p>
<p>2020.11.02 upd: 出题人造了个锤子数据, 瞎贪心(最小边乘最大数乘到满足要求)都能过</p>
</blockquote>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
<h2>K - Tate 的魔法</h2>
<h3>Description</h3>
<p>Tate 对魔法非常感兴趣, 他可以通过超自然力量的干预和解释了任何奇怪而怪异的现象. 但是谁能想到, 即使按固定的数字排列, Tate 也能看到美丽而神奇的东西. Tate 偶然拿到了一块纸, 上面写着一系列数字. 他立即发现这组数字不是随机的. 经过一系列研究的结果, Tate 得出了一个奇妙的属性, 这个神奇的数组应该具有这个性质: 如果这个数组中的最大值和最小值一样的, 则说明这组子数组是有魔力的. Tate 决定与你分享这个杰出的发现, 但他请求你的帮助. 所以你必须完成他的工作. 你所要做的就是数写在纸上的原始数字数组有多少个神奇的子数组. 子数组定义为连续元素的非空序列</p>
<h3>Input</h3>
<p>输入数据的第一行包含一个整数 $n$($1 \leq n \leq 10^5$). 第二行 $n$ 个数代表原始数组中的值 $a_1,a_2,....a_n$($-10^9 \leq a_i \leq 10^9$)</p>
<h3>Output</h3>
<p>输出为一行: 有多少个有魔力的子数组</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">4
2 1 1 4
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">5
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">5
-2 -2 -2 0 1
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">8
</code></pre>
<h3>题意简述</h3>
<p>给一组数 $a_1,a_2,\dots,a_n$, 我们把相邻且值相同的数合成一段并统计长度, 得到新数列 $l_1,l_2,\dots,l_m$, 求 $\sum_{i=1}^m\frac{l_i(l_i+1)}{2}$</p>
<p>如对于样例 2, 可分为 ${-2,-2,-2},{0},{1}$,则 $l_1=3,l_2=1,l_3=1$</p>
<h3>解题思路</h3>
<p>$O(n)$ 直接求</p>
<h2>L - 藤本树与树</h2>
<h3>Description</h3>
<p>镰池和马和藤本树受够了学校无聊的时光, 于是他们决定玩一场游戏</p>
<p>藤本树发现了一颗带有 $n$ 个结点且从结点 $1$ 到 $n$ 的树. 这棵树是无向无环图. 每个树的结点 $v$ 都有一个值 $a_v$. 每个结点的值都不相同并且值的范围在 $1$ 到 $n$</p>
<p>这个游戏是这样的, 镰池和马选择一个结点 $u$, 然后轮到藤本树的回合, 藤本树选择剩下结点中的一个 $v$. 很明显总共有 $n(n-1)$ 种选法. 之后计算函数值 $f(u,v)=\varphi(a_ua_v)d(u,v)$, $\varphi(x)$ 是欧拉函数, $d(x,y)$ 是点 $x$ 和 $y$ 的在树上的最短距离</p>
<p>很快这个游戏又变得无聊起来, 于是他们又想了个新玩法, 对于所有可能的 $u$ 和 $v$, 计算它们的所有函数 $f$ 的期望值. 让这个值以一个不可约分数 $P\over Q$​ 来表示. 为了更有趣一点, 计算 $PQ^{-1}\pmod{10^9+7}$ 的值</p>
<h3>Input</h3>
<p>第一行包含一个整数 $n$($2 \leq n \leq 2\times 10^5$), 代表树的点数</p>
<p>第二行包含 $n$ 个整数 $a_1,a_2,a_3,....,a_n$($1 \leq a_i \leq n$), 代表树上这些点的值</p>
<p>接下来 $n-1$ 行包含 $2$ 个整数 $x$ 和 $y$($1\leq x,y\leq n$), 代表这颗树的连边</p>
<h3>Output</h3>
<p>输出一个值等于 $PQ^{-1}\pmod{10^9+7}$</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">3
1 2 3
1 2
2 3
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">333333338
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">5
5 4 3 1 2
3 5
1 2
4 3
2 5
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">8
</code></pre>
<h3>Hint</h3>
<p>欧拉函数是小于或等于的正整数中与互质的数的数目</p>
<p>第一个样例:</p>
<ul>
<li>$u=1,v=2,f(1,2)=\varphi(a_1a_2)d(1,2)=\varphi(1\cdot2)\cdot1=\varphi(2)=1$</li>
<li>$u=2,v=1,f(2,1)=f(1,2)=1$</li>
<li>$u=1,v=3,f(1,3)=\varphi(a_1a_3)d(1,3)=\varphi(1\cdot3)\cdot2=2\varphi(3)=4$</li>
<li>$u=3,v=1,f(3,1)=f(1,3)=4$</li>
<li>$u=2,v=3,f(2,3)=\varphi(a_2a_3)d(2,3)=\varphi(2\cdot3)\cdot1=\varphi(6)=2$</li>
<li>$u=3,v=2,f(3,2)=f(2,3)=2$</li>
</ul>
<p>所以期望值为 $\frac{1}{6}(1+1+4+4+2+2)=\frac{14}{6}=\frac{7}{3}$</p>
<p>所以最后的值就是 $7\cdot 3^{-1}\equiv 7\cdot 333333336\equiv 333333338\pmod{10^9+7}$</p>
<h3>题意简述</h3>
<p>给定一棵 $n$ 个结点的树, 每个点有一个权值 $a[i]$, 保证 $a[i]$ 是一个 $1..n$ 的排列. 求 $\frac{1}{n(n-1)}\sum_{i=1}^n\sum_{j=1}^n\varphi(a_i<em>a_j)</em>\operatorname{dist}(i,j)$ 其中 $\varphi(x)$ 是欧拉函数, $\operatorname{dist}(i,j)$ 表示 $i,j$ 两个结点在树上的距离</p>
<blockquote>
<p>来自 <a href="https://www.luogu.com.cn/problem/CF809E">https://www.luogu.com.cn/problem/CF809E</a></p>
</blockquote>
<h3>解题思路</h3>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
<h2>M - 作曲家</h2>
<h3>Description</h3>
<p>Jasmine 是一位作曲家, 最近她录制了两首非常受欢迎的歌曲. 现在她有很多粉丝在等着她的新歌. 这次 Jasmine 想为她的歌曲组成四个旋律. Jasmine 有一张纸, 上面写着 $n$ 个数. 她想取 $4$ 个这样的非空无交集的子序列使得它们都能组成旋律且长度之和是最大的</p>
<p>子序列是指在不改变其余元素顺序的情况下, 通过删除一些元素可以从另一个序列中得到的序列</p>
<p>当每个相邻的两个音符的绝对值相差 $1$ 或模 $7$ 同余时, 子序列形成一个旋律</p>
<p>你应该写一个程序, 计算四个非空的不相交的子序列的最大长度之和, 使它们全部形成一个旋律</p>
<h3>Input</h3>
<p>第一行包含一个整数 $n$($4 \leq n \leq 3000$)第二行包含 $n$ 个整数 $a_1,a_2,....a_n$​($1 \leq a_i \leq 10^5$)——写在纸上的笔记</p>
<h3>Output</h3>
<p>输出这四个非空, 非相交的子序列的最大长度和, 使它们全部组成旋律</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">4
1 3 5 7
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">4
</code></pre>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">4
1 1 1 1
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">4
</code></pre>
<h3>题意简述</h3>
<h3>解题思路</h3>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
