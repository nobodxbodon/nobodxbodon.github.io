<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/cf1779.md">仓库源文</a>，<a href="https://tifa-233.com/cf1779">站点原文</a></h2>
<hr/>
<p>title: "比赛记录 - Hello 2023"
date: 2023-01-04 02:10:31
categories:</p>
<ul>
<li>算法竞赛
tags:</li>
<li>算法竞赛</li>
<li>Codeforces</li>
<li>交互题</li>
<li>构造</li>
<li>贪心</li>
<li>数学</li>
<li>字符串</li>
<li>数据结构</li>
<li>DP</li>
<li>图论</li>
<li>竞赛图</li>
<li>Hamilton路</li>
<li>拓扑排序</li>
<li>强连通分量</li>
<li>排序</li>
<li>位运算</li>
<li>树</li>
<li>最短路</li>
<li>暴力</li>
</ul>
<hr/>
<p><a href="https://codeforces.com/contest/1779">比赛链接</a></p>
<p>进度: 5 / 8</p>
<p>&lt;!-- more --&gt;</p>
<h2>A - Hall of Fame</h2>
<p>Thalia is a Legendary Grandmaster in chess. She has $n$ trophies in a line numbered from $1$ to $n$ (from left to right) and a lamp standing next to each of them (the lamps are numbered as the trophies)</p>
<p>A lamp can be directed either to the left or to the right, and it illuminates all trophies in that direction (but not the one it is next to). More formally, Thalia has a string $s$ consisting only of characters '<code>L</code>' and '<code>R</code>' which represents the lamps' current directions. The lamp $i$ illuminates:</p>
<ul>
<li>trophies $1,2,\ldots, i-1$ if $s_i$ is 'L';</li>
<li>trophies $i+1,i+2,\ldots, n$ if $s_i$ is 'R'</li>
</ul>
<p>She can perform the following operation <strong>at most</strong> once:</p>
<ul>
<li>Choose an index $i$ ($1 \leq i &lt; n$);</li>
<li>Swap the lamps $i$ and $i+1$ (without changing their directions). That is, swap $s_i$ with $s_{i+1}$</li>
</ul>
<p>Thalia asked you to illuminate all her trophies (make each trophy illuminated by at least one lamp), or to tell her that it is impossible to do so. If it is possible, you can choose to perform an operation or to do nothing. Notice that lamps <strong>cannot</strong> change direction, it is only allowed to swap adjacent ones</p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 10,000$). The description of the test cases follows</p>
<p>The first line of each test case contains a positive integer $n$ ($2 \leq n \leq 100,000$) — the number of trophies</p>
<p>The second line of each test case contains a string $s$ of length $n$ consisting only of characters '<code>L</code>' and '<code>R</code>' — the $i$-th character describes the direction of the $i$-th lamp</p>
<p>It is guaranteed that the sum of $n$ over all test cases does not exceed $100,000$</p>
<h3>Output</h3>
<p>For each test case print $-1$ if it is impossible to illuminate all trophies by performing one operation (or doing nothing). Otherwise, print $0$ if you choose not to perform the operation (i.e., the trophies are illuminated by the initial positioning of the lamps), or an index $i$ ($1 \leq i &lt; n$) if you choose to swap lamps $i$ and $i+1$</p>
<p>If there are multiple answers, print any</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="language-input1">6
2
LL
2
LR
2
RL
2
RR
7
LLRLLLR
7
RRLRRRL
</code></pre>
<h4>output</h4>
<pre><code class="language-output1">-1
1
0
-1
3
6
</code></pre>
<h3>Note</h3>
<p>In the first example, it is possible to swap lamps $1$ and $2$, or do nothing. In any case, the string "<code>LL</code>" is obtained. Not all trophies are illuminated since trophy $2$ is not illuminated by any lamp — lamp $1$ illuminates nothing and lamp $2$ illuminates only the trophy $1$</p>
<p>In the second example, it is necessary to swap lamps $1$ and $2$. The string becomes "<code>RL</code>". Trophy $1$ is illuminated by lamp $2$ and trophy $2$ is illuminated by lamp $1$, hence it is possible to illuminate all trophies</p>
<p>In the third example, all trophies are initially illuminated — hence, not performing any operation is a valid solution</p>
<p>In the last two examples performing swaps is not necessary as all trophies are illuminated initially. But, the presented solutions are also valid</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:CodeForces_1779A CodeForces/1779A/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>B - MKnez's ConstructiveForces Task</h2>
<p>MKnez wants to construct an array $s_1,s_2, \ldots , s_n$ satisfying the following conditions:</p>
<ul>
<li>Each element is an integer number different from $0$;</li>
<li>For each pair of adjacent elements their sum is equal to the sum of the whole array</li>
</ul>
<p>More formally, $s_i \neq 0$ must hold for each $1 \leq i \leq n$. Moreover, it must hold that $s_1 + s_2 + \cdots + s_n = s_i + s_{i+1}$ for each $1 \leq i &lt; n$</p>
<p>Help MKnez to construct an array with these properties or determine that it does not exist</p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 100$). The description of the test cases follows</p>
<p>The only line of each test case contains a single integer $n$ ($2 \leq n \leq 1000$) — the length of the array</p>
<h3>Output</h3>
<p>For each test case, print "<code>YES</code>" if an array of length $n$ satisfying the conditions exists. Otherwise, print "<code>NO</code>". If the answer is "<code>YES</code>", on the next line print a sequence $s_1,s_2, \ldots, s_n$ satisfying the conditions. Each element should be a non-zero integer in the range $[-5000,5000]$, i. e. $-5000 \leq s_i \leq 5000$ and $s_i \neq 0$ should hold for each $1 \leq i \leq n$</p>
<p>It can be proved that if a solution exists then there also exists one which satisfies the additional constraints on the range</p>
<p>If there are several correct answers, print any of them</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="language-input1">2
2
3
</code></pre>
<h4>output</h4>
<pre><code class="language-output1">YES
9 5
NO
</code></pre>
<h3>Note</h3>
<p>In the first test case, $[9,5]$ is a valid answer since $9+5$ (the sum of the two adjacent elements $s_1+s_2$) is equal to $9+5$ (the sum of all elements). Other solutions include $[6,-9], [-1,-2], [-5000,5000], \ldots$</p>
<p>For the second test case, let us show why some arrays <strong>do not</strong> satisfy the constraints:</p>
<ul>
<li>$[1,1,1]$ — $s_1+s_2 = 1+1 = 2$ and $s_1+s_2+s_3=1+1+1 = 3$ differ;</li>
<li>$[1,-1,1]$ — $s_1+s_2=1+(-1)=0$ and $s_1+s_2+s_3=1+(-1)+1 = 1$ differ;</li>
<li>$[0,0,0]$ — The array $s$ cannot contain a $0$</li>
</ul>
<p>This is not a proof, but it can be shown that the answer is "NO"</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:CodeForces_1779B CodeForces/1779B/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>C - Least Prefix Sum</h2>
<p>Baltic, a famous chess player who is also a mathematician, has an array $a_1,a_2, \ldots, a_n$, and he can perform the following operation several (possibly $0$) times:</p>
<ul>
<li>Choose some index $i$ ($1 \leq i \leq n$);</li>
<li>multiply $a_i$ with $-1$, that is, set $a_i := -a_i$</li>
</ul>
<p>Baltic's favorite number is $m$, and he wants $a_1 + a_2 + \cdots + a_m$ to be the smallest of all non-empty prefix sums. More formally, for each $k = 1,2,\ldots, n$ it should hold that</p>
<p>$$
a_1 + a_2 + \cdots + a_k \geq a_1 + a_2 + \cdots + a_m.
$$</p>
<p>Please note that multiple smallest prefix sums may exist and that it is only required that $a_1 + a_2 + \cdots + a_m$ is one of them</p>
<p>Help Baltic find the minimum number of operations required to make $a_1 + a_2 + \cdots + a_m$ the least of all prefix sums. It can be shown that a valid sequence of operations always exists</p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 10,000$). The description of the test cases follows</p>
<p>The first line of each test case contains two integers $n$ and $m$ ($1 \leq m \leq n \leq 2\cdot 10^5$) — the size of Baltic's array and his favorite number</p>
<p>The second line contains $n$ integers $a_1,a_2, \ldots, a_n$ ($-10^9 \leq a_i \leq 10^9$) — the array</p>
<p>It is guaranteed that the sum of $n$ over all test cases does not exceed $2\cdot 10^5$</p>
<h3>Output</h3>
<p>For each test case, print a single integer — the minimum number of required operations</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="language-input1">6
4 3
-1 -2 -3 -4
4 3
1 2 3 4
1 1
1
5 5
-2 3 -5 1 -20
5 2
-2 3 -5 -5 -20
10 4
345875723 -48 384678321 -375635768 -35867853 -35863586 -358683842 -81725678 38576 -357865873
</code></pre>
<h4>output</h4>
<pre><code class="language-output1">1
1
0
0
3
4
</code></pre>
<h3>Note</h3>
<p>In the first example, we perform the operation $a_4 := -a_4$. The array becomes $[-1,-2,-3,4]$ and the prefix sums, $[a_1, \ a_1+a_2, \ a_1+a_2+a_3, \ a_1+a_2+a_3+a_4]$, are equal to $[-1,-3,-6,-2]$. Thus $a_1 + a_2 + a_3=-6$ is the smallest of all prefix sums</p>
<p>In the second example, we perform the operation $a_3 := -a_3$. The array becomes $[1,2,-3,4]$ with prefix sums equal to $[1,3,0,4]$</p>
<p>In the third and fourth examples, $a_1 + a_2 + \cdots + a_m$ is already the smallest of the prefix sums — no operation needs to be performed</p>
<p>In the fifth example, a valid sequence of operations is:</p>
<ul>
<li>$a_3 := -a_3$,</li>
<li>$a_2 := -a_2$,</li>
<li>$a_5 := -a_5$</li>
</ul>
<p>The array becomes $[-2,-3,5,-5,20]$ and its prefix sums are $[-2,-5,0,-5,15]$. Note that $a_1+a_2=-5$ and $a_1+a_2+a_3+a_4=-5$ are both the smallest of the prefix sums (and this is a valid solution)</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:CodeForces_1779C CodeForces/1779C/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>D - Boris and His Amazing Haircut</h2>
<p>Boris thinks that chess is a tedious game. So he left his tournament early and went to a barber shop as his hair was a <em>bit</em> messy</p>
<p>His current hair can be described by an array $a_1,a_2,\ldots, a_n$, where $a_i$ is the height of the hair standing at position $i$. His desired haircut can be described by an array $b_1,b_2,\ldots, b_n$ in a similar fashion</p>
<p>The barber has $m$ razors. Each has its own size and can be used <strong>at most</strong> once. In one operation, he chooses a razor and cuts a segment of Boris's hair. More formally, an operation is:</p>
<ul>
<li>Choose any razor which hasn't been used before, let its size be $x$;</li>
<li>Choose a segment $[l,r]$ ($1\leq l \leq r \leq n$);</li>
<li>Set $a_i := \min (a_i,x)$ for each $l\leq i \leq r$;</li>
</ul>
<p>Notice that some razors might have equal sizes — the barber can choose some size $x$ only as many times as the number of razors with size $x$</p>
<p>He may perform as many operations as he wants, as long as any razor is used at most once and $a_i = b_i$ for each $1 \leq i \leq n$ at the end. He <strong>does not</strong> have to use all razors</p>
<p>Can you determine whether the barber can give Boris his desired haircut?</p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 20,000$). The description of the test cases follows</p>
<p>The first line of each test case contains a positive integer $n$ ($3\leq n\leq 2\cdot 10^5$) — the length of arrays $a$ and $b$</p>
<p>The second line of each test case contains $n$ positive integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 10^9$) — Boris's current hair</p>
<p>The third line of each test case contains $n$ positive integers $b_1, b_2, \ldots, b_n$ ($1 \leq b_i \leq 10^9$) — Boris's desired hair</p>
<p>The fourth line of each test case contains a positive integer $m$ ($1 \leq m \leq 2\cdot 10^5$) — the number of razors</p>
<p>The fifth line of each test case contains $m$ positive integers $x_1,x_2, \ldots, x_m$ ($1 \leq x_i \leq 10^9$) — the sizes of the razors</p>
<p>It is guaranteed that the sum of $n$ and the sum of $m$ over all test cases do not exceed $2\cdot 10^5$</p>
<h3>Output</h3>
<p>For each test case, print "<code>YES</code>" if the barber can cut Boris's hair as desired. Otherwise, print "<code>NO</code>"</p>
<p>You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="language-input1">7
3
3 3 3
2 1 2
2
1 2
6
3 4 4 6 3 4
3 1 2 3 2 3
3
3 2 3
10
1 2 3 4 5 6 7 8 9 10
1 2 3 4 5 6 7 8 9 10
10
1 2 3 4 5 6 7 8 9 10
3
1 1 1
1 1 2
12
4 2 4 3 1 5 6 3 5 6 2 1
13
7 9 4 5 3 3 3 6 8 10 3 2 5
5 3 1 5 3 2 2 5 8 5 1 1 5
8
1 5 3 5 4 2 3 1
13
7 9 4 5 3 3 3 6 8 10 3 2 5
5 3 1 5 3 2 2 5 8 5 1 1 5
7
1 5 3 4 2 3 1
3
19747843 2736467 938578397
2039844 2039844 2039844
1
2039844
</code></pre>
<h4>output</h4>
<pre><code class="language-output1">YES
NO
YES
NO
YES
NO
YES
</code></pre>
<h3>Note</h3>
<p>In the first test case, Boris's hair is initially $[3,3,3]$. Let us describe a sequence of $2$ operations the barber can perform:</p>
<ul>
<li>The barber uses the razor with size $1$ on the segment $[2,2]$; hence Boris's hair becomes $[3,1,3]$</li>
<li>The barber uses the razor with size $2$ on the segment $[1,3]$; hence Boris's hair becomes $[2,1,2]$ which is the desired haircut</li>
</ul>
<p>In the third test case, no operation has to be done since Boris's hair is already as desired</p>
<p>In the fourth test case, no cuts will be able to increase the third element in $[1,1,1]$ in a way that the array becomes $[1,1,2]$</p>
<h3>解题思路</h3>
<p>显然 $b_i\leq a_i,~\forall i\in 1..n$ 且 $b_i\in c,~\forall a_i\ne b_i$ 时才可能可行</p>
<p>我们将需要修剪的 $i$ 按 $b_i$ 升序排列, 每次尽可能修建尽可能大的范围, 不难发现所有的 $i$ 至多被修剪一次, 维护修建范围的边界即可</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:CodeForces_1779D CodeForces/1779D/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>E - Anya's Simultaneous Exhibition</h2>
<p><em>This is an interactive problem</em></p>
<p>Anya has gathered $n$ chess experts numbered from $1$ to $n$ for which the following properties hold:</p>
<ul>
<li>For any pair of players one of the players wins every game against the other (and no draws ever occur);</li>
<li>Transitivity does not necessarily hold — it might happen that $A$ always beats $B$, $B$ always beats $C$ and $C$ always beats $A$</li>
</ul>
<p>Anya <strong>does not</strong> know, for each pair, who is the player who beats the other</p>
<p>To organize a tournament, Anya hosts $n-1$ games. In each game, she chooses two players. One of them wins and stays, while the other one is disqualified. After all the games are hosted only one player will remain. A player is said to be a <em>candidate master</em> if they can win a tournament (notice that the winner of a tournament may depend on the players selected by Anya in the $n-1$ games)</p>
<p>Since Anya is a curious girl, she is interested in finding the <em>candidate masters</em>. Unfortunately, she does not have much time. To speed up the process, she will organize up to $2n$ simuls (short for "simultaneous exhibition", in which one player plays against many)</p>
<p>In one simul, Anya chooses <strong>exactly one</strong> player who will play against some (at least one) of the other players. The chosen player wins all games they would win in a regular game, and the same holds for losses. After the simul finishes, Anya is only told the total number of games won by the chosen player (but not which ones). Nobody is disqualified during a simul</p>
<p>Can you help Anya host simuls and determine the <em>candidate masters</em>?</p>
<p>The winning players in each pair <strong>could be</strong> changed between the simuls, but only in a way that preserves the results of all previous simuls. These changes may depend on your queries</p>
<h3>Interaction</h3>
<p>Firstly, the jury sends one integer $n$ ($3 \leq n \leq 250$) which should be read — the number of players. After that, your program may ask queries or report an answer</p>
<p>To ask a query, print "<code>?</code> $i ; s_1 s_2 \ldots s_n$" (without quotes), where $i$ is the index of the player who will play against some of the other players in the simul. $s$ is a binary string that denotes the players they play against. $i$ plays against every player $j$ for which $s_j = 1$ holds (and $s_j = 1$ should hold for at least one $1 \leq j \leq n$). Please note that $s_i = 0$ must hold since a player cannot play against themselves, otherwise, the query is considered to be incorrect</p>
<p>After this, you should read an integer — the number of games player $i$ has won</p>
<p>When you have identified the answer, you must print "<code>!</code> $c_1 c_2 \ldots c_n$" (without quotes) and terminate your program. $c$ is a binary string which represents the candidate masters. Player $i$ is a candidate master if $c_i=1$ holds, otherwise, they are not</p>
<p>If you ask more than $2n$ queries or if one of the queries is malformed, the interaction terminates immediately and your program receives verdict <code>Wrong Answer</code></p>
<p>After printing a query do not forget to output the end of line and flush the output. Otherwise, you will get <code>Idleness limit exceeded</code>. To do this, use:</p>
<ul>
<li><code>fflush(stdout)</code> or <code>cout.flush()</code> in C++;</li>
<li><code>System.out.flush()</code> in Java;</li>
<li><code>flush(output)</code> in Pascal;</li>
<li><code>stdout.flush()</code> in Python;</li>
<li>see the documentation for other languages</li>
</ul>
<p><strong>Hacks are disabled in this problem</strong></p>
<h3>Examples</h3>
<h4>input</h4>
<pre><code class="language-input1">3

1

1

1
</code></pre>
<h4>output</h4>
<pre><code class="language-output1">
? 1 010

? 2 001

? 3 100

! 111
</code></pre>
<h4>input</h4>
<pre><code class="language-input2">5

0

3

4
</code></pre>
<h4>output</h4>
<pre><code class="language-output2">
? 5 10110

? 2 10111

? 1 01111

! 10000
</code></pre>
<h3>Note</h3>
<p>In the first example, the first query describes a simul in which player $1$ plays against player $2$ (and no one else). The answer to the query is $1$, meaning that player $1$ won the only game they played. We can conclude that $1$ beats $2$. Similarly, the second query tells us that $2$ beats $3$ and the third query tells us that $3$ beats $1$. All players are candidate masters in this case as</p>
<ul>
<li>Player $1$ can win the tournament if $2$ and $3$ play first. $3$ loses and leaves, while $2$ stays. $1$ then plays against $2$ and wins;</li>
<li>Other players can win in the same fashion</li>
</ul>
<p>In the second example, the third query describes a simul in which player $1$ plays against every other player. The answer to the query is $4$, meaning that they won every game they played. It can be concluded that player $1$ also beats every other player. They can never lose, hence they are the only player who can remain at the end of every possible tournament, and the only possible candidate master</p>
<h3>解题思路</h3>
<p>不难看出题目等价于:</p>
<p>有一个含 $n$ 个点的竞赛图, 你可以进行至多 $2n$ 次询问, 每次询问可以问某点在含该点的某个子图中的出度, 问该竞赛图中所有满足如下条件的点 $v$:</p>
<p>$$
\operatorname{dis}(v,v')\in\mathbb{N},~\forall v'\in V\setminus{v}
$$</p>
<p>我们有引理</p>
<p>{% note danger no-icon %}</p>
<p><strong>&lt;a id="lm-E-1"&gt;引理 - E-1&lt;/a&gt;</strong> 竞赛图 $T=\lang V,E\rang$ 中出度最大的点到任意点的距离不超过 $2$</p>
<p>&lt;details open&gt;
&lt;summary&gt;证明&lt;/summary&gt;</p>
<p>假设出度最大的点为 $v$, 与之相邻的点集为 $V_1$, $V_2=V\setminus(V_1\cup{v})$</p>
<p>任取 $V_2$ 中的点 $u$, 若 $\operatorname{dis}(v,u)&gt;2$, 则说明 $V_1\cup{v}$ 中所有的点均不与 $u$ 相邻, 由竞赛图的性质, $d_{out}(u)\geq|V_1|+1&gt;d_{out}(v)$, 矛盾</p>
<p>&lt;/details&gt;</p>
<p>{% endnote %}</p>
<p>进一步, 竞赛图中出度最大的点满足要求</p>
<p>另外, 若该竞赛图是强连通的, 则所有点均满足条件, 否则, 我们考虑所有的强连通分量 $T_1,T_2,\dots,T_k$ (按拓扑序排列), 则</p>
<p>$$
d_{out}(u)&gt;d_{out}(v),~\forall u\in T_i, v\in T_j, i&lt;j
$$</p>
<p>不难发现 $T_1$ 中的点即为所求</p>
<p>我们只需 $n$ 次查询获得所有点的出度, 之后按出度排序后计算 $T_1$ 即可</p>
<p>官方题解说可以将查询次数控制在 $n-1$, 也许可以进一步利用竞赛图的性质来优化算法</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:CodeForces_1779E CodeForces/1779E/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>F - Xorcerer's Stones</h2>
<p><em>Misha had been banned from playing chess for good since he was accused of cheating with an engine. Therefore, he retired and decided to become a xorcerer</em></p>
<p>One day, while taking a walk in a park, Misha came across a rooted tree with nodes numbered from $1$ to $n$. The root of the tree is node $1$</p>
<p>For each $1\le i\le n$, node $i$ contains $a_i$ stones in it. Misha has recently learned a new spell in his <em>xorcery</em> class and wants to test it out. A spell consists of:</p>
<ul>
<li>Choose some node $i$ ($1 \leq i \leq n$)</li>
<li>Calculate the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR">bitwise XOR</a> $x$ of all $a_j$ such that node $j$ is in the subtree of $i$ ($i$ belongs to its own subtree)</li>
<li>Set $a_j$ equal to $x$ for all nodes $j$ in the subtree of $i$</li>
</ul>
<p>Misha can perform at most $2n$ spells and he wants to remove all stones from the tree. More formally, he wants $a_i=0$ to hold for each $1\leq i \leq n$. Can you help him perform the spells?</p>
<p>A tree with $n$ nodes is a connected acyclic graph which contains $n-1$ edges. The subtree of node $i$ is the set of all nodes $j$ such that $i$ lies on the simple path from $1$ (the root) to $j$. We consider $i$ to be contained in its own subtree</p>
<h3>Input</h3>
<p>The first line contains a single integer $n$ ($2 \leq n \leq 2\cdot 10^5$) — the size of the tree</p>
<p>The second line contains an array of integers $a_1,a_2,\ldots, a_n$ ($0 \leq a_i \leq 31$), describing the number of stones in each node initially</p>
<p>The third line contains an array of integers $p_2,p_3,\ldots, p_n$ ($1 \leq p_i \leq i-1$), where $p_i$ means that there is an edge connecting $p_i$ and $i$</p>
<h3>Output</h3>
<p>If there is not a valid sequence of spells, output $-1$</p>
<p>Otherwise, output a single integer $q$ ($0 \leq q \leq 2n$) in the first line — the number of performed spells</p>
<p>In the second line output a sequence of integers $v_1,v_2,\ldots,v_q$ ($1 \leq v_i \leq n$) — the $i$-th spell will be performed on the subtree of node $v_i$. Please note that order matters</p>
<p>If multiple solutions exist, output any. You don't have to minimize the number of operations</p>
<h3>Examples</h3>
<h4>input</h4>
<pre><code class="language-input1">2
13 13
1
</code></pre>
<h4>output</h4>
<pre><code class="language-output1">1
1
</code></pre>
<h4>input</h4>
<pre><code class="language-input2">7
5 2 8 3 4 1 31
1 1 2 2 3 3
</code></pre>
<h4>output</h4>
<pre><code class="language-output2">-1
</code></pre>
<h4>input</h4>
<pre><code class="language-input3">9
3 31 1 2 7 30 7 3 1
1 1 1 2 5 5 3 4
</code></pre>
<h4>output</h4>
<pre><code class="language-output3">6
3 2 3 1 2 2
</code></pre>
<h3>Note</h3>
<p>Please refer to the following pictures for an explanation of the third test. Only the first $4$ spells are shown since the last $2$ do nothing. The first picture represents the tree initially with the number of stones for each node written above it in green. Changes applied by the current spell are highlighted in red</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/F-1.png"/></p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
<h2>G - The Game of the Century</h2>
<p>The time has finally come, MKnez and Baltic are to host <em>The Game of the Century</em>. For that purpose, they built a village to lodge its participants</p>
<p>The village has the shape of an equilateral triangle delimited by three roads of length $n$. It is cut into $n^2$ smaller equilateral triangles, of side length $1$, by $3n-3$ additional roads which run parallel to the sides. See the figure for $n=3$. Each of the $3n$ roads is made of multiple (possibly $1$) road segments of length $1$ which connect adjacent intersections</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/G-1.png"/></p>
<p>The direction has already been chosen for each of the $3n$ roads (so, for each road, the same direction is assigned to all its road segments). Traffic can only go in the specified directions (i. e. the roads are monodirectional)</p>
<p>You are tasked with making adjustments to the traffic plan so that from each intersection it is possible to reach every other intersection. Specifically, you can invert the traffic direction of any number of road segments of length $1$. What is the minimal number of road segments for which you need to invert the traffic direction?</p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 10,000$). The description of the test cases follows</p>
<p>The first line of each test case contains a positive integer $n$ ($1\leq n\leq 10^5$) — the size of the triangular village's sides</p>
<p>Three lines follow, each containing a binary string of length $n$ which describes the traffic directions of the roads</p>
<p>The $i$-th of the following three lines contains a binary string $s_i$ of length $n$ representing the direction of each road parallel to the road segment denoted by $i$ in the picture above. In particular, the $j$-th character of $s_i$ is "<code>1</code>" if the $j$-th shortest road (parallel to the road segment denoted by $i$ in the picture) has the same direction of the road segment denoted by $i$ in the picture, while it is "<code>0</code>" if it has the opposite direction. So the first character of $s_i$ describes the direction of the road containing only $1$ road segment, while the last character describes the direction of the road containing $n$ road segments</p>
<p>It is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$</p>
<h3>Output</h3>
<p>For each test case, print the minimum number of road segments for which you need to invert the traffic direction</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="language-input1">3
3
001
001
010
1
0
0
0
3
111
011
100
</code></pre>
<h4>output</h4>
<pre><code class="language-output1">2
0
3
</code></pre>
<h3>Note</h3>
<p>The first example corresponds to the picture in the statement. There exist multiple solutions that invert the traffic direction of exactly $2$ road segments, but inverting only $1$ road segment never makes it possible to reach every intersection from any other. One of the possible solutions is shown in the picture below in which the inverted road segments are highlighted in blue</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/G-2.png"/></p>
<p>In the second example, the answer is $0$ since it is already possible to reach every intersection from any other</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
<h2>H - Olympic Team Building</h2>
<p>Iron and Werewolf are participating in a chess Olympiad, so they want to practice team building. They gathered $n$ players, where $n$ is a power of $2$, and they will play sports. Iron and Werewolf are among those $n$ people</p>
<p>One of the sports is tug of war. For each $1\leq i \leq n$, the $i$-th player has strength $s_i$. Elimination rounds will be held until only one player remains — we call that player the <em>absolute winner</em></p>
<p>In each round:</p>
<ul>
<li>Assume that $m&gt;1$ players are still in the game, where $m$ is a power of $2$</li>
<li>The $m$ players are split into two teams of equal sizes (i. e., with $m/2$ players in each team). The strength of a team is the sum of the strengths of its players</li>
<li>If the teams have equal strengths, Iron chooses who wins; otherwise, the stronger team wins</li>
<li>Every player in the losing team is eliminated, so $m/2$ players remain</li>
</ul>
<p>Iron already knows each player's strength and is wondering who can become the absolute winner and who can't if he may choose how the teams will be formed in each round, as well as the winning team in case of equal <em>strengths</em></p>
<h3>Input</h3>
<p>The first line contains a single integer $n$ ($4 \leq n \leq 32$) — the number of players participating in tug of war. It is guaranteed that $n$ is a power of $2$</p>
<p>The second line consists of a sequence $s_1,s_2, \ldots, s_n$ of integers ($1 \leq s_i \leq 10^{15}$) — the strengths of the players</p>
<h3>Output</h3>
<p>In a single line output a binary string $s$ of length $n$ — the $i$-th character of $s$ should be $1$ if the $i$-th player can become the <em>absolute winner</em> and it should be $0$ otherwise</p>
<h3>Examples</h3>
<h4>input</h4>
<pre><code class="language-input1">4
60 32 59 87
</code></pre>
<h4>output</h4>
<pre><code class="language-output1">1001
</code></pre>
<h4>input</h4>
<pre><code class="language-input2">4
100 100 100 100
</code></pre>
<h4>output</h4>
<pre><code class="language-output2">1111
</code></pre>
<h4>input</h4>
<pre><code class="language-input3">8
8 8 8 8 4 4 4 4
</code></pre>
<h4>output</h4>
<pre><code class="language-output3">11110000
</code></pre>
<h4>input</h4>
<pre><code class="language-input4">32
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
</code></pre>
<h4>output</h4>
<pre><code class="language-output4">00000000000000001111111111111111
</code></pre>
<h4>input</h4>
<pre><code class="language-input5">16
1 92875987325987 1 1 92875987325986 92875987325985 1 92875987325988 92875987325990 92875987325989 1 1 92875987325984 92875987325983 1 1
</code></pre>
<h4>output</h4>
<pre><code class="language-output5">0100110111001000
</code></pre>
<h3>Note</h3>
<p>In the first example, players $1$ and $4$ with their respective strengths of $60$ and $87$ can become the absolute winners</p>
<p>Let's describe the process for player $1$. Firstly, we divide the players into teams $[1,3]$ and $[2,4]$. Strengths of those two teams are $60+59=119$ and $32+87=119$. They they are equal, Iron can choose to disqualify any of the two teams. Let his choice be the second team</p>
<p>We are left with players $1$ and $3$. Since $1$ has greater strength ($60&gt;59$) they win and are declared the absolute winner as they are the last remaining player</p>
<p>In the third example, the strengths of the remaining players may look like $[8,8,8,8,4,4,4,4] \rightarrow [8,8,4,4] \rightarrow [8,4] \rightarrow [8]$. Each person with strength $8$ can become the absolute winner and it can be proved that others can't</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
