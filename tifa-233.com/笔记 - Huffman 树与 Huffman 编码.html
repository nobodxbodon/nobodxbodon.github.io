<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/hfm-tree.md">仓库源文</a>，<a href="https://tifa-233.com/archives/hfm-tree">站点原文</a></h2>
<hr/>
<p>title: 笔记 - Huffman 树与 Huffman 编码
categories:</p>
<ul>
<li>笔记</li>
<li>算法竞赛
tags:</li>
<li>算法竞赛</li>
<li>笔记</li>
<li>模板</li>
<li>数据结构</li>
<li>树</li>
<li>Huffman树</li>
<li>Huffman编码
date: 2021-07-15 18:41:12</li>
</ul>
<hr/>
<p>Huffman 编码是一种基于 Huffman 树的, 按字符概率构造的, 能保证编码平均长度最短的编码方式</p>
&lt;!-- more --&gt;

<p>{% note warning %}
<a href="https://cplib.tifa-233.com/src/code/util/huffman_tree.hpp">https://cplib.tifa-233.com/src/code/util/huffman_tree.hpp</a> 存放了笔者对该算法/数据结构的最新实现, 建议前往此处查看相关代码
{% endnote %}</p>
<h2>介绍</h2>
<p>Huffman 树即为根结点到所有叶子结点的带权路径长度之和最小的树</p>
<h3>构建方式</h3>
<p>对于一棵 $k$ 叉的 Huffman 树, 我们首先要确保 结点个数 $n$ 满足 $(k-1)\mid(n-1)$, 否则我们可以补充若干个权值为 $0$ 的结点使其成立</p>
<p>首先按结点的权值排序, 然后取出 $k$ 个权值最小的结点合并为一个新结点并插入该序列, 新结点的权值为这 $k$ 个点权值之和, 直到序列中只剩下 $1$ 个结点为止</p>
<p>Huffman 编码通过对 Huffman 树进行层序遍历得到</p>
<h2>例题</h2>
<ul>
<li><a href="https://uoj.ac/problem/130">UOJ 130 - 【NOI2015】荷马史诗</a> -&gt; {% post_link uoj-130 题解 %}</li>
</ul>
<h2>代码 (K 叉 Huffman 树)</h2>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

{% icodeweb blog lang:cpp hfm-tree/Huffman_tree.hpp %}

&lt;/details&gt;