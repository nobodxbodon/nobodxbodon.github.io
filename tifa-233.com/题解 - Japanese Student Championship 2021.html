<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/jsc2021.md">仓库源文</a>，<a href="https://tifa-233.com/archives/jsc2021">站点原文</a></h2>
<hr/>
<p>title: 题解 - Japanese Student Championship 2021
categories:</p>
<ul>
<li>算法竞赛</li>
<li>题解
tags:</li>
<li>算法竞赛</li>
<li>题解</li>
<li>AtCoder</li>
<li>暴力</li>
<li>枚举</li>
<li>数学</li>
<li>图论</li>
<li>数论</li>
<li>字符串</li>
<li>数据结构</li>
<li>最大公约数</li>
<li>回文字符串</li>
<li>线段树</li>
<li>平衡树</li>
<li>并查集</li>
<li>Laplacian矩阵</li>
<li>Kirchhoff矩阵树定理
date: 2021-04-17 18:54:25</li>
</ul>
<hr/>
<p><a href="https://atcoder.jp/contests/jsc2021">比赛链接</a></p>
<p>&lt;!-- more --&gt;</p>
<h2>题目概览</h2>
<p>| 题号<a href="%E6%89%93*%E7%9A%84%E6%98%AF%E8%BF%98%E6%B2%A1%E5%86%99%E7%9A%84%E9%A2%98">^1</a> | 标题               | 做法                |
| -------- | ------------------ | ------------------- |
| A        | Competition        | 签到                |
| B        | Xor of Sequences   | 签到                |
| C        | Max GCD 2          | 签到, 枚举          |
| D        | Nowhere $P$        | 签到, 找规律        |
| *E      | Level K Palindrome |                     |
| *F      | Max Matrix         | 线段树 / 平衡树     |
| G        | Spanning Tree      | 并查集 + 矩阵树定理 |
| *H      | Shipping           |                     |</p>
<p><a href="https://atcoder.jp/contests/jsc2021/editorial">官方题解</a></p>
<h2>A - Competition</h2>
<p>Time Limit: 2 sec / Memory Limit: 1024 MB</p>
<p>Score: 100 points</p>
<h3>Problem Statement</h3>
<p>A Supermarket Takahashi sells an $X$-gram beef pack for $Y$ yen</p>
<p>Another Supermarket Snuke has decided to sell a beef pack at a lower price per gram</p>
<p>In Snuke, one beef pack weighs $Z$ grams. What is the greatest possible price (a non-negative integer) for Snuke's beef pack such that it is strictly cheaper than Takahashi's beef pack per gram?</p>
<h3>Constraints</h3>
<ul>
<li>All values in input are integers</li>
<li>$1\leqslant X,Y,Z\leqslant 10^3$</li>
</ul>
<h3>Input</h3>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$X\ Y\ Z$</p>
</blockquote>
<h3>Output</h3>
<p>Print the answer</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">100 200 100
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">199
</code></pre>
<p>Both stores sell $100$-gram packs, so Snuke can just make it one yen cheaper than that in Takahashi</p>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">103 971 593
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">5590
</code></pre>
<p>Takahashi sells beef for $\frac{971}{103}=9.4271...$
yen per gram. Snuke can sell $593$ grams of beef for $5590$ yen to make it $\frac{5590}{593}=9.4266...$ yen per gram</p>
<h3>Sample Input 3</h3>
<pre><code class="language-input3">1000 1 1
</code></pre>
<h3>Sample Output 3</h3>
<pre><code class="language-output3">0
</code></pre>
<p>The price is allowed to be $0$ yen</p>
<h3>解题思路</h3>
<p>$\lfloor\frac{yz}{x}\rfloor-[x\mid yz]$</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:AtCoder_jsc2021_a AtCoder/jsc2021_a/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>B - Xor of Sequences</h2>
<p>Time Limit: 2 sec / Memory Limit: 1024 MB</p>
<p>Score: 200 points</p>
<h3>Problem Statement</h3>
<p>We have two strictly increasing integer sequences $A=(A_1,A_2,...,A_N)$ and $B=(B_1,B_2,...,B_M)$</p>
<p>Find all integers that appear in exactly one of $A$ and $B$ and print them in ascending order</p>
<h3>Constraints</h3>
<ul>
<li>All values in input are integers</li>
<li>$1\leqslant N,M\leqslant 10^3$</li>
<li>$1\leqslant A_1&lt;A_2&lt;...&lt;A_N\leqslant 10^3$</li>
<li>$1\leqslant B_1&lt;B_2&lt;...&lt;B_M\leqslant 10^3$</li>
</ul>
<h3>Input</h3>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$N\ M$</p>
<p>$A_1\ A_2\ ...\ A_N$</p>
<p>$B_1\ B_2\ ...\ B_M$</p>
</blockquote>
<h3>Output</h3>
<p>Print all integers that appear in exactly one of $A$ and $B$</p>
<p>in ascending order, with space as separator</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">2 2
1 2
1 3
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">2 3
</code></pre>
<p>$1$ is contained in both $A$ and$B$</p>
<p>$2$ is contained in only $A$</p>
<p>$3$ is contained in only $B$</p>
<p>Thus, we should print $2$ and $3$</p>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">4 4
1 2 3 4
1 2 3 4
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">
</code></pre>
<p>You can print an empty line or nothing</p>
<h3>题意简述</h3>
<p>给两串严格递增的序列, 求这两个序列的对称差</p>
<h3>解题思路</h3>
<p>随便做</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:AtCoder_jsc2021_b AtCoder/jsc2021_b/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>C - Max GCD 2</h2>
<p>Time Limit: 2 sec / Memory Limit: 1024 MB</p>
<p>Score: 300 points</p>
<h3>Problem Statement</h3>
<p>Given are integers $A$ and $B$. Find the maximum possible value of $\gcd(x,y)$ when we choose integers x and y so that $A\leqslant x&lt;y\leqslant B$</p>
<p>Here, $\gcd(x,y)$ denotes the greatest common divisor of $x$ and $y$</p>
<h3>Constraints</h3>
<ul>
<li>$A$ and $B$ are integers</li>
<li>$1\leqslant A&lt;B\leqslant 2\times 10^5$</li>
</ul>
<h3>Input</h3>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$A\ B$</p>
</blockquote>
<h3>Output</h3>
<p>Print the answer</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">2 4
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">2
</code></pre>
<p>We have three ways to choose $(x,y)$ such that $A\leqslant x&lt;y\leqslant B$: $(2,3),(2,4),(3,4)$, where the greatest common divisors are $1,2,1$, respectively, so the maximum possible value is $2$</p>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">199999 200000
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">1
</code></pre>
<p>We have $\gcd(199999,200000)=1$</p>
<h3>Sample Input 3</h3>
<pre><code class="language-input3">101 139
</code></pre>
<h3>Sample Output 3</h3>
<pre><code class="language-output3">34
</code></pre>
<h3>题意简述</h3>
<p>给定 $A,B$, 求 $\displaystyle\max_{A\leqslant x&lt;y\leqslant B}(x,y)$</p>
<h3>解题思路</h3>
<p>直接暴力枚举即可</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:AtCoder_jsc2021_c AtCoder/jsc2021_c/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>D - Nowhere P</h2>
<p>Time Limit: 2 sec / Memory Limit: 1024 MB</p>
<p>Score: 400 points</p>
<h3>Problem Statement</h3>
<p>You are given a prime number $P$ not less than $2$, which you don't like</p>
<p>Let's call an array of integers $A_1,A_2,...,A_N$ very good if it satisfies the following condition:</p>
<ul>
<li>there is no $i$ with $1\leqslant i\leqslant N$ and $A_1+A_2+...+A_i\equiv0\pmod P$</li>
</ul>
<p>Consider all $(P-1)^N$ arrays of length $N$ with elements from $1$ to $P-1$. How many of them are very good?</p>
<p>As this number can be very big, output it modulo $10^9+7$</p>
<h3>Constraints</h3>
<ul>
<li>$N$ and $P$ are integers</li>
<li>$1\leqslant N\leqslant 10^9$</li>
<li>$2\leqslant P\leqslant 10^9$</li>
</ul>
<h3>Input</h3>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$N\ P$</p>
</blockquote>
<h3>Output</h3>
<p>Print the count modulo $10^9+7$</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">3 3
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">2
</code></pre>
<p>Two arrays, $(1,1,2)$ and $(2,2,1)$, satisfy the condition</p>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">3 2
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">0
</code></pre>
<h3>Sample Input 3</h3>
<pre><code class="language-input3">45108 2571593
</code></pre>
<h3>Sample Output 3</h3>
<pre><code class="language-output3">224219544
</code></pre>
<h3>题意简述</h3>
<p>给定质数 $P$, 求有多少序列 $(A_1,A_2,\dots,A_N)$ 满足:</p>
<p>$$
\forall i\in[1,n]<em>{\mathbb{N}},~\sum</em>{j=1}^iA_j{\equiv}\llap{/,}0\pmod P
$$</p>
<h3>解题思路</h3>
<p>显然, 当 $n=1$ 时答案为 $p-1$, 对应合法序列即为 $(1),(2),...,(p-1)$</p>
<p>之后在这些合法序列后插入新数时, 每个序列都有且仅有一个数使得这个数插入后该序列非法 (该数即为 $(-\sum_{i}a_i)\bmod p$)</p>
<p>故答案为 $(p-1)(p-2)^{n-1}$</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:AtCoder_jsc2021_d AtCoder/jsc2021_d/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>E - Level K Palindrome</h2>
<p>Time Limit: 2 sec / Memory Limit: 1024 MB</p>
<p>Score: 500 points</p>
<h3>Problem Statement</h3>
<p>As a token of his gratitude, Takahashi has decided to give Snuke a level-$K$ palindrome. A level-$L$ palindrome, where $L$ is a non-negative integer, is defined as follows:</p>
<ul>
<li>Let $\operatorname{rev}(s)$ denote the reversal of a string $s$</li>
<li>A string $s$ is said to be a palindrome when $s=\operatorname{rev}(s)$</li>
<li>The empty string and a string that is not a palindrome are level-$0$ palindromes</li>
<li>For any <strong>non-empty</strong> level-($L-1$) palindrome $t$, the concatenation of $t$,$\operatorname{rev}(t)$ in this order is a level-$L$ palindrome</li>
<li>For any level-($L-1$) palindrome $t$ and any character $c$, the concatenation of $t$,$c$,$\operatorname{rev}(t)$ in this order is a level-$L$ palindrome</li>
</ul>
<p>Now, Takahashi has a string $S$. Determine whether it is possible to make $S$ an exactly level-$K$ palindrome by doing the following action zero or more times: choose a character in $S$ and change it to another lowercase English letter. If it is possible, find the minimum number of changes needed to make $S$ a level-$K$ palindrome</p>
<h3>Constraints</h3>
<ul>
<li>$K$ is an integer</li>
<li>$0\leqslant K\leqslant 5\times 10^5$</li>
<li>$S$ consists of lowercase English letters</li>
<li>$1\leqslant |S|\leqslant 5\times 10^5$</li>
</ul>
<h3>Input</h3>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$K\ S$</p>
</blockquote>
<h3>Output</h3>
<p>If it is possible to get an exactly level-$K$ palindrome, print the minimum number of changes needed. If it is impossible, print impossible</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">4
aabaaaabaa
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">0
</code></pre>
<p>We can find the level of <code>aabaaaabaa</code> as follows:</p>
<ul>
<li>the empty string is a level-$0$ palindrome</li>
<li><code>a</code> is a concatenation of (empty string), <code>a</code>, (empty string) in this order, so it is a level-$1$ palindrome</li>
<li><code>aa</code> is a concatenation of a, a in this order, so it is a level-$2$ palindrome</li>
<li><code>aabaa</code> is a concatenation of <code>aa</code>, <code>b</code>, <code>aa</code> in this order, so it is a level-$3$ palindrome</li>
<li><code>aabaaaabaa</code> is a concatenation of <code>aabaa</code>, <code>aabaa</code> in this order, so it is a level-$4$ palindrome</li>
</ul>
<p>Thus, <code>aabaaaabaa</code> is already a level-$4$ palindrome and needs no changes</p>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">2
aabaaaabaa
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">4
</code></pre>
<p>We can, for example, change <code>aabaaaabaa</code> to <code>acbcaacbca</code> to get a level-$2$ palindrome</p>
<p>Note that <code>aabaaaabaa</code> is not a level-$2$ palindrome</p>
<h3>Sample Input 3</h3>
<pre><code class="language-input3">3
aabaaaabaa
</code></pre>
<h3>Sample Output 3</h3>
<pre><code class="language-output3">impossible
</code></pre>
<h3>Sample Input 4</h3>
<pre><code class="language-input4">5
aabaaaabaa
</code></pre>
<h3>Sample Output 4</h3>
<pre><code class="language-output4">impossible
</code></pre>
<h3>Sample Input 5</h3>
<pre><code class="language-input5">2
acaabcbababaaac
</code></pre>
<h3>Sample Output 5</h3>
<pre><code class="language-output5">6
</code></pre>
<h3>题意简述</h3>
<p>本题所有的字符串均指只由小写英文字母构成的字符串</p>
<p>对字符串 $s$,</p>
<ul>
<li>定义其反转为: $\operatorname{rev}(s)$, 则 $s$ 是回文串 $\iff s=\operatorname{rev}(s)$</li>
<li>$+$ 运算定义为字符串的拼接</li>
<li>定义字符串上的变换为: 将其中某一字符替换为一小写英文字母</li>
</ul>
<p>定义 $k$ 阶回文串如下:</p>
<ul>
<li>空串, 非回文串为 $0$ 阶回文串</li>
<li>对 $i$ 阶非空回文串 $s$, 定义 $s+\operatorname{rev}(s)$ 为 $i+1$ 阶回文串</li>
<li>对 $i$ 阶回文串 $s$ 和单个字符 $c$, 定义 $s+c+\operatorname{rev}(s)$ 为 $i+1$ 阶回文串</li>
</ul>
<p>给一字符串 $s$, 问至少经几次变换可使其恰好为 $k$ 阶回文串</p>
<h3>解题思路</h3>
<p>显然, 若有解则 $k$ 不可能过大</p>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
<h2>F - Max Matrix</h2>
<p>Time Limit: 3 sec / Memory Limit: 1024 MB</p>
<p>Score: 600 points</p>
<h3>Problem Statement</h3>
<p>We have a sequence a of length $N$ and a sequence $b$ of length $M$. Initially, every element in $a$ and $b$ is $0$</p>
<p>You are asked to process $Q$ queries. In the $i$-th query, given three integers $T_i$, $X_i$, and $Y_i$, do the following:</p>
<ul>
<li>if $T_i=1$: replace $a_{X_i}$ with $Y_i$</li>
<li>if $T_i=2$: replace $b_{X_i}$ with $Y_i$</li>
</ul>
<p>Then, after processing each query, print the value $\displaystyle\sum_{i=1}^N\sum_{j=1}^M\max(a_i,b_j)$</p>
<h3>Constraints</h3>
<ul>
<li>$1\leqslant N\leqslant 2\times 10^5$</li>
<li>$1\leqslant M\leqslant 2\times 10^5$</li>
<li>$1\leqslant Q\leqslant 2\times 10^5$</li>
<li>$T_i$ is $1$ or $2$</li>
<li>If $T_i=1$, $1\leqslant X_i\leqslant N$</li>
<li>If $T_i=2$, $1\leqslant X_i\leqslant M$</li>
<li>$1\leqslant Y_i\leqslant 10^8$</li>
<li>All values in input are integers</li>
</ul>
<h3>Input</h3>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$N\ M\ Q$</p>
<p>$T_1\ X_1\ Y_1$</p>
<p>$T_2\ X_2\ Y_2$</p>
<p>$T_3\ X_3\ Y_3$</p>
<p>$\vdots$</p>
<p>$T_Q\  X_Q\ Y_Q$</p>
</blockquote>
<h3>Output</h3>
<p>Print $Q$ integers as instructed in Problem Statement, with newline as separator</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">2 2 4
1 1 10
2 1 20
2 2 5
1 1 30
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">20
50
55
85
</code></pre>
<p>If we write $\max(a_i,b_j)$ at the $i$-th row and $j$-th column in a grid, the four queries will change it as follows:</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/F-1.webp"/></p>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">3 3 5
1 3 10
2 1 7
1 3 5
2 2 10
2 1 1
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">30
44
31
56
42
</code></pre>
<h3>Sample Input 3</h3>
<pre><code class="language-input3">200000 200000 4
2 112219 100000000
1 73821 100000000
2 26402 100000000
1 73821 100000000
</code></pre>
<h3>Sample Output 3</h3>
<pre><code class="language-output3">20000000000000
39999900000000
59999800000000
59999800000000
</code></pre>
<p>The integers to be printed may not fit into a $32$-bit integer type</p>
<h3>题意简述</h3>
<p>有一个长为 $n$ 的全零序列 $a$ 和长为 $m$ 的全零序列 $b$, 对其做如下操作</p>
<ul>
<li>将 $a$ 中的某个数赋一个值</li>
<li>将 $b$ 中的某个数赋一个值</li>
</ul>
<p>这两种操作一共进行 $Q$ 次, 要求每次操作后都要输出 $\displaystyle\sum_{i=1}^n\sum_{j=1}^M\max{a_i,b_j}$</p>
<h3>解题思路</h3>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
<h2>G - Spanning Tree</h2>
<p>Time Limit: 2 sec / Memory Limit: 1024 MB</p>
<p>Score: 600 points</p>
<h3>Problem Statement</h3>
<p>We have a graph with $N$ vertices numbered $1,2,...,N$. Initially, it has no edges</p>
<p>Now, let us add some number of undirected edges to $G$ so that the following condition holds for any $i,j(i\ne j)$</p>
<p>after addition</p>
<ul>
<li>If $A_{i,j}=1$, there is an edge directly connecting Vertex $i$ and Vertex $j$</li>
<li>if $A_{i,j}=0$, there is no edge directly connecting Vertex $i$ and Vertex $j$</li>
<li>if $A_{i,j}=-1$, either is fine</li>
</ul>
<p>Among the graphs that can be $G$ after addition, how many are trees?</p>
<p>Since the count can be enormous, find it modulo $10^9+7$</p>
<h3>Constraints</h3>
<ul>
<li>All values in input are integers</li>
<li>$2\leqslant N\leqslant 300$</li>
<li>$-1\leqslant A_{i,j}=A_{j,i}\leqslant 1$</li>
<li>$A_{i,i}=0$</li>
</ul>
<h3>Input</h3>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$N$</p>
<p>$A_{1,1}\ ...\  A_{1,N}$</p>
<p>$\vdots$</p>
<p>$A_{N,1}\ ...\ A_{N,N}$</p>
</blockquote>
<h3>Output</h3>
<p>Print the count modulo $10^9+7$</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">4
0 1 -1 0
1 0 -1 -1
-1 -1 0 0
0 -1 0 0
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">2
</code></pre>
<p>We need an edge between Vertex $1$ and Vertex $2$, and we must not add an edge between Vertex $1$ and Vertex $4$ or between Vertex $3$ and Vertex $4$</p>
<p>Thus, we have the following two valid graphs:</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/G-1.webp"/></p>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">3
0 1 1
1 0 1
1 1 0
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">0
</code></pre>
<h3>Sample Input 3</h3>
<pre><code class="language-input3">3
0 0 0
0 0 0
0 0 0
</code></pre>
<h3>Sample Output 3</h3>
<pre><code class="language-output3">0
</code></pre>
<h3>Sample Input 4</h3>
<pre><code class="language-input4">11
0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
-1 0 -1 -1 -1 -1 -1 -1 -1 -1 -1
-1 -1 0 -1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 0 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 0 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 0 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 0 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 0 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1 0 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1 -1 0 -1
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0
</code></pre>
<h3>Sample Output 4</h3>
<pre><code class="language-output4">357947677
</code></pre>
<p>When we distinguish the vertices, there are $11^9$
trees with $11$ vertices</p>
<h3>题意简述</h3>
<p>有 $n$ 个点, 考虑以这 $n$ 个点为顶点, 满足如下条件的所有图:</p>
<ul>
<li>无向图</li>
<li>给出一个矩阵 $A$<ul>
<li>若 $A_{i,j}=1$, 则点 $i$ 和点 $j$ 间有一条无向边</li>
<li>若 $A_{i,j}=0$, 则点 $i$ 和点 $j$ 间没有边</li>
<li>若 $A_{i,j}=-1$, 则为上述两种情况的任一种</li>
</ul>
</li>
</ul>
<p>求这些图中树的个数</p>
<h3>解题思路</h3>
<p>首先, 考虑所以已经存在的边构成的图, 如果有环了, 则答案一定为 $0$, 否则森林中的每个树都可缩成一个点, 之后用矩阵树定理即可</p>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:AtCoder_jsc2021_g AtCoder/jsc2021_g/0.cpp %}</p>
<p>&lt;/details&gt;</p>
<h2>H - Shipping</h2>
<p>Time Limit: 5 sec / Memory Limit: 1024 MB</p>
<p>Score: 600 points</p>
<h3>Problem Statement</h3>
<p>In the Republic of AtCoder, there are $N$ cities called City $1$ through City $N$ and $N$ canals called Canal $1$ through Canal $N$</p>
<p>Canal $i$ connects City $i$ and City $A_i$ bidirectionally, and you have to pay the toll of $C_i$</p>
<p>yen to go through it, but after paying the toll once, you can use it any number of times in any direction</p>
<p>It is guaranteed that you can reach from any city to any city using some canals</p>
<p>You are asked to deliver $M$ cargoes in this country. The $i$-th cargo should be delivered from City $X_i$ to City $Y_i$</p>
<p>There is no way other than using the canals to deliver the cargoes, but you yourself can travel between the cities freely without using the canals</p>
<p>Find the minimum total toll you have to pay to deliver all $M$ cargoes</p>
<h3>Constraints</h3>
<ul>
<li>$3\leqslant N\leqslant 2\times 10^5$</li>
<li>$1\leqslant M\leqslant 2\times 10^5$</li>
<li>$1\leqslant A_i\leqslant N$</li>
<li>$A_i\ne i$</li>
<li>$1\leqslant C_i\leqslant 10^9$</li>
<li>It is possible to reach from any city to any city by using some canals</li>
<li>$1\leqslant X_i\leqslant N$</li>
<li>$1\leqslant Y_i\leqslant N$</li>
<li>$X_i\ne Y_i$</li>
<li>All values in input are integers</li>
</ul>
<h3>Input</h3>
<p>Input is given from Standard Input in the following format:</p>
<blockquote>
<p>$N\ M$</p>
<p>$A_1\ C_1$</p>
<p>$A_2\ C_2$</p>
<p>$A_3\ C_3$</p>
<p>$\vdots$</p>
<p>$A_N\ C_N$</p>
<p>$X_1\ Y_1$</p>
<p>$X_2\ Y_2$</p>
<p>$X_3\ Y_3$</p>
<p>$\vdots$</p>
<p>$X_M\ Y_M$</p>
</blockquote>
<h3>Output</h3>
<p>Print the minimum total toll you have to pay, as an integer</p>
<h3>Sample Input 1</h3>
<pre><code class="language-input1">4 2
3 3
1 7
2 5
1 2
4 3
2 1
</code></pre>
<h3>Sample Output 1</h3>
<pre><code class="language-output1">10
</code></pre>
<p>The figure below shows the cities and canals in this country, where numbers along the lines representing canals represent the tolls:</p>
<p><img alt="" src="/media/wwww/share/study/聚聚/源数据/博客聚合/tifa-233.com/source/_posts/H-1.webp"/></p>
<p>You can deliver the cargoes as follows to make the total toll $10$ yen:</p>
<ul>
<li>The $1$-st cargo: use Canal $1,4$ to deliver it on the route: City $4,1,3$</li>
<li>The $2$-nd cargo: use Canal $3,1$ to deliver it on this route: City $2,3,1$</li>
</ul>
<h3>Sample Input 2</h3>
<pre><code class="language-input2">5 2
2 2
5 5
5 7
2 4
3 10
3 5
4 1
</code></pre>
<h3>Sample Output 2</h3>
<pre><code class="language-output2">13
</code></pre>
<p>Multiple canals may connect the same pair of cities</p>
<h3>Sample Input 3</h3>
<pre><code class="language-input3">11 4
8 1
9 9
8 10
8 3
1 2
11 3
9 2
6 5
3 4
1 7
3 2
7 8
10 1
4 9
11 6
</code></pre>
<h3>Sample Output 3</h3>
<pre><code class="language-output3">26
</code></pre>
<h3>题意简述</h3>
<p>给一个带权无向图, 求满足如下条件的子图的最小边权和</p>
<ul>
<li>$$
\forall i\in[1,M]_{\mathbb{N}},~\operatorname{dis}(x_i,y_i)\ne\infty
$$</li>
</ul>
<h3>解题思路</h3>
<h3>复杂度</h3>
<h3>代码参考</h3>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>&lt;/details&gt;</p>
