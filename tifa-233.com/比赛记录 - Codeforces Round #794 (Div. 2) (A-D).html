<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/cf1686.md">仓库源文</a>，<a href="https://tifa-233.com/archives/cf1686">站点原文</a></h2>
<p><a href="https://codeforces.com/contest/1686">比赛链接</a></p>
<p>难度梯度好怪</p>
&lt;!-- more --&gt;

<h2>A - Everything Everywhere All But One</h2>
<p>You are given an array of $n$ integers $a_1, a_2, \ldots, a_n$. After you watched the amazing film "Everything Everywhere All At Once", you came up with the following operation</p>
<p>In one operation, you choose $n-1$ elements of the array and replace each of them with their arithmetic mean (which doesn't have to be an integer). For example, from the array $[1, 2, 3, 1]$ we can get the array $[2, 2, 2, 1]$, if we choose the first three elements, or we can get the array $[\frac{4}{3}, \frac{4}{3}, 3, \frac{4}{3}]$, if we choose all elements except the third</p>
<p>Is it possible to make all elements of the array equal by performing a finite number of such operations?</p>
<h3>Input</h3>
<p>The first line of the input contains a single integer $t$ ($1 \le t \le 200$) — the number of test cases. The description of the test cases follows</p>
<p>The first line of each test case contains a single integer $n$ ($3 \le n \le 50$) — the number of integers</p>
<p>The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 100$)</p>
<h3>Output</h3>
<p>For each test case, if it is possible to make all elements equal after some number of operations, output $\texttt{YES}$. Otherwise, output $\texttt{NO}$</p>
<p>You can output $\texttt{YES}$ and $\texttt{NO}$ in any case (for example, strings $\texttt{yEs}$, $\texttt{yes}$, $\texttt{Yes}$ will be recognized as a positive response)</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">4
3
42 42 42
5
1 2 3 4 5
4
4 3 2 1
3
24 2 22
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">YES
YES
NO
NO
</code></pre>
<h3>Note</h3>
<p>In the first test case, all elements are already equal</p>
<p>In the second test case, you can choose all elements except the third, their average is $\frac{1 + 2 + 4 + 5}{4} = 3$, so the array will become $[3, 3, 3, 3, 3]$</p>
<p>It's possible to show that it's impossible to make all elements equal in the third and fourth test cases</p>
<h3>代码参考</h3>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

{% icodeweb cpa_cpp title:CodeForces_1686A CodeForces/1686A/0.cpp %}

&lt;/details&gt;<h2>B - Odd Subarrays</h2>
<p>For an array $[b_1, b_2, \ldots, b_m]$ define its number of inversions as the number of pairs $(i, j)$ of integers such that $1 \le i &lt; j \le m$ and $b_i&gt;b_j$. Let's call array $b$ odd if its number of inversions is odd</p>
<p>For example, array $[4, 2, 7]$ is odd, as its number of inversions is $1$, while array $[2, 1, 4, 3]$ isn't, as its number of inversions is $2$</p>
<p>You are given a permutation $[p_1, p_2, \ldots, p_n]$ of integers from $1$ to $n$ (each of them appears exactly once in the permutation). You want to split it into several consecutive subarrays (maybe just one), so that the number of the odd subarrays among them is as large as possible</p>
<p>What largest number of these subarrays may be odd?</p>
<h3>Input</h3>
<p>The first line of the input contains a single integer $t$ ($1 \le t \le 10^5$) — the number of test cases. The description of the test cases follows</p>
<p>The first line of each test case contains a single integer $n$ ($1 \le n \le 10^5$) — the size of the permutation</p>
<p>The second line of each test case contains $n$ integers $p_1, p_2, \ldots, p_n$ ($1 \le p_i \le n$, all $p_i$ are distinct) — the elements of the permutation</p>
<p>The sum of $n$ over all test cases doesn't exceed $2\cdot 10^5$</p>
<h3>Output</h3>
<p>For each test case output a single integer — the largest possible number of odd subarrays that you can get after splitting the permutation into several consecutive subarrays</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">5
3
1 2 3
4
4 3 2 1
2
1 2
2
2 1
6
4 5 6 1 2 3
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">0
2
0
1
1
</code></pre>
<h3>Note</h3>
<p>In the first and third test cases, no matter how we split our permutation, there won't be any odd subarrays</p>
<p>In the second test case, we can split our permutation into subarrays $[4, 3], [2, 1]$, both of which are odd since their numbers of inversions are $1$</p>
<p>In the fourth test case, we can split our permutation into a single subarray $[2, 1]$, which is odd</p>
<p>In the fifth test case, we can split our permutation into subarrays $[4, 5], [6, 1, 2, 3]$. The first subarray has $0$ inversions, and the second has $3$, so it is odd</p>
<h3>代码参考</h3>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

{% icodeweb cpa_cpp title:CodeForces_1686B CodeForces/1686B/0.cpp %}

&lt;/details&gt;<h2>C - Circular Local MiniMax</h2>
<p>You are given $n$ integers $a_1, a_2, \ldots, a_n$. Is it possible to arrange them on a circle so that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors?</p>
<p>In other words, check if there exists a rearrangement $b_1, b_2, \ldots, b_n$ of the integers $a_1, a_2, \ldots, a_n$ such that for each $i$ from $1$ to $n$ at least one of the following conditions holds:</p>
<p>$b_{i-1} &lt; b<em>i &gt; b</em>{i+1}$
$b_{i-1} &gt; b<em>i &lt; b</em>{i+1}$
To make sense of the previous formulas for $i=1$ and $i=n$, one shall define $b_0=b<em>n$ and $b</em>{n+1}=b_1$</p>
<h3>Input</h3>
<p>The first line of the input contains a single integer $t$ ($1 \le t \le 3\cdot 10^4$) — the number of test cases. The description of the test cases follows</p>
<p>The first line of each test case contains a single integer $n$ ($3 \le n \le 10^5$) — the number of integers</p>
<p>The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \le a_i \le 10^9$)</p>
<p>The sum of $n$ over all test cases doesn't exceed $2\cdot 10^5$</p>
<h3>Output</h3>
<p>For each test case, if it is not possible to arrange the numbers on the circle satisfying the conditions from the statement, output $\texttt{NO}$. You can output each letter in any case</p>
<p>Otherwise, output $\texttt{YES}$. In the second line, output $n$ integers $b_1, b_2, \ldots, b_n$, which are a rearrangement of $a_1, a_2, \ldots, a_n$ and satisfy the conditions from the statement. If there are multiple valid ways to arrange the numbers, you can output any of them</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">4
3
1 1 2
4
1 9 8 4
4
2 0 2 2
6
1 1 1 11 111 1111
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">NO
YES
1 8 4 9
NO
YES
1 11 1 111 1 1111
</code></pre>
<h3>Note</h3>
<p>It can be shown that there are no valid arrangements for the first and the third test cases</p>
<p>In the second test case, the arrangement $[1, 8, 4, 9]$ works. In this arrangement, $1$ and $4$ are both smaller than their neighbors, and $8, 9$ are larger</p>
<p>In the fourth test case, the arrangement $[1, 11, 1, 111, 1, 1111]$ works. In this arrangement, the three elements equal to $1$ are smaller than their neighbors, while all other elements are larger than their neighbors</p>
<h3>代码参考</h3>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

{% icodeweb cpa_cpp title:CodeForces_1686C CodeForces/1686C/0.cpp %}

&lt;/details&gt;<h2>D - Linguistics</h2>
<p>Alina has discovered a weird language, which contains only $4$ words: $\texttt{A}$, $\texttt{B}$, $\texttt{AB}$, $\texttt{BA}$. It also turned out that there are no spaces in this language: a sentence is written by just concatenating its words into a single string</p>
<p>Alina has found one such sentence $s$ and she is curious: is it possible that it consists of precisely $a$ words $\texttt{A}$, $b$ words $\texttt{B}$, $c$ words $\texttt{AB}$, and $d$ words $\texttt{BA}$?</p>
<p>In other words, determine, if it's possible to concatenate these $a+b+c+d$ words in some order so that the resulting string is $s$. Each of the $a+b+c+d$ words must be used exactly once in the concatenation, but you can choose the order in which they are concatenated</p>
<h3>Input</h3>
<p>The first line of the input contains a single integer $t$ ($1 \le t \le 10^5$) — the number of test cases. The description of the test cases follows</p>
<p>The first line of each test case contains four integers $a$, $b$, $c$, $d$ ($0\le a,b,c,d\le 2\cdot 10^5$) — the number of times that words $\texttt{A}$, $\texttt{B}$, $\texttt{AB}$, $\texttt{BA}$ respectively must be used in the sentence</p>
<p>The second line contains the string $s$ ($s$ consists only of the characters $\texttt{A}$ and $\texttt{B}$, $1\le |s| \le 2\cdot 10^5$, $|s|=a+b+2c+2d$) — the sentence. Notice that the condition $|s|=a+b+2c+2d$ (here $|s|$ denotes the length of the string $s$) is equivalent to the fact that $s$ is as long as the concatenation of the $a+b+c+d$ words</p>
<p>The sum of the lengths of $s$ over all test cases doesn't exceed $2\cdot 10^5$</p>
<h3>Output</h3>
<p>For each test case output $\texttt{YES}$ if it is possible that the sentence $s$ consists of precisely $a$ words $\texttt{A}$, $b$ words $\texttt{B}$, $c$ words $\texttt{AB}$, and $d$ words $\texttt{BA}$, and $\texttt{NO}$ otherwise. You can output each letter in any case</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">8
1 0 0 0
B
0 0 1 0
AB
1 1 0 1
ABAB
1 0 1 1
ABAAB
1 1 2 2
BAABBABBAA
1 1 2 3
ABABABBAABAB
2 3 5 4
AABAABBABAAABABBABBBABB
1 3 3 10
BBABABABABBBABABABABABABAABABA
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">NO
YES
YES
YES
YES
YES
NO
YES
</code></pre>
<h3>Note</h3>
<p>In the first test case, the sentence $s$ is $\texttt{B}$. Clearly, it can't consist of a single word $\texttt{A}$, so the answer is $\texttt{NO}$</p>
<p>In the second test case, the sentence $s$ is $\texttt{AB}$, and it's possible that it consists of a single word $\texttt{AB}$, so the answer is $\texttt{YES}$</p>
<p>In the third test case, the sentence $s$ is $\texttt{ABAB}$, and it's possible that it consists of one word $\texttt{A}$, one word $\texttt{B}$, and one word $\texttt{BA}$, as $\texttt{A} + \texttt{BA} + \texttt{B} = \texttt{ABAB}$</p>
<p>In the fourth test case, the sentence $s$ is $\texttt{ABAAB}$, and it's possible that it consists of one word $\texttt{A}$, one word $\texttt{AB}$, and one word $\texttt{BA}$, as $\texttt{A} + \texttt{BA} + \texttt{AB} = \texttt{ABAAB}$</p>
<p>In the fifth test case, the sentence $s$ is $\texttt{BAABBABBAA}$, and it's possible that it consists of one word $\texttt{A}$, one word $\texttt{B}$, two words $\texttt{AB}$, and two words $\texttt{BA}$, as $\texttt{BA} + \texttt{AB} + \texttt{B} + \texttt{AB} + \texttt{BA} + \texttt{A}= \texttt{BAABBABBAA}$</p>
<h3>代码参考</h3>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

{% icodeweb cpa_cpp title:CodeForces_1686D CodeForces/1686D/0.cpp %}

&lt;/details&gt;<h2>E - Bring Balance</h2>
<p>Alina has a bracket sequence $s$ of length $2n$, consisting of $n$ opening brackets '(' and $n$ closing brackets ')'. As she likes balance, she wants to turn this bracket sequence into a balanced bracket sequence</p>
<p>In one operation, she can reverse any substring of $s$</p>
<p>What's the smallest number of operations that she needs to turn $s$ into a balanced bracket sequence? It can be shown that it's always possible in at most $n$ operations</p>
<p>As a reminder, a sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters + and 1. For example, sequences (())(), (), and (()(())) are balanced, while )(, ((), and (()))( are not</p>
<h3>Input</h3>
<p>The first line of the input contains a single integer $t$ ($1 \le t \le 2 \cdot 10^4$) — the number of test cases. The description of the test cases follows</p>
<p>The first line of each test case contains a single integer $n$ ($1 \le n \le 10^5$)</p>
<p>The second line of each test case contains a string $s$ of length $2n$, consisting of $n$ opening and $n$ closing brackets</p>
<p>The sum of $n$ over all test cases doesn't exceed $2\cdot 10^5$</p>
<h3>Output</h3>
<p>For each test case, in the first line output a single integer $k$ $(0 \le k \le n)$ — the smallest number of operations required</p>
<p>The $i$-th of the next $k$ lines should contain two integers $l_i, r_i$ ($1 \le l_i \le r<em>i \le 2n$), indicating that in the $i$-th operation, Alina will reverse the substring $s<em>ls</em>{l+1} \ldots s\</em>{r-1}s_r$. Here the numeration starts from $1$</p>
<p>If there are multiple sequences of operations with the smallest length which transform the sequence into a balanced one, you can output any of them</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">3
2
(())
5
())((()))(
6
())((()))(()
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">0
2
3 4
9 10
1
2 11
</code></pre>
<h3>Note</h3>
<p>In the first test case, the string is already balanced</p>
<p>In the second test case, the string will be transformed as follows: ())((()))( $\to$ ()()(()))( $\to$ ()()(())(), where the last string is balanced</p>
<p>In the third test case, the string will be transformed to ((()))((())), which is balanced</p>
<h3>代码参考</h3>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

&lt;/details&gt;<h2>F - Permutation Weight (Easy Version)</h2>
<p><strong>This is an easy version of the problem. The difference between the easy and hard versions is that in this version, you can output any permutation with the smallest weight</strong></p>
<p>You are given a permutation $p_1, p_2, \ldots, p_n$ of integers from $1$ to $n$</p>
<p>Let's define the weight of the permutation $q_1, q_2, \ldots, q_n$ of integers from $1$ to $n$ as</p>
<p>$$
|q<em>1 - p</em>{q_{2}}| + |q<em>2 - p</em>{q<em>{3}}| + \ldots + |q</em>{n-1} - p<em>{q</em>{n}}| + |q<em>n - p</em>{q_{1}}|
$$</p>
<p>You want your permutation to be as lightweight as possible. Find any permutation $q$ with the smallest possible weight</p>
<h3>Input</h3>
<p>The first line of the input contains a single integer $t$ ($1 \le t \le 100$) — the number of test cases. The description of the test cases follows</p>
<p>The first line of each test case contains a single integer $n$ ($2 \le n \le 200$) — the size of the permutation</p>
<p>The second line of each test case contains $n$ integers $p_1, p_2, \ldots, p_n$ ($1 \le p_i \le n$, all $p_i$ are distinct) — the elements of the permutation</p>
<p>The sum of $n$ over all test cases doesn't exceed $400$</p>
<h3>Output</h3>
<p>For each test case, output $n$ integers $q_1, q_2, \ldots, q_n$ ($1 \le q_i \le n$, all $q_i$ are distinct) — one of the permutations with the smallest weight</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">3
2
2 1
4
2 3 1 4
5
5 4 3 2 1
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">1 2
1 3 4 2
1 4 2 3 5
</code></pre>
<h3>Note</h3>
<p>In the first test case, there are two permutations of length $2$: $(1, 2)$ and $(2, 1)$. Permutation $(1, 2)$ has weight $|1 - p_2| + |2 - p_1| = 0$, and permutation $(2, 1)$ has the same weight: $|2 - p_1| + |1 - p_2| = 0$. You can output any of these permutations in this version</p>
<p>In the second test case, the weight of the permutation $(1, 3, 4, 2)$ is $|1 - p_3| + |3 - p_4| + |4 - p_2| + |2 - p_1| = |1 - 1| + |3 - 4| + |4 - 3| + |2 - 2| = 2$. There are no permutations with smaller weights</p>
<p>In the third test case, the weight of the permutation $(1, 4, 2, 3, 5)$ is $|1 - p_4| + |4 - p_2| + |2 - p_3| + |3 - p_5| + |5 - p_1| = |1 - 2| + |4 - 4| + |2 - 3| + |3 - 1| + |5 - 5| = 4$. There are no permutations with smaller weights</p>
<h3>代码参考</h3>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

&lt;/details&gt;