<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/cf1761.md">仓库源文</a>，<a href="https://tifa-233.com/archives/cf1761">站点原文</a></h2>
<p><a href="https://codeforces.com/contest/1761">比赛链接</a></p>
<p>进度: 5 / 8</p>
<p>被二次元猫娘骗了</p>
<p>还以为这场是二次元场, 结果全场的二次元成分只在 Announcement 有</p>
<p>Upd: 之后发现这个猫娘是出题组的二次元形象</p>
&lt;!-- more --&gt;

<h2>A - Two Permutations</h2>
<p>You are given three integers $n$, $a$, and $b$. Determine if there exist two permutations $p$ and $q$ of length $n$, for which the following conditions hold:</p>
<ul>
<li>The length of the longest common prefix of $p$ and $q$ is $a$</li>
<li>The length of the longest common suffix of $p$ and $q$ is $b$</li>
</ul>
<p>A permutation of length $n$ is an array containing each integer from $1$ to $n$ exactly once. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array)</p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains a single integer $t$ ($1\leq t\leq 10^4$) — the number of test cases. The description of test cases follows</p>
<p>The only line of each test case contains three integers $n$, $a$, and $b$ ($1\leq a,b\leq n\leq 100$)</p>
<h3>Output</h3>
<p>For each test case, if such a pair of permutations exists, output "<code>Yes</code>"; otherwise, output "<code>No</code>". You can output each letter in any case (upper or lower)</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">4
1 1 1
2 1 2
3 1 1
4 1 1
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">Yes
No
No
Yes
</code></pre>
<h3>Note</h3>
<p>In the first test case, $[1]$ and $[1]$ form a valid pair</p>
<p>In the second test case and the third case, we can show that such a pair of permutations doesn't exist</p>
<p>In the fourth test case, $[1,2,3,4]$ and $[1,3,2,4]$ form a valid pair</p>
<h3>代码参考</h3>
<p>{% icodeweb cpa_cpp title:CodeForces_1761A CodeForces/1761A/0.cpp %}</p>
<h2>B - Elimination of a Ring</h2>
<p>Define a cyclic sequence of size $n$ as an array $s$ of length $n$, in which $s_n$ is adjacent to $s_1$</p>
<p>Muxii has a ring represented by a cyclic sequence $a$ of size $n$</p>
<p>However, the ring itself hates equal adjacent elements. So if two adjacent elements in the sequence are equal at any time, <strong>one of them</strong> will be erased <strong>immediately</strong>. The sequence doesn't contain equal adjacent elements initially</p>
<p>Muxii can perform the following operation until the sequence becomes empty:</p>
<ul>
<li>Choose an element in $a$ and erase it</li>
</ul>
<p>For example, if ring is $[1, 2, 4, 2, 3, 2]$, and Muxii erases element $4$, then ring would erase one of the elements equal to $2$, and the ring will become $[1, 2, 3, 2]$</p>
<p>Muxii wants to find the <strong>maximum</strong> number of operations he could perform</p>
<p><strong>Note that in a ring of size</strong> $1$, <strong>its only element isn't considered adjacent to itself (so it's not immediately erased)</strong></p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains a single integer $t$ ($1\leq t\leq 100$) — the number of test cases. The description of test cases follows</p>
<p>The first line of each test case contains a single integer $n$ ($1\leq n\leq 100$) — the size of the cyclic sequence</p>
<p>The second line of each test case contains $n$ integers $a_1,a_2,\ldots,a_n$ ($1\leq a_i\leq n$) — the sequence itself</p>
<p>It's guaranteed that $a<em>i\ne a</em>{i+1}$ for $1\leq i&lt;n$</p>
<p>It's guaranteed that $a_n\ne a_1$ when $n&gt;1$</p>
<h3>Output</h3>
<p>For each test case, output a single integer — the maximum number of operations Muxii can perform</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">3
4
1 2 3 2
4
1 2 1 2
1
1
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">4
3
1
</code></pre>
<h3>Note</h3>
<p>In the first test case, you can erase the second element first, then erase the remaining elements one by one in any order. In total, you can perform the operation $4$ times. Note that if you erase the first element first, then the sequence will be turned into $[2,3,2]$ and then immediately become $[2,3]$</p>
<p>In the second test case, you can erase the first element first, then the sequence becomes $[2,1]$. Then you can erase all remaining elements one by one in any order</p>
<h3>代码参考</h3>
<p>{% icodeweb cpa_cpp title:CodeForces_1761B CodeForces/1761B/0.cpp %}</p>
<h2>C - Set Construction</h2>
<p>You are given a binary matrix $b$ (all elements of the matrix are $0$ or $1$) of $n$ rows and $n$ columns</p>
<p>You need to construct a $n$ sets $A_1, A_2, \ldots, A_n$, for which the following conditions are satisfied:</p>
<ul>
<li>Each set is nonempty and consists of distinct integers between $1$ and $n$ inclusive</li>
<li>All sets are distinct</li>
<li>For all pairs $(i,j)$ satisfying $1\leq i, j\leq n$, $b_{i,j}=1$ if and only if $A_i\subsetneq A<em>j$. In other words, $b</em>{i, j}$ is $1$ if $A_i$ is a proper subset of $A_j$ and $0$ otherwise</li>
</ul>
<p>Set $X$ is a proper subset of set $Y$, if $X$ is a nonempty subset of $Y$, and $X \neq Y$</p>
<p>It's guaranteed that for all test cases in this problem, such $n$ sets exist. <strong>Note that it doesn't mean that such</strong> $n$ <strong>sets exist for all possible inputs</strong></p>
<p>If there are multiple solutions, you can output any of them</p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains a single integer $t$ ($1\le t\le 1000$) — the number of test cases. The description of test cases follows</p>
<p>The first line contains a single integer $n$ ($1\le n\le 100$)</p>
<p>The following $n$ lines contain a binary matrix $b$, the $j$-th character of $i$-th line denotes $b_{i,j}$</p>
<p>It is guaranteed that the sum of $n$ over all test cases does not exceed $1000$</p>
<p>It's guaranteed that for all test cases in this problem, such $n$ sets exist</p>
<h3>Output</h3>
<p>For each test case, output $n$ lines</p>
<p>For the $i$-th line, first output $s_i$ $(1 \le s_i \le n)$ — the size of the set $A_i$. Then, output $s_i$ distinct integers from $1$ to $n$ — the elements of the set $A_i$</p>
<p>If there are multiple solutions, you can output any of them</p>
<p>It's guaranteed that for all test cases in this problem, such $n$ sets exist</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">2
4
0001
1001
0001
0000
3
011
001
000
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">3 1 2 3
2 1 3
2 2 4
4 1 2 3 4
1 1
2 1 2
3 1 2 3
</code></pre>
<h3>Note</h3>
<p>In the first test case, we have $A_1 = {1, 2, 3}, A_2 = {1, 3}, A_3 = {2, 4}, A_4 = {1, 2, 3, 4}$. Sets $A_1, A_2, A_3$ are proper subsets of $A_4$, and also set $A_2$ is a proper subset of $A_1$. No other set is a proper subset of any other set</p>
<p>In the second test case, we have $A_1 = {1}, A_2 = {1, 2}, A_3 = {1, 2, 3}$. $A_1$ is a proper subset of $A_2$ and $A_3$, and $A_2$ is a proper subset of $A_3$</p>
<h3>代码参考</h3>
<p>{% icodeweb cpa_cpp title:CodeForces_1761C CodeForces/1761C/0.cpp %}</p>
<h2>D - Carry Bit</h2>
<p>Let $f(x,y)$ be the number of carries of $x+y$ in binary (i. e. $f(x,y)=g(x)+g(y)-g(x+y)$, where $g(x)$ is the number of ones in the binary representation of $x$)</p>
<p>Given two integers $n$ and $k$, find the number of ordered pairs $(a,b)$ such that $0 \leq a,b &lt; 2^n$, and $f(a,b)$ equals $k$. Note that for $a\ne b$, $(a,b)$ and $(b,a)$ are considered as two different pairs</p>
<p>As this number may be large, output it modulo $10^9+7$</p>
<h3>Input</h3>
<p>The only line of each test contains two integers $n$ and $k$ ($0\leq k&lt;n\leq 10^6$)</p>
<h3>Output</h3>
<p>Output a single integer — the answer modulo $10^9+7$</p>
<h3>Examples</h3>
<h4>input</h4>
<pre><code class="lang-input1">3 1
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">15
</code></pre>
<h4>input</h4>
<pre><code class="lang-input2">3 0
</code></pre>
<h4>output</h4>
<pre><code class="lang-output2">27
</code></pre>
<h4>input</h4>
<pre><code class="lang-input3">998 244
</code></pre>
<h4>output</h4>
<pre><code class="lang-output3">573035660
</code></pre>
<h3>Note</h3>
<p>Here are some examples for understanding carries:</p>
<p>$$
\begin{aligned}
  &amp; \begin{array}{r}
    1{\ \ }1{\ \ }1\
    +\ <em>{1}1</em>{\ \ }0{\ \ }0\
    \hline
    \ 1{\ \ }0{\ \ }1{\ \ }1
  \end{array}
  &amp; \begin{array}{r}
    \ 1{\ \ }0{\ \ }1\
    +\ <em>{\ \ }0</em>{\ \ }0{}<em>{1}1\
    \hline
    \ 0{\ \ }1{\ \ }1{\ \ }0
  \end{array}
  &amp; &amp;\begin{array}{r}
    \ 1{\ \ }0{\ \ }1\
    +\ </em>{1}0<em>{1}1{}</em>{1}1\
    \hline
    \ 1{\ \ }0{\ \ }0{\ \ }0
  \end{array}
\end{aligned}
$$</p>
<p>So $f(7,4)=1$, $f(5,1)=1$ and $f(5,3)=3$</p>
<p>In the first test case, all the pairs meeting the constraints are</p>
<p>$$
\begin{array}{lllll}
  (1,1)&amp;(1,5)&amp;(2,2)&amp;(2,3)&amp;(3,2)\
  (4,4)&amp;(4,5)&amp;(4,6)&amp;(4,7)&amp;(5,1)\
  (5,4)&amp;(5,6)&amp;(6,4)&amp;(6,5)&amp;(7,4)
\end{array}
$$</p>
<h3>代码参考</h3>
<p>{% icodeweb cpa_cpp title:CodeForces_1761D CodeForces/1761D/0.cpp %}</p>
<h2>E - Make It Connected</h2>
<p>You are given a simple undirected graph consisting of $n$ vertices. The graph doesn't contain self-loops, there is at most one edge between each pair of vertices. Your task is simple: make the graph connected</p>
<p>You can do the following operation any number of times (possibly zero):</p>
<ul>
<li>Choose a vertex $u$ arbitrarily</li>
<li>For each vertex $v$ satisfying $v\ne u$ in the graph individually, if $v$ is adjacent to $u$, remove the edge between $u$ and $v$, otherwise add an edge between $u$ and $v$</li>
</ul>
<p>Find the minimum number of operations required to make the graph connected. Also, find any sequence of operations with the minimum length that makes the graph connected</p>
<h3>Input</h3>
<p>Each test contains multiple test cases. The first line contains a single integer $t$ ($1\leq t\leq 800$) — the number of test cases. The description of test cases follows</p>
<p>The first line of each test case contains a single integer $n$ ($2\leq n\leq 4000$) — the number of vertices in the graph</p>
<p>Then $n$ lines follow. The $i$-th row contains a binary string $s<em>i$ of length $n$, where $s</em>{i,j}$ is '1' if there is an edge between vertex $i$ and $j$ initially, otherwise $s_{i,j}$ is '0'</p>
<p>It is guaranteed that $s<em>{i,i}$ is always '0' and $s</em>{i,j}=s_{j,i}$ for $1\leq i,j\leq n$</p>
<p>It is guaranteed that the sum of $n$ over all test cases does not exceed $4000$</p>
<h3>Output</h3>
<p>For each test case, in the first line, output an integer $m$ — the minimum number of operations required</p>
<p>If $m$ is greater than zero, then print an extra line consisting of $m$ integers — the vertices chosen in the operations in your solution. If there are multiple solutions with the minimum number of operations, print any</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">4
3
011
100
100
3
000
001
010
4
0100
1000
0001
0010
6
001100
000011
100100
101000
010001
010010
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">0
1
1
2
3 4
3
2 5 6
</code></pre>
<h3>Note</h3>
<p>In the first test case, the graph is connected at the beginning, so the answer is $0$</p>
<p>In the second test case, if we do the operation with vertex $1$, we will get the following graph represented by an adjacency matrix:</p>
<p>$$
\begin{bmatrix}
  0&amp;1&amp;1\
  1&amp;0&amp;1\
  1&amp;1&amp;0
\end{bmatrix}
$$</p>
<p>It's obvious that the graph above is connected</p>
<p>In the third test case, if we do the operation with vertex $3$ and $4$, we will get the following graph represented by an adjacency matrix:</p>
<p>$$
\begin{bmatrix}
  0&amp;1&amp;1&amp;1\
  1&amp;0&amp;1&amp;1\
  1&amp;1&amp;0&amp;1\
  1&amp;1&amp;1&amp;0
\end{bmatrix}
$$</p>
<p>It's obvious that the graph above is connected, and it can be proven that we can't perform less than $2$ operations to make the graph connected</p>
<h3>代码参考</h3>
<p>{% icodeweb cpa_cpp title:CodeForces_1761E CodeForces/1761E/0.cpp %}</p>
<h2>F1 - Anti-median (Easy Version)</h2>
<p><strong>This is the easy version of the problem. The only difference between the two versions is the constraint on</strong> $n$. <strong>You can make hacks only if all versions of the problem are solved</strong></p>
<p>Let's call an array $a$ of odd length $2m+1$ (with $m \ge 1$) <strong>bad</strong>, if element $a_{m+1}$ is equal to the median of this array. In other words, the array is bad if, after sorting it, the element at $m+1$-st position remains the same</p>
<p>Let's call a permutation $p$ of integers from $1$ to $n$ <strong>anti-median</strong>, if every its subarray of odd length $\ge 3$ is not bad</p>
<p>You are already given values of some elements of the permutation. Find the number of ways to set unknown values to obtain an <strong>anti-median</strong> permutation. As this number can be very large, find it modulo $10^9+7$</p>
<h3>Input</h3>
<p>The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases. The description of test cases follows</p>
<p>The first line of each test case contains a single integer $n$ $(2 \le n \le 1000)$ — the length of the permutation</p>
<p>The second line of each test case contains $n$ integers $p_1, p_2, \ldots, p_n$ ($1 \le p_i \le n$, or $p_i = -1$) — the elements of the permutation. If $p_i \neq -1$, it's given, else it's unknown. It's guaranteed that if for some $i \neq j$ holds $p_i \neq -1, p_j \neq -1$, then $p_i \neq p_j$</p>
<p>It is guaranteed that the sum of $n^2$ over all test cases does not exceed $10^6$</p>
<h3>Output</h3>
<p>For each test case, output a single integer — the number of ways to set unknown values to obtain an anti-median permutation, modulo $10^9+7$</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">5
2
-1 -1
3
-1 -1 -1
4
1 2 3 4
6
-1 -1 3 4 -1 -1
8
-1 -1 -1 -1 -1 -1 -1 -1
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">2
4
0
1
316
</code></pre>
<h3>Note</h3>
<p>In the first test case, both $[1, 2]$ and $[2, 1]$ are anti-median</p>
<p>In the second test case, permutations $[1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]$ are anti-median. The remaining two permutations, $[1, 2, 3]$, $[3, 2, 1]$, are bad arrays on their own, as their median, $2$, is in their middle</p>
<p>In the third test case, $[1, 2, 3, 4]$ isn't anti-median, as it contains bad subarray $[1, 2, 3]$</p>
<p>In the fourth test case, the only anti-median array you can get is $[5, 6, 3, 4, 1, 2]$</p>
<h3>代码参考</h3>
<h2>F2 - Anti-median (Hard Version)</h2>
<p><strong>This is the hard version of the problem. The only difference between the two versions is the constraint on</strong> $n$. <strong>You can make hacks only if all versions of the problem are solved</strong></p>
<p>Let's call an array $a$ of odd length $2m+1$ (with $m \ge 1$) <strong>bad</strong>, if element $a_{m+1}$ is equal to the median of this array. In other words, the array is bad if, after sorting it, the element at $m+1$-st position remains the same</p>
<p>Let's call a permutation $p$ of integers from $1$ to $n$ <strong>anti-median</strong>, if every its subarray of odd length $\ge 3$ is not bad</p>
<p>You are already given values of some elements of the permutation. Find the number of ways to set unknown values to obtain an <strong>anti-median</strong> permutation. As this number can be very large, find it modulo $10^9+7$</p>
<h3>Input</h3>
<p>The first line contains a single integer $t$ ($1 \le t \le 10^4$) — the number of test cases. The description of test cases follows</p>
<p>The first line of each test case contains a single integer $n$ $(2 \le n \le 10^6)$ — the length of the permutation</p>
<p>The second line of each test case contains $n$ integers $p_1, p_2, \ldots, p_n$ ($1 \le p_i \le n$, or $p_i = -1$) — the elements of the permutation. If $p_i \neq -1$, it's given, else it's unknown. It's guaranteed that if for some $i \neq j$ holds $p_i \neq -1, p_j \neq -1$, then $p_i \neq p_j$</p>
<p>It is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$</p>
<h3>Output</h3>
<p>For each test case, output a single integer — the number of ways to set unknown values to obtain an anti-median permutation, modulo $10^9+7$</p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">5
2
-1 -1
3
-1 -1 -1
4
1 2 3 4
6
-1 -1 3 4 -1 -1
8
-1 -1 -1 -1 -1 -1 -1 -1
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">2
4
0
1
316
</code></pre>
<h3>Note</h3>
<p>In the first test case, both $[1, 2]$ and $[2, 1]$ are anti-median</p>
<p>In the second test case, permutations $[1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]$ are anti-median. The remaining two permutations, $[1, 2, 3]$, $[3, 2, 1]$, are bad arrays on their own, as their median, $2$, is in their middle</p>
<p>In the third test case, $[1, 2, 3, 4]$ isn't anti-median, as it contains bad subarray $[1, 2, 3]$</p>
<p>In the fourth test case, the only anti-median array you can get is $[5, 6, 3, 4, 1, 2]$</p>
<h3>代码参考</h3>
<h2>G - Centroid Guess</h2>
<p><strong>This in an interactive problem</strong></p>
<p>There is an unknown tree consisting of $n$ nodes, which has <strong>exactly one</strong> centroid. You only know $n$ at first, and your task is to find the centroid of the tree</p>
<p>You can ask the distance between any two vertices for at most $2\cdot10^5$ times</p>
<p>Note that the interactor is <strong>not</strong> adaptive. That is, the tree is fixed in each test beforehand and does not depend on your queries</p>
<p>A vertex is called a centroid if its removal splits the tree into subtrees with at most $\lfloor\frac{n}{2}\rfloor$ vertices each</p>
<h3>Input</h3>
<p>The only line of the input contains an integer $n$ ($3\le n\le 7.5\cdot10^4$) — the number of nodes in the tree</p>
<p>Interaction
Start interaction by reading $n$</p>
<p>To ask a query about the distance between two nodes $u, v$ ($1 \le u, v \le n$), output "? u v"</p>
<p>If you determine that the centroid of the tree is $x$, use "! x" to report</p>
<p>After printing a query, do not forget to output the end of a line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:</p>
<ul>
<li><code>fflush(stdout)</code> or <code>cout.flush()</code> in C++;</li>
<li><code>System.out.flush()</code> in Java;</li>
<li><code>flush(output)</code> in Pascal;</li>
<li><code>stdout.flush()</code> in Python;</li>
<li>see documentation for other languages</li>
</ul>
<p><strong>Hacks are disabled in this problem</strong></p>
<p><strong>It's guaranteed that there are at most</strong> $500$ <strong>tests in this problem</strong></p>
<h3>Example</h3>
<h4>input</h4>
<pre><code class="lang-input1">5

2

1

2

3

1

1

1
</code></pre>
<h4>output</h4>
<pre><code class="lang-output1">
? 1 2

? 1 3

? 1 4

? 1 5

? 2 3

? 3 4

? 4 5

! 3
</code></pre>
<h3>Note</h3>
<p>Here is an image of the tree from the sample</p>
<p><img alt="" src="/Users/xuanwu/work/聚聚/中文博客集锦/源数据/博客聚合/tifa-233.com/source/_posts/G-1.webp"/></p>
<h3>代码参考</h3>
