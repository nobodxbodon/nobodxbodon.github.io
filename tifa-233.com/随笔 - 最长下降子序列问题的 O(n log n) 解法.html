<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/draft-015.md">仓库源文</a>，<a href="https://tifa-233.com/archives/draft-015">站点原文</a></h2>
<p>科普文, 看看就好</p>
&lt;!-- more --&gt;

<h2>算法流程</h2>
<p>设 <code>a[]</code> 为原序列, <code>s[]</code> 为辅助数组</p>
<ol>
<li><code>a</code> 中第一个元素插入 <code>s</code> 的末尾</li>
<li><p>遍历 <code>a</code>, 从第二个元素取到最后一个</p>
<ol>
<li>如果当前遍历到的元素小于 <code>s</code> 的末尾, 则将其插入 <code>s</code> 的末尾</li>
<li><p>否则在队内二分查找比当前元素大的最小元素, 将该元素替换为当前遍历到的元素</p>
<p>如果找不到这样的元素, 则清空 <code>s</code> 并将当前遍历到的元素插入 <code>s</code> 的末尾即可</p>
<blockquote><p>因为此时除了 <code>s</code> 末尾的元素之外, <code>s</code> 内的其余元素不会影响到答案</p>
<p>而当前遍历到的元素更有可能成为最长下降子序列内的元素</p>
<p>故直接替换即可</p>
</blockquote>
</li>
</ol>
</li>
<li><p><code>s</code> 的长度即为最长下降子序列长度</p>
</li>
</ol>
<h2>复杂度</h2>
<p>令原序列长度为 $n$</p>
<ul>
<li>时间复杂度: $O(n\log n)$</li>
<li>空间复杂度: $O(n)$</li>
</ul>
<h2>代码</h2>
&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;

{% icodeweb blog lang:cpp draft-015/main.cpp %}

&lt;/details&gt;