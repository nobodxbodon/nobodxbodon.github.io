<p>版权声明： 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>
<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/cf696a.md">仓库源文</a>，<a href="https://tifa-233.com/archives/cf696a">站点原文</a></h2>
<hr/>
<p>title: "题解 - [CodeForces 696 A] Lorenzo Von Matterhorn"
categories:</p>
<ul>
<li>算法竞赛</li>
<li>题解
tags:</li>
<li>算法竞赛</li>
<li>题解</li>
<li>Codeforces</li>
<li>数据结构</li>
<li>完全二叉树
date: 2020-07-25 00:48:00</li>
</ul>
<hr/>
<p><a href="https://codeforces.com/problemset/problem/696/A">题目链接</a></p>
<p>&lt;!-- more --&gt;</p>
<h2>简述题意</h2>
<p>给出一棵完全二叉树, 对其上任意结点 $i$, 其子结点只能为 $2i$ 和 $2i+1$, 其父结点只能为 $\lfloor\frac{i}{2}\rfloor$</p>
<p>处理两种操作</p>
<ol>
<li><code>1 u v w</code>: 将从<code>u</code>到<code>v</code>的最短路径经过的所有边加上权值<code>w</code> (权值不影响路径长度)</li>
<li><code>2 u v</code>: 统计从<code>u</code>到<code>v</code>的最短路径经过的所有边权值之和</li>
</ol>
<h2>解题思路</h2>
<p>对于树来说, 实现这两种操作我们自然会想到 LCA 之类的, 不过这道题有一个巧妙的解法可以绕过这些知识</p>
<p>我们用一个<code>map</code>来记录权值的变化, 在更新和查询权值时, 我们从<code>u</code>, <code>v</code>向上查找, 直到到达了<code>lca(u, v)</code>为止</p>
<p>由于这是在完全二叉树上, 我们并不需要去求<code>lca(u, v)</code>, 我们只需这样: 在每次循环的时候选<code>u</code>和<code>v</code>中编号较大的那个, 一边维护一边向上回溯, 当<code>u</code>和<code>v</code>相等的时候我们就已经维护到了<code>lca(u, v)</code>, 题目自然就解决了</p>
<h2>代码</h2>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:CodeForces_696A CodeForces/696A/0.cpp %}</p>
<p>&lt;/details&gt;</p>
