<h2><a href="https://github.com/Tiphereth-A/Tiphereth-A.github.io/blob/master/source/_posts/cf501d.md">仓库源文</a>，<a href="https://tifa-233.com/cf501d">站点原文</a></h2>
<hr/>
<p>title: "题解 - [CodeForces 501 D] Misha and Permutations Summation"
categories:</p>
<ul>
<li>算法竞赛</li>
<li>题解
tags:</li>
<li>算法竞赛</li>
<li>题解</li>
<li>Codeforces</li>
<li>数学</li>
<li>组合数学</li>
<li>Cantor展开</li>
<li>逆Cantor展开
date: 2020-11-15 00:21:06</li>
</ul>
<hr/>
<p><a href="https://codeforces.com/problemset/problem/501/D">题目链接</a></p>
<p>&lt;!-- more --&gt;</p>
<h2>原始题面</h2>
<p>Let's define the sum of two permutations $p$ and $q$ of numbers $0, 1, ..., (n - 1)$ as permutation $\texttt{Perm}((\texttt{Ord}(p)+\texttt{Ord}(q))\bmod n!)$, where $\texttt{Perm}(x)$ is the x-th lexicographically permutation of numbers $0, 1, ..., (n - 1)$ (counting from zero), and $\texttt{Ord}(p)$ is the number of permutation $p$ in the lexicographical order</p>
<p>For example, $\texttt{Perm}(0) = (0, 1, ..., n - 2, n - 1)$, $\texttt{Perm}(n! - 1) = (n - 1, n - 2, ..., 1, 0)$</p>
<p>Misha has two permutations, $p$ and $q$. Your task is to find their sum</p>
<p>Permutation $a = (a_0, a_1, ..., a_{n - 1})$ is called to be lexicographically smaller than permutation $b = (b_0, b_1, ..., b_{n - 1})$, if for some k following conditions hold:</p>
<p>$$
a_0 = b_0, a_1 = b_1, ..., a_{k - 1} = b_{k - 1}, a_k &lt; b_k
$$</p>
<h3>Input</h3>
<p>The first line contains an integer $n$ ($1 ≤ n ≤ 200 000$)</p>
<p>The second line contains n distinct integers from $0$ to $n - 1$, separated by a space, forming permutation $p$</p>
<p>The third line contains n distinct integers from $0$ to $n - 1$, separated by spaces, forming permutation $q$</p>
<h3>Output</h3>
<p>Print $n$ distinct integers from $0$ to $n - 1$, forming the sum of the given permutations. Separate the numbers by spaces</p>
<h3>Examples</h3>
<h4>Input 1</h4>
<pre><code class="language-input1">2
0 1
0 1
</code></pre>
<h4>Output 1</h4>
<pre><code class="language-output1">0 1
</code></pre>
<h4>Input 2</h4>
<pre><code class="language-input2">2
0 1
1 0
</code></pre>
<h4>Output 2</h4>
<pre><code class="language-output2">1 0
</code></pre>
<h4>Input 3</h4>
<pre><code class="language-input3">3
1 2 0
2 1 0
</code></pre>
<h4>Output 3</h4>
<pre><code class="language-output3">1 0 2
</code></pre>
<h3>Note</h3>
<p>Permutations of numbers from $0$ to $1$ in the lexicographical order: $(0, 1), (1, 0)$</p>
<p>In the first sample $\texttt{Ord}(p) = 0$ and $\texttt{Ord}(q) = 0$, so the answer is $\texttt{Perm}((0+0)\bmod 2)=\texttt{Perm}(0)=(0, 1)$</p>
<p>In the second sample $\texttt{Ord}(p) = 0$ and $\texttt{Ord}(q) = 1$, so the answer is $\texttt{Perm}((0+1)\bmod 2)=\texttt{Perm}(1)=(1, 0)$</p>
<p>Permutations of numbers from $0$ to $2$ in the lexicographical order: $(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)$</p>
<p>In the third sample $\texttt{Ord}(p) = 3$ and $\texttt{Ord}(q) = 5$, so the answer is $\texttt{Perm}((3+5)\bmod 6)=\texttt{Perm}(2)=(1, 0, 2)$</p>
<h2>题意简述</h2>
<p>现在有两个长度为 $n$ 的排列, 由 $0,1,2...n-1$ 这 $n$ 个数字组成</p>
<p>对于一个排列 $p$, $\texttt{Ord}(p)$ 表示 $p$ 是字典序第 $\texttt{Ord}(p)$ 小的排列 (从 $0$ 开始计数)</p>
<p>对于小于 $n!$ 的非负数 $x$, $\texttt{Perm}(x)$ 表示字典序第 $x$ 小的排列</p>
<p>给出两个排列 $p$ 和 $q$, 求 $\texttt{Perm}((\texttt{Ord}(p)+\texttt{Ord}(q))\bmod n!)$</p>
<blockquote>
<p>from <a href="https://www.luogu.com.cn/discuss/show/188178">https://www.luogu.com.cn/discuss/show/188178</a></p>
</blockquote>
<h2>解题思路</h2>
<p>显然是 Cantor 展开和逆 Cantor 展开的模板题</p>
<p>但这题的 $n$ 是 <code>2e5</code> 的, 我们肯定不能直接套板子</p>
<p>注意到 $d(A)=P_Af_n^T$, 对于给出的 $p,q$, 我们可以考虑直接将 $P_p,P_q$ 相加并还原即可</p>
<p>另外注意在 CF 的评测环境是 32 位的, 即<code>std::size_t</code>是<code>unsigned int</code>而不是<code>uint64_t</code></p>
<h2>复杂度</h2>
<p>$O(n\log n)$</p>
<h2>代码参考</h2>
<p>&lt;details open&gt;
&lt;summary&gt;&lt;font color='orange'&gt;Show code&lt;/font&gt;&lt;/summary&gt;</p>
<p>{% icodeweb cpa_cpp title:CodeForces_501D CodeForces/501D/0.cpp %}</p>
<p>&lt;/details&gt;</p>
